# **Временно не распределенные вопросы**`(Все требует доработки)`

# **Веб-разработка: Архитектура, запросы, CORS**

## 1. Архитектура проекта и ее отличие от структуры. Какие архитектуры использовал?

## 3. Что такое CORS?

`CORS (Cross-Origin Resource Sharing)` — это механизм, который позволяет ограничить или разрешить доступ к ресурсам веб-сайта с других доменов. Он используется для обеспечения безопасности веб-приложений, чтобы предотвратить несанкционированный доступ к данным.

Когда веб-страница пытается сделать запрос (например, AJAX-запрос) к ресурсу на другом домене, браузер сначала отправляет предварительный запрос (preflight request) методом OPTIONS. Сервер может ответить, указав, какие домены могут получать доступ к ресурсам, какие методы разрешены (GET, POST и т.д.) и какие заголовки могут использоваться.

Основные элементы CORS включают:

1. **`Заголовки CORS`**: Сервер может отправлять специальные заголовки, такие как `Access-Control-Allow-Origin`, чтобы указать, какие домены могут получать доступ к ресурсам.

2. **`Preflight-запросы`**: Перед выполнением некоторых типов запросов (например, методов, отличных от GET и POST) браузер отправляет предварительный запрос, чтобы проверить, разрешен ли доступ.

3. **`Настройка на стороне сервера`**: Чтобы использовать CORS, необходимо настроить сервер для отправки соответствующих заголовков.

CORS важен для обеспечения безопасности веб-приложений, предотвращая атаки, такие как межсайтовый скриптинг (XSS(Cross-Site Scripting)) и кража данных.

## 4. Как поддерживать постоянное соединение?

Для поддержания постоянного соединения в веб-приложениях можно использовать несколько подходов:

1. **`WebSockets`**:
   - WebSockets обеспечивают двустороннюю связь между клиентом и сервером. Они позволяют отправлять и получать данные в реальном времени, что делает их отличным выбором для приложений, требующих постоянного соединения (например, чаты, игры).
   - Для использования WebSocket в React можно использовать библиотеку `socket.io-client` или встроенные API браузера.

2. **`Long Polling`**:
   - В этом методе клиент отправляет запрос на сервер и держит соединение открытым до тех пор, пока сервер не ответит. После получения ответа клиент сразу же отправляет новый запрос, создавая эффект постоянного соединения. 
   - Этот подход менее эффективен по сравнению с WebSockets, но может быть использован, если WebSockets недоступны.

3. **`Server-Sent Events (SSE)`**:
   - SSE позволяет серверу отправлять обновления клиенту через однонаправленное соединение. Это полезно для приложений, где необходимо получать данные с сервера, но не требуется отправлять их обратно.
   - SSE поддерживается в большинстве современных браузеров.

4. **`Обновление данных с интервалами`**:
   - Если ваше приложение не требует мгновенных обновлений, вы можете периодически отправлять запросы к серверу для получения обновленных данных (например, каждые 5 секунд). Это просто в реализации, но может быть менее эффективным.

5. **`Реакция на события`**:
   - Используйте библиотеки, такие как `Redux` или `React Query`, для управления состоянием и выполнения асинхронных запросов. Они помогут оптимизировать процесс получения данных и поддерживать состояние приложения актуальным.

## 5. Что такое микрофронтенды?

## 6. Code splitting, чанки, tree shaking в Webpack?

## 7. Зачем нужен ESLint, настройка и плагины?

`ESLint` — это инструмент статического анализа кода для JavaScript и других языков, основанных на JavaScript, который помогает разработчикам выявлять и устранять проблемы в коде. Вот несколько основных причин, почему ESLint полезен:

1. **`Поиск ошибок`**: ESLint позволяет находить синтаксические ошибки и потенциальные проблемы в коде, что помогает избежать ошибок выполнения.

2. **`Соблюдение стиля кода`**: Он помогает поддерживать единообразный стиль кода, обеспечивая соблюдение заданных правил оформления. Это делает код более читаемым и понятным для других разработчиков.

3. **`Кастомизация`**: Вы можете настроить ESLint под свои нужды, добавляя или изменяя правила в зависимости от стандартов вашей команды или проекта.

4. **`Интеграция с редакторами`**: ESLint легко интегрируется с различными текстовыми редакторами и IDE, такими как WebStorm, Visual Studio Code и другими, что позволяет получать мгновенные подсказки и предупреждения о проблемах в коде.

5. **`Улучшение качества кода`**: Использование ESLint способствует написанию более качественного и поддерживаемого кода, что особенно важно в крупных проектах.

6. **`Поддержка различных конфигураций`**: ESLint поддерживает конфигурации, такие как Airbnb, Google и другие, что упрощает интеграцию общепринятых стандартов.

## 8. Что происходит, когда вводим запрос в адресную строку браузера?

Когда вы вводите запрос в адресную строку браузера, происходит несколько последовательных шагов:

1. **`Парсинг запроса`**: Браузер обрабатывает введённый текст, определяя, является ли это URL или поисковым запросом. Если это URL, браузер может распознать протокол (например, HTTP или HTTPS) и доменное имя.

2. **`DNS-запрос`**: Если вы ввели URL, браузер обращается к DNS-серверу для получения IP-адреса сервера, на котором расположен сайт. DNS (Domain Name System) переводит человекочитаемые домены (например, www.example.com) в машинные IP-адреса.

3. **`Установка TCP-соединения`**: Браузер устанавливает соединение с сервером через протокол TCP (Transmission Control Protocol), используя IP-адрес, полученный на предыдущем шаге.

4. **`TLS/SSL-шифрование (если используется HTTPS)`**: Если вы обращаетесь к защищённому сайту (HTTPS), происходит установка защищённого соединения с помощью протоколов TLS (Transport Layer Security) или SSL (Secure Sockets Layer).

5. **`Отправка HTTP-запроса`**: Браузер отправляет HTTP-запрос на сервер. Запрос может содержать информацию о запрашиваемом ресурсе, метод запроса (GET, POST и т.д.), а также заголовки с дополнительной информацией.

6. **`Обработка запроса сервером`**: Сервер получает запрос и обрабатывает его. Он может извлекать данные из базы данных, выполнять бизнес-логику и генерировать ответ.

7. **`Отправка HTTP-ответа`**: После обработки запроса сервер отправляет обратно HTTP-ответ, который содержит статус (например, 200 OK, 404 Not Found и т.д.), заголовки и тело ответа (обычно HTML-код страницы).

8. **`Получение ответа и рендеринг страницы`**: Браузер получает ответ и начинает его обрабатывать. Он парсит HTML, загружает ресурсы (CSS, JavaScript, изображения и т.д.), и отображает страницу на экране.

9. **`Выполнение JavaScript`**: Если на странице есть JavaScript-код, браузер выполняет его, что может привести к динамическому изменению содержимого страницы.

10. **`Кэширование`**: Некоторые ресурсы могут быть закэшированы, чтобы ускорить последующие запросы к тому же сайту.

# **ООП и паттерны**
1. Что такое ООП?
2. Какие паттерны знаешь? (порождающие, структурные, поведенческие)
1. Как работают классы под капотом? Прототипы.

# **HTTP и сети**

## 1. Что такое идемпотентность? Какие методы запросов являются идемпотентными?

`Идемпотентность` — это свойство операций, при котором выполнение одной и той же операции несколько раз приводит к одному и тому же результату. В контексте веб-разработки и HTTP-запросов идемпотентность означает, что повторное выполнение одного и того же запроса не должно изменять состояние ресурса после первого выполнения.

### `Методы запросов, которые являются идемпотентными:`

1. **`GET`**: Этот метод используется для получения данных. Запросы GET не изменяют состояние сервера и, следовательно, являются идемпотентными.

2. **`PUT`**: Этот метод используется для обновления существующего ресурса или создания нового, если его не существует. Повторный запрос PUT с теми же данными не изменит состояние ресурса после первого выполнения.

3. **`DELETE`**: Этот метод удаляет ресурс. Повторный запрос DELETE к одному и тому же ресурсу будет возвращать одну и ту же реакцию (обычно статус 404, если ресурс уже удалён), не изменяя состояние сервера после первого удаления.

4. **`HEAD`**: Этот метод аналогичен GET, но не возвращает тело ответа. Он также является идемпотентным, так как не изменяет состояние ресурса.

Методы **POST** и **PATCH** не являются идемпотентными, так как их повторное выполнение может привести к изменению состояния сервера или созданию дополнительных ресурсов.

## 2. Различия кодов HTTP (1xx, 2xx, 3xx и т.д.)?

`HTTP-коды статуса` — это трехзначные числа, которые сервер отправляет клиенту (например, браузеру) в ответ на его запрос. Они указывают на статус обработки запроса. `Коды статуса` помогают понять, что произошло при обработке HTTP-запроса и какие действия необходимо предпринять для исправления ошибок. Коды статуса делятся на пять категорий, каждая из которых имеет свое значение:

### `1xx: Информационные`
- **`100 Continue`**: Продолжайте запрос.
- **`101 Switching Protocols`**: Переключение протоколов.

### `2xx: Успешные`
- **`200 OK`**: Запрос успешно выполнен.
- **`201 Created`**: Ресурс был успешно создан.
- **`202 Accepted`**: Запрос принят, но еще не обработан.
- **`203 Non-Authoritative Information`**: Ответ, содержащий информацию, не являющуюся авторитетной.
- **`204 No Content`**: Запрос выполнен, но нет содержимого для возвращения.
- **`205 Reset Content`**: Запрос выполнен, клиент должен сбросить представление документа.
- **`206 Partial Content`**: Сервер возвращает только часть запрашиваемого ресурса.

### `3xx: Перенаправления`
- **`300 Multiple Choices`**: Несколько вариантов для ресурса.
- **`301 Moved Permanently`**: Ресурс был перемещен на постоянной основе.
- **`302 Found`**: Ресурс временно доступен по другому URI.
- **`303 See Other`**: Необходимо получить ресурс по другому URI с использованием метода GET.
- **`304 Not Modified`**: Запрашиваемый ресурс не изменялся с момента последнего запроса.
- **`305 Use Proxy`**: Ресурс должен быть доступен только через прокси.
- **`307 Temporary Redirect`**: Временное перенаправление на другой URI, используйте тот же метод.
- **`308 Permanent Redirect`**: Постоянное перенаправление на другой URI, используйте тот же метод.

### `4xx: Ошибки клиента`
- **`400 Bad Request`**: Неверный запрос, который сервер не может обработать.
- **`401 Unauthorized`**: Для доступа к ресурсу требуется аутентификация.
- **`402 Payment Required`**: Зарезервировано для будущего использования (обычно для платных API).
- **`403 Forbidden`**: Доступ к ресурсу запрещен.
- **`404 Not Found`**: Запрашиваемый ресурс не найден на сервере.
- **`405 Method Not Allowed`**: Метод, указанный в запросе, не разрешен для данного ресурса.
- **`406 Not Acceptable`**: Сервер не может предоставить ресурс, подходящий под условия запроса.
- **`407 Proxy Authentication Required`**: Необходима аутентификация через прокси.
- **`408 Request Timeout`**: Время ожидания запроса истекло.
- **`409 Conflic`t**: Конфликт с текущим состоянием ресурса.
- **`410 Gone`**: Запрашиваемый ресурс был удален и больше недоступен.
- **`411 Length Required`**: Необходим заголовок `Content-Length`.
- **`412 Precondition Failed`**: Предусловие в заголовке запроса не выполнено.
- **`413 Payload Too Large`**: Размер запроса превышает лимит, установленный сервером.
- **`414 URI Too Long`**: Запрашиваемый URI слишком длинный для обработки сервером.
- **`415 Unsupported Media Type`**: Неподдерживаемый тип медиа в запросе.
- **`416 Range Not Satisfiable`**: Запрашиваемый диапазон недоступен.
- **`417 Expectation Failed`**: Ожидание, указанное в заголовке `Expect`, не было выполнено.

### `5xx: Ошибки сервера`
- **`500 Internal Server Error`**: Внутренняя ошибка сервера.
- **`501 Not Implemented`**: Сервер не поддерживает функциональность, необходимую для выполнения запроса.
- **`502 Bad Gateway`**: Сервер, действующий как шлюз, получил неверный ответ от вышестоящего сервера.
- **`503 Service Unavailable`**: Сервер временно недоступен, например, из-за перегрузки.
- **`504 Gateway Timeout`**: Время ожидания ответа от вышестоящего сервера истекло.
- **`505 HTTP Version Not Supported`**: Версия HTTP, указанная в запросе, не поддерживается сервером.

## 3. Что такое JWT?

`JWT (JSON Web Token)` — это открытый стандарт (RFC 7519), который определяет компактный и самостоятельный способ передачи информации между сторонами в виде JSON-объекта. Эта информация может быть проверена и надежно защищена с помощью цифровой подписи. JWT часто используется для аутентификации и авторизации в веб-приложениях.

### `Основные компоненты JWT:`

1. **`Заголовок (Header)`**: Обычно состоит из двух частей: типа токена, который будет JWT, и используемого алгоритма подписи, например HMAC SHA256 или RSA.

   Пример:
   ```json
   {
     "alg": "HS256",
     "typ": "JWT"
   }
   ```

2. **`Полезная нагрузка (Payload)`**: Содержит утверждения (claims) о субъекте (например, пользователе) и дополнительную информацию. Утверждения могут быть стандартными (например, `iss` — издатель, `exp` — время истечения) или пользовательскими.

   Пример:
   ```json
   {
     "sub": "1234567890",
     "name": "John Doe",
     "admin": true
   }
   ```

3. **`Подпись (Signature)`**: Чтобы создать подпись, нужно взять закодированный заголовок, закодированную полезную нагрузку и секретный ключ. Это позволяет проверять целостность токена и аутентифицировать его источник.

   Пример:
   ```plaintext
   HMACSHA256(
     base64UrlEncode(header) + "." +
     base64UrlEncode(payload),
     secret)
   ```

### `Как работает JWT:`

1. **Аутентификация**: Пользователь вводит свои учетные данные (логин и пароль). Если они верны, сервер создает JWT и отправляет его клиенту.

2. **Хранение**: Клиент может хранить JWT в локальном хранилище или куках.

3. **Запросы**: При каждом запросе к защищенному ресурсу клиент отправляет JWT в заголовке авторизации.

4. **Валидация**: Сервер получает токен, декодирует его и проверяет подпись с помощью секретного ключа. Если токен действителен, сервер выполняет запрашиваемое действие.

## 4. LocalStorage, SessionStorage, Cookies? - есть ответ в теме JavaScript

## 6. Отличие HTTP от HTTPS?

`HTTP (HyperText Transfer Protocol)` и `HTTPS (HyperText Transfer Protocol Secure)` — это протоколы, используемые для передачи данных в Интернете, но между ними есть несколько ключевых отличий:

1. **`Безопасность`**:
   - **`HTTP`**: Данные передаются в открытом виде и могут быть перехвачены или изменены третьими лицами.
   - **`HTTPS`**: Данные передаются в зашифрованном виде с использованием SSL (Secure Sockets Layer) или TLS (Transport Layer Security), что обеспечивает защиту от перехвата и атак.

2. **`Порт`**:
   - **`HTTP`**: Обычно использует порт 80.
   - **`HTTPS`**: Обычно использует порт 443.

3. **`Идентификация`**:
   - **`HTTP`**: Не требует сертификатов безопасности и не подтверждает идентичность сервера.
   - **`HTTPS`**: Требует наличия SSL/TLS сертификата, который подтверждает идентичность веб-сервера и защищает данные от перехвата.

4. **`SEO`**:
   - Поисковые системы, такие как Google, отдают предпочтение сайтам, использующим HTTPS, что может положительно сказаться на их ранжировании в результатах поиска.

5. **`Доверие пользователей`**:
   - Сайты с HTTPS отображают значок замка в адресной строке браузера, что повышает доверие пользователей. Сайты с HTTP могут вызвать у пользователей сомнения в безопасности.

## 7. Из чего состоит HTTP запрос?

HTTP-запрос состоит из нескольких основных компонентов:

1. **`Метод запроса`**: Определяет действие, которое клиент хочет выполнить на сервере. Наиболее распространенные методы:
   - **GET**: Запрашивает данные с сервера.
   - **POST**: Отправляет данные на сервер.
   - **PUT**: Обновляет данные на сервере.
   - **DELETE**: Удаляет данные с сервера.

2. **`URL (Uniform Resource Locator)`**: Указывает адрес ресурса, к которому обращается клиент. Он может содержать протокол (например, `http` или `https`), хост (например, `example.com`), путь к ресурсу и параметры запроса.

3. **HTTP версия**: Указывает версию протокола HTTP, например, HTTP/1.1 или HTTP/2.

4. **`Заголовки (Headers)`**: Дополнительная информация о запросе или о клиенте. Они могут включать:
   - `Content-Type`: Тип отправляемых данных (например, `application/json`).
   - `Authorization`: Информация для аутентификации.
   - `User-Agent`: Информация о клиенте (браузере или приложении).

5. **`Тело запроса (Body)`**: (опционально) Содержит данные, которые отправляются на сервер, обычно используется с методами POST и PUT. Тело может содержать различные форматы данных, такие как JSON, XML или формы.

Пример HTTP-запроса методом GET:

```
GET /api/users HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0
Accept: application/json
```

В этом примере:
- **`Метод`**: GET
- **`URL`**: /api/users
- **`Версия`**: HTTP/1.1
- **`Заголовки`**: Host, User-Agent, Accept

# **CSS и верстка**

## 10. **Семантика**

`Семантическая вёрстка` — подход к разметке, который опирается не на внешний вид сайта, а на смысловое предназначение каждого блока и логическую структуру документа.

`Семантика` — это использование HTML-тегов по их предназначению для обозначения структуры и содержания веб-страницы. Семантические теги HTML передают смысловое значение содержимого, а не только внешний вид, что помогает как поисковым системам, так и браузерам лучше понимать контент страницы. Это также улучшает доступность для пользователей с ограниченными возможностями, например, тех, кто использует программы для чтения с экрана.

Пример:

- **`<header>`** — используется для заголовков секций или страниц.
- **`<nav>`** — обозначает секцию навигации по сайту.
- **`<article>`** — представляет самостоятельный блок контента, который может быть использован повторно.
- **`<section>`** — используется для логического деления контента на разделы.
- **`<footer>`** — для содержимого, находящегося внизу страницы или раздела (например, информация об авторе).
- **`<aside>`** — боковая панель с дополнительной информацией, связанной с основным контентом.

Использование семантических тегов помогает не только улучшить SEO (поисковую оптимизацию), но и делает код более доступным для людей с ограниченными возмжностями, читабельным и поддерживаемым.

## 9. **Атрибуты тега скрипт?**

Тег `<script>` используется для добавления и выполнения JavaScript на веб-странице. Он поддерживает несколько атрибутов, наиболее важные из которых:

### 1. **`src`** — указывает путь к внешнему файлу JavaScript.
   - Пример: `<script src="script.js"></script>`

### 2. **`type`** — определяет тип скрипта. По умолчанию используется `text/javascript`.
   - Пример: `<script type="module"></script>`

### 3. **`async`** — загружает скрипт асинхронно, не блокируя загрузку страницы. Скрипт выполняется, как только загружается.
   - Пример: `<script src="script.js" async></script>`

### 4. **`defer`** — откладывает выполнение скрипта до полного завершения загрузки страницы (обработки HTML).
   - Пример: `<script src="script.js" defer></script>`

### 5. **`crossorigin`** — определяет, нужно ли скрипту отправлять запросы с использованием кросс-доменной политики CORS.
   - Пример: `<script src="script.js" crossorigin="anonymous"></script>`

### 6. **`nomodule`** — предотвращает выполнение скрипта в браузерах, поддерживающих ES-модули. Используется для обеспечения обратной совместимости.
   - Пример: `<script nomodule src="fallback.js"></script>`

### 7. **`integrity`** — используется для проверки целостности загружаемого ресурса с использованием криптографического хеша (обычно с внешними скриптами).
   - Пример: `<script src="script.js" integrity="sha384-abc123"></script>`

### 8. **`referrerpolicy`** — управляет тем, какие данные о реферере передаются при запросах, связанных с загрузкой скрипта.
   - Пример: `<script src="script.js" referrerpolicy="no-referrer"></script>`

### 9. **`charset`** — задает кодировку символов для скрипта (обычно используется с внешними скриптами).
   - Пример: `<script src="script.js" charset="UTF-8"></script>`

## 7. **Специфичность в CSS?**

`Специфичность в CSS` — это концепция, которая определяет, какое CSS правило будет применяться к элементу, когда несколько правил подходят под один и тот же элемент. Специфичность основана на количестве и типе селекторов, используемых в CSS-правиле.

### `Основные компоненты специфичности:`
1. **`Инлайн-стили`** (в атрибуте `style`) — имеют самую высокую специфичность.
2. **`ID-селекторы`** — каждый `#id` добавляет высокую специфичность.
3. **`Классы, псевдоклассы, атрибутные селекторы`** — каждый `.class`, `[attribute]`, и `:pseudo-class` увеличивает специфичность.
4. **`Типы элементов и псевдоэлементы`** — каждый тег, например, `div`, `p`, `h1` или псевдоэлемент (`::before`, `::after`), добавляет меньшую специфичность.

## 8. **Каскадность в CSS?**

`Каскадность в CSS` — это механизм, который определяет, какое CSS-правило будет применяться к элементу, если для него заданы несколько конфликтующих правил.


## 5. **Препроцессоры CSS (SCSS, SASS)?**

https://sass-scss.ru/guide/

## 1. **Какие анимации лучше использовать? Преимущества transform?**

## 2. **Стадии работы браузера (парсинг, layout, paint)?**

## 3. **Flexbox?**

## 4. **Позиционирование: absolute, fixed, sticky?**

## 6. **Отличие display: block, inline-block, inline?**



# **Git**
1. Что такое Git Flow, GitHub Flow?
2. Как минимизировать количество merge-конфликтов?
3. Отличие merge и rebase.
4. Зачем нужны git hooks (pre-commit и др.)?
5. Что такое code review и зачем оно нужно?
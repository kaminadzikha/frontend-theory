# **JavaScript**

1. **Типы данных в JavaScript?**
   В JavaScript есть следующие типы данных:
    - Примитивные типы: `number`, `string`, `boolean`, `null`, `undefined`, `symbol`, `bigint`.
    - Объектные типы: `object`, `function`.

2. **Разница между == и === (нестрогое/строгое равенство)?**
   `==` (нестрогое равенство) проверяет равенство значений с приведением типов. `===` (строгое равенство) проверяет равенство значений без приведения типов.

3. **Что такое Strict mode в JavaScript?**
   Strict mode ("строгий режим") вводит в код дополнительные проверки и ограничения для улучшения качества и безопасности кода. Включается директивой `"use strict";`.

4. **Разница между function declaration и function expression?**
    - `Function declaration` (объявление функции): `function foo() { }` - имеет имя и доступна везде в текущей области видимости благодаря "поднятию".
    - `Function expression` (функциональное выражение): `const foo = function() { }` - может быть анонимным или именованным, но доступно только после его объявления.

5. **Разница между null и undefined?**
    - `null` - явное отсутствие значения.
    - `undefined` - значение по умолчанию для необъявленных переменных или отсутствующих аргументов функций.

6. **Типы таймеров в JavaScript?**
    - `setTimeout`: выполняет функцию через определённое время.
    - `setInterval`: выполняет функцию с заданным интервалом.
    - `requestAnimationFrame`: выполняет функцию перед следующим перерисовкой экрана.

7. **Что такое поднятие (Hoisting)?**
   Поднятие - это механизм JavaScript, при котором объявления переменных и функций "поднимаются" в верхнюю часть их области видимости во время компиляции.

8. **Что такое область видимости (Scope)?**
   Область видимости - это контекст, в котором определяются переменные и функции. В JavaScript есть глобальная, функциональная и блочная области видимости.

9. **Разница между var, let и const?**
    - `var`: функциональная область видимости, допускает повторное объявление.
    - `let`: блочная область видимости, не допускает повторное объявление.
    - `const`: блочная область видимости, значение нельзя изменить после инициализации.

10. **Что такое замыкание (Closure)?**
    Замыкание - это функция, которая "помнит" окружение, в котором была создана, даже после того, как это окружение исчезло.

11. **Что обозначает this в JavaScript?**
    `this` ссылается на контекст выполнения функции. В глобальной области видимости `this` ссылается на глобальный объект (`window` в браузере).

12. **Что такое функции высшего порядка (Higher Order Functions)?**
    Функции высшего порядка - это функции, которые принимают другие функции в качестве аргументов или возвращают их.

13. **Как превратить любой тип данных в булевый? Перечислите ложные значения в JS?**
    Преобразование в булевый тип можно сделать через функцию `Boolean()` или оператор `!!`. Ложные значения: `false`, `0`, `-0`, `0n`, `""` (пустая строка), `null`, `undefined`, `NaN`.

14. **Методы строк в JavaScript?**
    - `length`
    - `charAt()`
    - `includes()`
    - `indexOf()`
    - `slice()`
    - `substring()`
    - `split()`
    - `toLowerCase()`
    - `toUpperCase()`
    - `trim()`

15. **Методы массивов в JavaScript?**
    - `length`
    - `push()`
    - `pop()`
    - `shift()`
    - `unshift()`
    - `concat()`
    - `slice()`
    - `splice()`
    - `forEach()`
    - `map()`
    - `filter()`
    - `reduce()`
    - `find()`
    - `findIndex()`
    - `includes()`
    - `indexOf()`

16. **Что такое чистая функция?**
    Чистая функция - это функция, которая:
    - Всегда возвращает один и тот же результат для одних и тех же аргументов.
    - Не имеет побочных эффектов.

17. **Разница между .forEach() и .map()?**
    - `.forEach()`: выполняет функцию для каждого элемента массива, не возвращает новое значение.
    - `.map()`: выполняет функцию для каждого элемента массива и возвращает новый массив с результатами.

18. **Разница между .call(), .apply() и bind()?**
    - `.call()`: вызывает функцию с указанным `this` и аргументами, переданными по отдельности.
    - `.apply()`: вызывает функцию с указанным `this` и аргументами, переданными в виде массива.
    - `.bind()`: возвращает новую функцию с указанным `this` и частично переданными аргументами.

19. **Почему в JS функции называют объектами первого класса?**
    Функции являются объектами первого класса, потому что их можно передавать как аргументы, возвращать из других функций и присваивать переменным.

20. **Как определить наличие свойства в объекте?**
    - Оператор `in`: `"property" in object`
    - Метод `.hasOwnProperty()`: `object.hasOwnProperty("property")`

21. **Что такое IIFE?**
    IIFE (Immediately Invoked Function Expression) - это функция, которая вызывается сразу после своего определения:
    ```javascript
    (function() { /* code */ })();
    ```

22. **Что такое псевдомассив arguments?**
    `arguments` - это объект, похожий на массив, доступный внутри всех функций, который содержит переданные функции аргументы.

23. **Разница между host-объектами и нативными объектами?**
    - Нативные объекты - встроенные объекты JavaScript (`Object`, `Array`, и т.д.).
    - Host-объекты - объекты, предоставленные средой выполнения (например, браузерные объекты, такие как `window`, `document`).

24. **Почему результат сравнения 2х объектов это false?**
    В JavaScript объекты сравниваются по ссылке, а не по значению. Два разных объекта будут всегда не равны друг другу, даже если они содержат одинаковые данные.

25. **Что такое прототипное наследование? Как создать объект без прототипа?**
    Прототипное наследование - механизм, при котором объекты могут наследовать свойства и методы от другого объекта (прототипа). Объект без прототипа можно создать с помощью `Object.create(null)`.

26. **Почему расширение нативных JavaScript-объектов это плохая практика?**
    Расширение нативных объектов может привести к конфликтам и проблемам совместимости, особенно если библиотека или другой код делает то же самое.

27. **Что такое NaN? Как определить, что значение равно NaN?**
    `NaN` (Not-a-Number) - специальное значение, которое указывает, что результат операции не является числом. Определить `NaN` можно с помощью функции `isNaN()` или метода `Number.isNaN()`.

28. **Что такое объектная обертка (Wrapper Objects)?**
    Объектные обертки (`String`, `Number`, `Boolean`) позволяют работать с примитивными значениями как с объектами, предоставляя методы и свойства.

29. **Как в JavaScript создать объект?**
    - Литерал объекта: `{ key: value }`
    - `new Object()`
    - `Object.create(proto)`

30. **Для чего используется ключевое слово new?**
    Ключевое слово `new` используется для создания экземпляра объекта на основе функции-конструктора.

31. **Операторы «И» и «ИЛИ» (&& и ||)?**
    - `&&` (И): возвращает первое ложное значение или последнее истинное.
    - `||` (ИЛИ): возвращает первое истинное значение или последнее ложное.

32. **Для чего используется оператор двойного отрицания (!!)?**
    Оператор двойного отрицания используется для приведения значения к булевому типу.

33. **Для чего используется оператор остатка (%)?**
    Оператор остатка возвращает остаток от деления двух чисел.

34. **Как проверить, является ли значение массивом?**
    С помощью метода `Array.isArray()`:
    ```javascript
    Array.isArray(value);
    ```

35. **Как работает boxing/unboxing в JavaScript?**
    Boxing - это процесс оборачивания примитива в объектную обертку, например, при доступе к свойствам или методам примитивного значения. Unboxing - обратный процесс, когда объектная обертка преобразуется обратно в примитив.

36. **Что такое мемоизация? Реализуйте базовую логи

ку функции для мемоизации?**
Мемоизация - это оптимизация, при которой результаты функции сохраняются и используются при последующих вызовах с теми же аргументами.
```javascript
function memoize(fn) {
const cache = {};
return function(...args) {
const key = JSON.stringify(args);
if (!(key in cache)) {
cache[key] = fn(...args);
}
return cache[key];
};
}
```

37. **Разница между оператором in и методом .hasOwnProperty()?**
    - `in` проверяет наличие свойства в объекте и его прототипах.
    - `.hasOwnProperty()` проверяет наличие свойства только в самом объекте.

38. **Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? Как сделать каждую из них?**
    - Поверхностная копия копирует только верхний уровень объекта. Например, с помощью `Object.assign()` или оператора распространения `{ ...obj }`.
    - Глубокая копия копирует все уровни вложенности объекта. Например, с помощью `JSON.parse(JSON.stringify(obj))` или библиотек вроде `lodash`.

39. **Что такое цепочка вызовов функций (chaining)? Как реализовать такой подход?**
    Цепочка вызовов функций позволяет вызывать несколько методов объекта последовательно. Реализуется возвратом `this` в методах объекта.
    ```javascript
    class Chain {
        method1() {
            console.log("method1");
            return this;
        }
        method2() {
            console.log("method2");
            return this;
        }
    }
    const chain = new Chain();
    chain.method1().method2();
    ```

40. **Что такое необъявленная переменная?**
    Необъявленная переменная - это переменная, к которой обращаются без использования ключевых слов `var`, `let` или `const`.

41. **Как передаются параметры в функцию: по ссылке или по значению?**
    Примитивные типы передаются по значению, объекты - по ссылке.

42. **Что такое прототип объекта в JavaScript?**
    Прототип объекта - это объект, от которого другой объект наследует свойства и методы.

43. **Как работает метод Object.create()?**
    Метод `Object.create(proto)` создает новый объект с указанным прототипом `proto`.

44. **Разниц между Object.freeze() и Object.seal()?**
    - `Object.freeze()` замораживает объект, делая его неизменяемым.
    - `Object.seal()` запечатывает объект, позволяя изменять существующие свойства, но не добавлять или удалять их.

45. **Разница между методами .slice() и .splice()?**
    - `.slice()`: возвращает новый массив, содержащий копию части исходного массива.
    - `.splice()`: изменяет исходный массив, удаляя или добавляя элементы.

46. **Как работают методы .find(), .findIndex() и .indexOf()?**
    - `.find()`: возвращает первый элемент, удовлетворяющий условию.
    - `.findIndex()`: возвращает индекс первого элемента, удовлетворяющего условию.
    - `.indexOf()`: возвращает индекс первого вхождения элемента в массиве.

47. **Плюсы и минусы использования use strict?**
    Плюсы:
    - Улучшение производительности.
    - Лучшая диагностика ошибок.
    - Защита от небезопасных действий.

    Минусы:
    - Могут возникнуть проблемы при интеграции с "нестрогим" кодом.

48. **Разница между методами .push(), .pop(), .shift() и .unshift()?**
    - `.push()`: добавляет элемент в конец массива.
    - `.pop()`: удаляет последний элемент массива.
    - `.shift()`: удаляет первый элемент массива.
    - `.unshift()`: добавляет элемент в начало массива.

49. **Плюсы и минусы иммутабельности? Как достичь иммутабельности в JS?**
    Плюсы:
    - Предсказуемость кода.
    - Упрощение отладки.
    - Меньше побочных эффектов.

    Минусы:
    - Возможны проблемы с производительностью.

    Иммутабельность можно достичь с помощью методов, которые возвращают новые объекты вместо изменения старых, и библиотек, таких как Immutable.js.

50. **Типы всплывающих окон в JavaScript?**
    - `alert()`
    - `confirm()`
    - `prompt()`

51. **Типы объектов JavaScript?**
    - `Object`
    - `Array`
    - `Function`
    - `Date`
    - `RegExp`
    - `Error`
    - и др.

52. **Парадигмы программирования в JavaScript?**
    - Императивное программирование.
    - Объектно-ориентированное программирование.
    - Функциональное программирование.

53. **Типы ошибок в JavaScript?**
    - `SyntaxError`
    - `ReferenceError`
    - `TypeError`
    - `RangeError`
    - `EvalError`
    - `URIError`

54. **Разница между typeof и instanceof?**
    - `typeof` возвращает строку, указывающую тип примитива или объекта.
    - `instanceof` проверяет, является ли объект экземпляром определенного конструктора.

55. **JavaScript статически, или динамически типизированный язык?**
    JavaScript - динамически типизированный язык.

56. **Что такое регулярное выражение (Regular Expression)?**
    Регулярное выражение - это шаблон для поиска и замены текста.

57. **Что такое рекурсия?**
    Рекурсия - это метод программирования, при котором функция вызывает саму себя.

58. **Что такое прототип (Prototype) объекта?**
    Прототип объекта - это объект, от которого другой объект наследует свойства и методы.

59. **Какие методы используются в регулярных выражениях?**
    - `test()`
    - `exec()`
    - методы строк: `match()`, `replace()`, `search()`, `split()`

60. **Что такое полифил (polyfill)?**
    Полифил - это код, который реализует функциональность, отсутствующую в старых версиях браузеров.

61. **Что такое switch/case? Правила использования switch/case?**
    `switch/case` - это оператор для сравнения одного выражения с несколькими значениями:
    ```javascript
    switch (expression) {
        case value1:
            // код
            break;
        case value2:
            // код
            break;
        default:
            // код
    }
    ```

62. **Типы функций по способности принимать другие функции?**
    - Функции первого порядка: не принимают и не возвращают другие функции.
    - Функции высшего порядка: принимают или возвращают другие функции.

63. **Что такое выражения (expression) и инструкции (statement) в JavaScript?**
    - Выражение (expression) - это фрагмент кода, который вычисляется и возвращает значение.
    - Инструкция (statement) - это команда, которая выполняет действие.

64. **Разница между .some() и .every()?**
    - `.some()`: возвращает `true`, если хотя бы один элемент массива удовлетворяет условию.
    - `.every()`: возвращает `true`, если все элементы массива удовлетворяют условию.

65. **Как сгенерировать случайное число в JavaScript?**
    С помощью `Math.random()`:
    ```javascript
    Math.random(); // случайное число от 0 до 1 (не включая 1)
    ```

66. **Типы операторов в JavaScript?**
    - Арифметические: `+`, `-`, `*`, `/`, `%`
    - Сравнения: `==`, `===`, `!=`, `!==`, `>`, `<`, `>=`, `<=`
    - Логические: `&&`, `||`, `!`
    - Присваивания: `=`, `+=`, `-=`, `*=`, `/=`
    - Побитовые: `&`, `|`, `^`, `~`, `<<`, `>>`, `>>>`
    - Специальные: `typeof`, `instanceof`, `new`, `delete`, `void`, `in`

67. **Разница между параметром и аргументом функции?**
    Параметры - это переменные, объявленные в определении функции. Аргументы - это значения, передаваемые функции при ее вызове.

68. **Правила задания имён для переменных и функций в JavaScript?**
    - Должны начинаться с буквы, знака доллара `$` или подчеркивания `_`.
    - Не могут начинаться с цифры.
    - Должны быть понятными и описательными.
    - Не должны быть зарезервированными словами.

69. **Разница между явным и неявным преобразованием (Implicit and Explicit Coercion)?**
    - Явное преобразование: программист явно указывает преобразование типа (`Number()`, `String()`, `Boolean()`).
    - Неявное преобразование: JavaScript автоматически преобразует типы в процессе выполнения.

70. **Для чего применяется метод Array

.from()?**
Метод `Array.from()` создает новый массив из массивоподобного или итерируемого объекта.

71. **Назовите способы преобразования массива в объект?**
    - Использование метода `reduce()`:
      ```javascript
      const array = [1, 2, 3];
      const obj = array.reduce((acc, cur, index) => ({ ...acc, [index]: cur }), {});
      ```
    - С помощью `Object.assign()` и оператора распространения:
      ```javascript
      const obj = Object.assign({}, array);
      ```
    - Использование метода `Object.fromEntries()`:
      ```javascript
      const obj = Object.fromEntries(array.map((value, index) => [index, value]));
      ```

72. **Разница между Object и Map?**
    - `Object` позволяет хранить ключи только строкового типа.
    - `Map` позволяет хранить ключи любого типа и сохраняет порядок добавления.

73. **Что такое каррирование?**
    Каррирование - это процесс преобразования функции с множеством аргументов в серию функций, каждая из которых принимает один аргумент.
    ```javascript
    function curry(f) {
        return function(a) {
            return function(b) {
                return f(a, b);
            };
        };
    }
    ```

74. **Для чего используются метод Object.seal()?**
    Метод `Object.seal()` запечатывает объект, предотвращая добавление новых и удаление существующих свойств, но позволяет изменять существующие свойства.

75. **Для чего используется свойство .dataset?**
    Свойство `.dataset` используется для работы с пользовательскими атрибутами данных (data-*) в элементах DOM.

76. **Каким образом можно обмениваться кодом между файлами?**
    - Экспорт и импорт модулей с помощью `export` и `import` (ES6).
    - Использование CommonJS модулей (`module.exports` и `require()`).

77. **Как работает «сборщик мусора» в JavaScript?**
    Сборщик мусора автоматически освобождает память, удаляя объекты, которые больше не доступны или не используются.

78. **Что такое утечки памяти?**
    Утечки памяти возникают, когда программа продолжает потреблять память, не освобождая ее после использования, что может привести к исчерпанию памяти.

79. **Назовите основные типы утечек памяти в JavaScript?**
    - Забытые таймеры и обратные вызовы.
    - Замыкания, удерживающие ссылки на переменные.
    - Ссылки на удаленные DOM-элементы.
    - Глобальные переменные.

80. **Как работает контекст выполнения (execution context) в JavaScript?**
    Контекст выполнения - это окружение, в котором выполняется JavaScript код, состоящий из:
    - Области видимости (Scope)
    - Стек вызовов (Call Stack)
    - Объект окружения (Environment Object)

81. **Разница между примитивом и объектом?**
    - Примитивы (числа, строки, булевые значения, `null`, `undefined`, `symbol`, `bigint`) хранятся непосредственно по значению.
    - Объекты хранятся по ссылке и могут содержать множество значений и методов.

82. **Что значит текст max call stack size exceeded в консоли?**
    Это ошибка, указывающая на переполнение стека вызовов, часто возникающая из-за бесконечной рекурсии.

83. **Как реализовать отложенную загрузку изображений?**
    Отложенная загрузка (lazy loading) изображений может быть реализована с использованием атрибута `loading="lazy"` или библиотеки, такой как `lazysizes`, или с использованием JavaScript:
    ```javascript
    document.addEventListener("DOMContentLoaded", function() {
        const lazyImages = document.querySelectorAll("img.lazy");
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    img.src = img.dataset.src;
                    img.classList.remove("lazy");
                    observer.unobserve(img);
                }
            });
        });
        lazyImages.forEach(img => observer.observe(img));
    });
    ```

84. **Чем отличаются события input и change?**
    - `input` срабатывает каждый раз при изменении значения элемента.
    - `change` срабатывает, когда изменение элемента завершено (например, после потери фокуса).

85. **Почему typeof null возвращает object?**
    Это баг в языке JavaScript, который сохранился для обратной совместимости. Исторически `null` интерпретировался как "нулевой объект".

86. **Зачем нужен конструктор Proxy?**
    `Proxy` позволяет создавать прокси для объекта, который может перехватывать и изменять основные операции (например, чтение/запись свойств, вызов функций).

87. **Что такое хвостовая рекурсия? Оптимизация рекурсии?**
    Хвостовая рекурсия - это рекурсия, при которой рекурсивный вызов является последней операцией функции. Оптимизация хвостовой рекурсии позволяет уменьшить использование памяти.

88. **Что такое и как работает debounce() и throttle() в JavaScript?**
    - `debounce()`: ограничивает частоту вызова функции, вызывая её только после определенного времени с последнего вызова.
    - `throttle()`: ограничивает количество вызовов функции, вызывая её не чаще определенного времени.
    ```javascript
    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }

    function throttle(func, limit) {
        let lastFunc;
        let lastRan;
        return function(...args) {
            if (!lastRan) {
                func.apply(this, args);
                lastRan = Date.now();
            } else {
                clearTimeout(lastFunc);
                lastFunc = setTimeout(() => {
                    if (Date.now() - lastRan >= limit) {
                        func.apply(this, args);
                        lastRan = Date.now();
                    }
                }, limit - (Date.now() - lastRan));
            }
        };
    }
    ```

89. **Как в JavaScript работают декораторы? Как они могут быть использованы для модификации поведения классов и методов?**
    Декораторы - это функции, которые принимают целевой объект, метод или свойство и могут изменять их поведение.
    ```javascript
    function readonly(target, key, descriptor) {
        descriptor.writable = false;
        return descriptor;
    }

    class Example {
        @readonly
        method() {
            return "This method is readonly";
        }
    }
    ```
# **JavaScript**

## 1. **Типы данных в JavaScript?**
   В JavaScript есть следующие типы данных:
   `number`, `string`, `boolean`, `null`, `undefined`, `symbol`, `bigint`, `object`

## 2. **Разница между == и === (нестрогое/строгое равенство)?**
`==` (нестрогое равенство) проверяет равенство значений с приведением типов. `===` (строгое равенство) проверяет равенство значений без приведения типов.

## 3. **Что такое Strict mode в JavaScript?**
`Strict mode ("строгий режим")` вводит в код дополнительные проверки и ограничения для улучшения качества и безопасности кода. Включается директивой `"use strict";`.

## 4. **Разница между function declaration и function expression?**
- `Function declaration` (объявление функции): `function foo() { }` - имеет имя и доступна везде в текущей области видимости благодаря "поднятию".
- `Function expression` (функциональное выражение): `const foo = function() { }` - может быть анонимным или именованным, но доступно только после его объявления.

## 5. **Разница между null и undefined?**
`undefined` представляет собой значение по умолчанию:
- переменной, которой не было присвоено значение;
- функции, которая ничего не возвращает явно, например, console.log(1);
- несуществующего свойства объекта.

`null` — это значение, которое присваивается переменной явно.

При сравнении null и undefined мы получаем true, когда используем оператор ==, и false при использовании оператора ===.

## 6. **Типы таймеров в JavaScript?**
- `setTimeout`: выполняет функцию через определённое время.
- `setInterval`: выполняет функцию с заданным интервалом.
- `requestAnimationFrame`: выполняет функцию перед следующим перерисовкой экрана.

## 7. **Что такое поднятие (Hoisting)?**
`Поднятие` - это механизм JavaScript, при котором объявления переменных и функций "поднимаются" в верхнюю часть их
области видимости во время компиляции.

**Контекст выполнения** — это среда, в которой выполняется код. Контекст выполнения имеет две фазы — компиляция и выполнение.

**_Компиляция._** В этой фазе функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости - как бы перемещаются в начало нашего кода. Это объясняет, почему мы можем вызывать функции до их объявления

**_Выполнение._** В этой фазе переменным присваиваются значения, а функции вызываются и выполняются.

## 8. **Что такое область видимости (Scope)?**

### **Область видимости** — это область, ограничивающая доступ к переменным и функциям внутри себя, как бы инкапсулирующая их.

**JS имеет три типа областей видимости: глобальная, функциональная и блочная (ES6).**

**Глобальная** — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и
доступны из любого места в коде.

**Функциональная** — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции.

**Блочная** — переменные, объявленные с помощью ключевых слов let и const, доступны только внутри блока {}, в котором
были
объявлены.

**Область видимости** — это также набор правил, по которым осуществляется поиск переменной. Если переменной не
существует в
текущей области видимости, ее поиск производится выше, во внешней по отношению к текущей области видимости. Если и во
внешней области видимости переменная отсутствует, ее поиск продолжается вплоть до глобальной области видимости. Если в
глобальной области видимости переменная обнаружена, поиск прекращается, если нет — выбрасывается исключение. Поиск
осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной. Это называется
цепочкой областей видимости (Scope Chain).

## 9. **Разница между var, let и const?**

### var
- поднимается в начало области видимости функции при компиляции (имеет область видимости функции)
- объявляет переменную, которая может быть перезаписана
- объявляет переменную, которая может быть переопределена

### let
- не поднимается в начало области видимости блока при компиляции (имеет блочную область видимости)
- объявляет переменную, которая может быть перезаписана
- объявляет переменную, которая не может быть переопределена

### const
- не поднимается в начало области видимости блока при компиляции (имеет блочную область видимости)
- объявляет переменную, которая не может быть перезаписана или переопределена

## 10. **Что такое замыкание (Closure)?**

### 1. **`Замыкание`** — это способность функции во время создания запоминать ссылки на переменные и параметры, находящиеся в текущей области видимости. Обычно область видимости определяется при создании функции.

2. **`Замыкание`** - это комбинация функции и лексического окружения, в котором она была определена. Это позволяет ей
   обращаться к переменным и функциям этого лексического окружения в дальнейшем.

## 11. **Что обозначает this в JavaScript?**

`this` ссылается на контекст выполнения функции. В глобальной области видимости `this` ссылается на глобальный
объект (`window` в браузере).

## 12. **Что такое функции высшего порядка (Higher Order Functions)?**
    Функции высшего порядка - это функции, которые принимают другие функции в качестве аргументов или возвращают их.

## 13. **Как превратить любой тип данных в булевый? Перечислите ложные значения в JS?**
    Преобразование в булевый тип можно сделать через функцию `Boolean()` или оператор `!!`. Ложные
    значения: `false`, `0`, `-0`, `0n`, `""` (пустая строка), `null`, `undefined`, `NaN`.

## 14. **Методы строк в JavaScript?**

- **`length`** – возвращает длину строки.
   ```js
   const str = "Hello, World!";
   console.log(str.length); // 13
   ```

- **`toUpperCase()`** – преобразует все символы строки в верхний регистр.
   ```js
   const str = "hello";
   console.log(str.toUpperCase()); // "HELLO"
   ```

- **`toLowerCase()`** – преобразует все символы строки в нижний регистр.
   ```js
   const str = "HELLO";
   console.log(str.toLowerCase()); // "hello"
   ```

- **`charAt(index)`** – возвращает символ строки по указанному индексу.
   ```js
   const str = "JavaScript";
   console.log(str.charAt(0)); // "J"
   ```

- **`includes(substring)`** – проверяет, содержит ли строка подстроку.
   ```js
   const str = "Hello, World!";
   console.log(str.includes("World")); // true
   ```

- **`indexOf(substring)`** – возвращает индекс первого вхождения подстроки, или -1, если подстрока не найдена.
   ```js
   const str = "Hello, World!";
   console.log(str.indexOf("World")); // 7
   ```

- **`slice(start, end)`** – извлекает часть строки с указанного индекса до конца или до заданного индекса.
   ```js
   const str = "Hello, World!";
   console.log(str.slice(7, 12)); // "World"
   ```

- **`substring(start, end)`** – аналогичен методу `slice()`, но не поддерживает отрицательные индексы.
   ```js
   const str = "JavaScript";
   console.log(str.substring(4, 10)); // "Script"
   ```

- **`replace(searchValue, newValue)`** – заменяет первую найденную подстроку на новую строку.
   ```js
   const str = "Hello, World!";
   console.log(str.replace("World", "JavaScript")); // "Hello, JavaScript!"
   ```

- **`split(separator)`** – разбивает строку на массив строк по указанному разделителю.
    ```js
    const str = "apple, banana, cherry";
    const arr = str.split(", ");
    console.log(arr); // ["apple", "banana", "cherry"]
    ```

- **`trim()`** – удаляет пробелы в начале и конце строки.
    ```js
    const str = "   Hello, World!   ";
    console.log(str.trim()); // "Hello, World!"
    ```

- **`repeat(count)`** – возвращает новую строку, повторённую указанное количество раз.
    ```js
    const str = "Hi! ";
    console.log(str.repeat(3)); // "Hi! Hi! Hi! "
    ```

- **`concat(...strings)`** – объединяет строки.
    ```js
    const str1 = "Hello";
    const str2 = "World";
    console.log(str1.concat(", ", str2)); // "Hello, World"
    ```

## 15. **Методы массивов в JavaScript?**
    
Смотреть большинство методов здесь: - https://doka.guide/js/

## 16. **Что такое чистая функция?**
`Чистая функция` - это функция, которая:
- Всегда возвращает один и тот же результат для одних и тех же аргументов.
- Не имеет побочных эффектов.

## 17. **Разница между .forEach() и .map()?**
- `.forEach()`: выполняет функцию для каждого элемента массива, не возвращает новое значение.
- `.map()`: выполняет функцию для каждого элемента массива и возвращает новый массив с результатами.

## 18. **Разница между .call(), .apply() и bind()?**
- `.call()`: вызывает функцию с указанным `this` и аргументами, переданными по отдельности.
- `.apply()`: вызывает функцию с указанным `this` и аргументами, переданными в виде массива.
- `.bind()`: возвращает новую функцию с указанным `this` и частично переданными аргументами.

## 19. **Почему в JS функции называют объектами первого класса?**
`Функции являются объектами первого класса`, потому что их можно передавать как аргументы, возвращать из других
функций и присваивать переменным.

## 21. **Что такое IIFE?**
`IIFE или Immediately Invoked Function Expression` — это функция, которая вызывается или выполняется сразу же после создания или объявления.:
```javascript
(function() { /* code */ })();
```

## 22. **Что такое псевдомассив arguments?**
`arguments `— это коллекция аргументов, передаваемых функции. Он имеет свойство length и поддерживает обращение по индексу к элементам, но не является массивом, из-за чего не имеет методов forEach, reduce, filter, map и так далее.

Преобразовать arguments в массив можно, например, с помощью Array.prototype.slice.

В стрелочных функциях объект arguments не работает.

23. **Разница между host-объектами и нативными объектами?**
    - Нативные объекты - встроенные объекты JavaScript (`Object`, `Array`, и т.д.).
    - Host-объекты - объекты, предоставленные средой выполнения (например, браузерные объекты, такие
      как `window`, `document`).

24. **Почему результат сравнения 2х объектов это false?**
    В JavaScript объекты сравниваются по ссылке, а не по значению. Два разных объекта будут всегда не равны друг другу,
    даже если они содержат одинаковые данные.

## 25. **Что такое прототипное наследование? Как создать объект без прототипа?**
**`Прототипное наследование`** - механизм, при котором объекты могут наследовать свойства и методы от другого объекта (прототипа). Объект без прототипа можно создать с помощью `Object.create(null)`.

## 26. **Почему расширение нативных JavaScript-объектов это плохая практика?**
`Расширение нативных объектов` может привести к конфликтам и проблемам совместимости, особенно если библиотека или
другой код делает то же самое.

## 27. **Что такое NaN? Как определить, что значение равно NaN?**
`NaN` (Not-a-Number) - специальное значение, которое указывает, что результат операции не является числом.
Определить `NaN` можно с помощью функции `isNaN()` или метода `Number.isNaN()`.

## 28. **Что такое объектная обертка (Wrapper Objects)?**
Объектные обертки (`String`, `Number`, `Boolean`, `Symbol` и `BigInt`) позволяют работать с примитивными значениями как с объектами,
предоставляя методы и свойства.

## 29. **Как в JavaScript создать объект?**
- Литерал объекта: `{ key: value }`
- `new Object()`
- `Object.create(proto)`

## 30. **Для чего используется ключевое слово new?**
`Ключевое слово new` используется в функциях-конструкторах для создания нового объекта (нового экземпляра класса).

Ключевое слово `new` делает 4 вещи:

1. Создает пустой объект.
2. Привязывает к нему значение this.
3. Функция наследует от functionName.prototype.
4. Возвращает значение this, если не указано иное.


## 31. **Операторы «И» и «ИЛИ» (&& и ||)?**
- `&&` (И): возвращает первое ложное значение или последнее истинное.
- `||` (ИЛИ): возвращает первое истинное значение или последнее ложное.

## 32. **Для чего используется оператор двойного отрицания (!!)?**
`Оператор двойного отрицания` используется для приведения значения к булевому типу.

## 33. **Для чего используется оператор остатка (%)?**
    Оператор остатка возвращает остаток от деления двух чисел.

## 34. **Как проверить, является ли объект массивом?**
С помощью метода `Array.isArray()`:
```javascript
Array.isArray(value);
```

## 35. **Как работает boxing/unboxing в JavaScript?**
`Boxing` - это процесс оборачивания примитива в объектную обертку, например, при доступе к свойствам или методам
примитивного значения. `Unboxing` - обратный процесс, когда объектная обертка преобразуется обратно в примитив.

## 36. **Что такое мемоизация? Реализуйте базовую логи ку функции для мемоизации?**
`Мемоизация` - это оптимизация, при которой результаты функции сохраняются и используются при последующих вызовах с теми
же аргументами.

```javascript
function memoize(fn) {
    const cache = {};
    return function (...args) {
        const key = JSON.stringify(args);
        if (!(key in cache)) {
            cache[key] = fn(...args);
        }
        return cache[key];
    };
}
```

## 37. **Как определить наличие свойства в объекте? Разница между оператором in и методом .hasOwnProperty()?**
- `in` проверяет наличие свойства в объекте и его прототипах.
- `.hasOwnProperty()` проверяет наличие свойства только в самом объекте.

## 38. **Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? Как сделать каждую из них?**
- Поверхностная копия копирует только верхний уровень объекта. Например, с помощью `Object.assign()` или оператора
  распространения `{ ...obj }`.
- Глубокая копия копирует все уровни вложенности объекта. Например, с помощью `JSON.parse(JSON.stringify(obj))` или
  библиотек вроде `lodash`.

## 39. **Что такое цепочка вызовов функций (chaining)? Как реализовать такой подход?**

`Цепочка вызовов функций` позволяет вызывать несколько методов объекта последовательно. Реализуется возвратом `this` в
методах объекта.

```javascript
class Chain {
    method1() {
        console.log("method1");
        return this;
    }
    method2() {
        console.log("method2");
        return this;
    }
}
const chain = new Chain();
chain.method1().method2();
```

## 40. **Что такое необъявленная переменная?**

`Необъявленная переменная` - это переменная, к которой обращаются без использования ключевых слов `var`, `let`
или `const`.

## 41. **Как передаются параметры в функцию: по ссылке или по значению?**
Примитивные типы передаются `по значению`, объекты - `по ссылке`.

## 42. **Что такое прототип объекта в JavaScript?**
**`Прототип объекта`** - это объект, от которого другой объект наследует свойства и методы.

## 43. **Как работает метод Object.create()?**
Метод `Object.create(proto)` создает новый объект с указанным прототипом `proto`.

## 44. **Разниц между Object.freeze() и Object.seal()?**
- `Object.freeze()` замораживает объект, делая его неизменяемым.
- `Object.seal()` запечатывает объект, позволяя изменять существующие свойства, но не добавлять или удалять их.

## 45. **Разница между методами .slice() и .splice()?**
- `.slice()`: возвращает новый массив, содержащий копию части исходного массива.
- `.splice()`: изменяет исходный массив, удаляя или добавляя элементы.

## 46. **Как работают методы .find(), .findIndex() и .indexOf()?**
- `.find()`: возвращает первый элемент, удовлетворяющий условию.
- `.findIndex()`: возвращает индекс первого элемента, удовлетворяющего условию.
- `.indexOf()`: возвращает индекс первого вхождения элемента в массиве.

## 47. **Плюсы и минусы использования use strict?**

**`Плюсы:`**

- Улучшение производительности.
- Лучшая диагностика ошибок.
- Защита от небезопасных действий.

**`Минусы:`**

- Могут возникнуть проблемы при интеграции с "нестрогим" кодом.

## 48. **Разница между методами .push(), .pop(), .shift() и .unshift()?**
- `.push()`: добавляет элемент в конец массива.
- `.pop()`: удаляет последний элемент массива.
- `.shift()`: удаляет первый элемент массива.
- `.unshift()`: добавляет элемент в начало массива.

## 49. **Плюсы и минусы иммутабельности? Как достичь иммутабельности в JS?**
`Плюсы:`
- Предсказуемость кода.
- Упрощение отладки.
- Меньше побочных эффектов.

`Минусы:`
- Возможны проблемы с производительностью.

Иммутабельность можно достичь с помощью методов, которые возвращают новые объекты вместо изменения старых, и
библиотек, таких как Immutable.js.

## 50. **Типы всплывающих окон в JavaScript?**
- `alert()`
- `confirm()`
- `prompt()`

## 51. **Типы объектов JavaScript?**
- `Object`
- `Array`
- `Function`
- `Date`
- `RegExp`
- `Error`
- и др.

## 52. **Парадигмы программирования в JavaScript?**
- Императивное программирование.
- Объектно-ориентированное программирование.
- Функциональное программирование.

## 53. **Типы ошибок в JavaScript?**
- `SyntaxError`
- `ReferenceError`
- `TypeError`
- `RangeError`
- `EvalError`
- `URIError`

## 54. **Разница между typeof и instanceof?**
- `typeof` возвращает строку, указывающую тип примитива или объекта.
- `instanceof` проверяет, является ли объект экземпляром определенного конструктора.

## 55. **JavaScript статически, или динамически типизированный язык?**
`JavaScript - динамически типизированный язык.`

## 56. **Что такое регулярное выражение (Regular Expression)?**
Регулярное выражение - это шаблон для поиска и замены текста.

## 57. **Что такое рекурсия?**
Рекурсия - это метод программирования, при котором функция вызывает саму себя.

## 59. **Какие методы используются в регулярных выражениях?**
- `test()`
- `exec()`
- методы строк: `match()`, `replace()`, `search()`, `split()`

## 60. **Что такое полифил (polyfill)?**
`Полифил` - это код, который реализует функциональность, отсутствующую в старых версиях браузеров.

## 61. **Что такое switch/case? Правила использования switch/case?**

`switch/case` - это оператор для сравнения одного выражения с несколькими значениями:

```javascript
switch (expression) {
    case value1:
        // код
        break;
    case value2:
        // код
        break;
    default:
        // код
}
```

## 62. **Типы функций по способности принимать другие функции?**
- `Функции первого порядка`: не принимают и не возвращают другие функции.
- `Функции высшего порядка`: принимают или возвращают другие функции.

## 63. **Что такое выражения (expression) и инструкции (statement) в JavaScript?**
- `Выражение (expression)` - это фрагмент кода, который вычисляется и возвращает значение.
- `Инструкция (statement)` - это команда, которая выполняет действие.

## 64. **Разница между .some() и .every()?**
- `.some()`: возвращает `true`, если хотя бы один элемент массива удовлетворяет условию.
- `.every()`: возвращает `true`, если все элементы массива удовлетворяют условию.

## 65. **Как сгенерировать случайное число в JavaScript?**

С помощью `Math.random()`:

```javascript
Math.random(); // случайное число от 0 до 1 (не включая 1)
```

## 66. **Типы операторов в JavaScript?**
- `Арифметические`: `+`, `-`, `*`, `/`, `%`
- `Сравнения`: `==`, `===`, `!=`, `!==`, `>`, `<`, `>=`, `<=`
- `Логические`: `&&`, `||`, `!`
- `Присваивания`: `=`, `+=`, `-=`, `*=`, `/=`
- `Побитовые`: `&`, `|`, `^`, `~`, `<<`, `>>`, `>>>`
- `Специальные`: `typeof`, `instanceof`, `new`, `delete`, `void`, `in`

## 67. **Разница между параметром и аргументом функции?**
`Параметры` - это переменные, объявленные в определении функции. Аргументы - это значения, передаваемые функции при ее
вызове.

## 68. **Правила задания имён для переменных и функций в JavaScript?**
- Должны начинаться с буквы, знака доллара `$` или подчеркивания `_`.
- Не могут начинаться с цифры.
- Должны быть понятными и описательными.
- Не должны быть зарезервированными словами.

## 69. **Разница между явным и неявным преобразованием (Implicit and Explicit Coercion)?**
- `Явное преобразование`: программист явно указывает преобразование типа (`Number()`, `String()`, `Boolean()`).
- `Неявное преобразование`: JavaScript автоматически преобразует типы в процессе выполнения.

## 70. **Для чего применяется метод Array.from()?**

Метод `Array.from()` создает новый массив из массивоподобного или итерируемого объекта.

## 71. **Назовите способы преобразования массива в объект?**
- Использование метода `reduce()`:
```javascript
const array = [1, 2, 3];
const obj = array.reduce((acc, cur, index) => ({ ...acc, [index]: cur }), {});
```
- С помощью `Object.assign()` и оператора распространения:
```javascript
const obj = Object.assign({}, array);
```
- Использование метода `Object.fromEntries()`:
```javascript
const obj = Object.fromEntries(array.map((value, index) => [index, value]));
```

## 72. **Разница между Object и Map?**
- `Object` позволяет хранить ключи только строкового типа.
- `Map` позволяет хранить ключи любого типа и сохраняет порядок добавления.

## 73. **Что такое каррирование?**

`Каррирование` - это процесс преобразования функции с множеством аргументов в серию функций, каждая из которых
принимает один аргумент.

```javascript
function curry(f) {
    return function(a) {
        return function(b) {
            return f(a, b);
        };
    };
}
```

## 74. **Для чего используются метод Object.seal()?**

Метод `Object.seal()` запечатывает объект, предотвращая добавление новых и удаление существующих свойств, но
позволяет изменять существующие свойства.

## 75. **Для чего используется свойство .dataset?**

Свойство `.dataset` используется для работы с пользовательскими атрибутами данных (data-*) в элементах DOM.

## 76. **Каким образом можно обмениваться кодом между файлами?**

- Экспорт и импорт модулей с помощью `export` и `import` (ES6).
- Использование CommonJS модулей (`module.exports` и `require()`).

## 77. **Как работает «сборщик мусора» в JavaScript?**
`Сборщик мусора` автоматически освобождает память, удаляя объекты, которые больше не доступны или не используются.

## 78. **Что такое утечки памяти?**
Утечки памяти возникают, когда программа продолжает потреблять память, не освобождая ее после использования, что
может привести к исчерпанию памяти.

## 79. **Назовите основные типы утечек памяти в JavaScript?**
- Забытые таймеры и обратные вызовы.
- Замыкания, удерживающие ссылки на переменные.
- Ссылки на удаленные DOM-элементы.
- Глобальные переменные.

## 80. **Как работает контекст выполнения (execution context) в JavaScript?**
`Контекст выполнения` (execution context) в JavaScript — это концепция, которая описывает среду, в которой выполняется текущий код. Это важная часть механизма выполнения JavaScript-кода, которая управляет областью видимости переменных и определяет, как и где они могут быть доступны.

### Основные типы контекстов выполнения:
1. **Глобальный контекст выполнения:**
    - Это контекст выполнения по умолчанию для любого JavaScript-кода.
    - В браузере глобальный контекст привязан к объекту `window`, а в Node.js — к объекту `global`.
    - Все переменные и функции, объявленные на глобальном уровне, принадлежат этому контексту.
    - В глобальном контексте нет "родителя", это самый верхний уровень выполнения.

2. **Контекст выполнения функции:**
    - Создается каждый раз, когда вызывается функция.
    - Внутри функции создается собственное пространство имен для переменных и функций (локальная область видимости).
    - При каждом вызове функции создается новый контекст выполнения для этой конкретной функции.

3. **Контекст выполнения eval():**
    - Код, переданный в функцию `eval()`, выполняется в собственном контексте выполнения.

### Что содержит каждый контекст выполнения?
Каждый контекст выполнения имеет три ключевых компонента:
1. **Область видимости (Scope) и цепочка областей видимости (Scope Chain):**
    - Область видимости — это набор переменных, к которым функция может получить доступ.
    - Цепочка областей видимости обеспечивает поиск переменных в контексте функции, если они не найдены в текущем контексте.

2. **Объект переменных (Variable Object):**
    - Содержит все переменные, функции и аргументы, определенные в контексте функции или глобальном контексте.
    - В случае функции он также содержит параметры, переданные функции.

3. **Ключевое слово `this`:**
    - Значение `this` зависит от того, как была вызвана функция.
    - В глобальном контексте `this` ссылается на глобальный объект (например, `window` в браузере).
    - В контексте функции значение `this` определяется способом вызова функции (например, может быть объектом, который вызывает метод).

### Стек контекстов выполнения (Execution Context Stack):
Когда JavaScript выполняет код, он использует стек контекстов выполнения (также называемый стеком вызовов). Каждый новый контекст выполнения добавляется в стек, когда начинается выполнение функции, и удаляется, когда функция завершает выполнение. Стек работает по принципу LIFO (последний пришел — первый ушел).

Пример:
```javascript
function a() {
  console.log('Function a');
  b();
}

function b() {
  console.log('Function b');
}

a();
```
1. Когда запускается `a()`, создается новый контекст выполнения для функции `a`.
2. Внутри `a()` вызывается `b()`, создается контекст выполнения для функции `b`, и он добавляется в стек.
3. Когда `b()` завершается, его контекст удаляется из стека, и выполнение возвращается в `a()`.

### Фазы контекста выполнения:
1. **Фаза создания (Creation Phase):**
    - JavaScript движок создает контекст выполнения, но не выполняет код.
    - Создается объект переменных, происходит "поднятие" (hoisting) переменных и функций.

2. **Фаза исполнения (Execution Phase):**
    - После завершения фазы создания, движок начинает выполнять код строка за строкой.

Контекст выполнения — это основа работы JavaScript, благодаря которой движок управляет областью видимости и контекстом вызова в процессе выполнения кода.

## 81. **Разница между примитивом и объектом?**
- `Примитивы` (числа, строки, булевые значения, `null`, `undefined`, `symbol`, `bigint`) хранятся непосредственно по
  значению.
- `Объекты` хранятся по ссылке и могут содержать множество значений и методов.

## 82. **Что значит текст max call stack size exceeded в консоли?**

Это ошибка, указывающая на переполнение стека вызовов, часто возникающая из-за бесконечной рекурсии.

## 83. **Как реализовать отложенную загрузку изображений?**

`Отложенная загрузка` (lazy loading) изображений может быть реализована с использованием атрибута `loading="lazy"` или
библиотеки, такой как `lazysizes`, или с использованием JavaScript:

```javascript
document.addEventListener("DOMContentLoaded", function() {
    const lazyImages = document.querySelectorAll("img.lazy");
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const img = entry.target;
                img.src = img.dataset.src;
                img.classList.remove("lazy");
                observer.unobserve(img);
            }
        });
    });
    lazyImages.forEach(img => observer.observe(img));
});
```

## 84. **Чем отличаются события input и change?**
- `input` срабатывает каждый раз при изменении значения элемента.
- `change` срабатывает, когда изменение элемента завершено (например, после потери фокуса).

## 85. **Почему typeof null возвращает object?**
Это баг в языке JavaScript, который сохранился для обратной совместимости. Исторически `null` интерпретировался как "нулевой объект".

## 86. **Зачем нужен конструктор Proxy?**
Конструктор `Proxy` в JavaScript нужен для создания объекта-прокси, который позволяет контролировать доступ к другому объекту, перехватывая и обрабатывая различные операции с этим объектом, такие как чтение, запись, вызовы методов и т.д.

Основные цели использования `Proxy`:
1. **Перехват операций с объектом**. `Proxy` позволяет перехватывать такие операции, как:
    - Доступ к свойствам (`get`)
    - Запись значений в свойства (`set`)
    - Удаление свойств (`deleteProperty`)
    - Проверка наличия свойства (`has`)
    - Вызов методов объекта (`apply`)
    - Создание новых экземпляров (`construct`)
    - И другие.

2. **Создание настраиваемых поведений**. Вы можете изменить или добавить логику для стандартных операций. Например, можно добавлять автоматическую валидацию данных при записи в объект, логировать изменения или динамически управлять доступом к определённым свойствам.

3. **Пример использования**:
   ```javascript
   const target = {
     message: "Hello, World!",
   };

   const handler = {
     get: function (target, property) {
       return property in target ? target[property] : "Property not found!";
     },
   };

   const proxy = new Proxy(target, handler);

   console.log(proxy.message); // "Hello, World!"
   console.log(proxy.nonExistentProp); // "Property not found!"
   ```

В этом примере объект `proxy` перехватывает попытки чтения свойств и, если запрашиваемое свойство отсутствует в объекте `target`, возвращает сообщение "Property not found!".

Таким образом, `Proxy` полезен для более гибкого контроля над поведением объектов в JavaScript.

## 87. **Что такое хвостовая рекурсия? Оптимизация рекурсии?**
`Хвостовая рекурсия` - это рекурсия, при которой рекурсивный вызов является последней операцией функции. Оптимизация
хвостовой рекурсии позволяет уменьшить использование памяти.

## 88. **Что такое и как работает debounce() и throttle() в JavaScript?**
- `debounce()`: ограничивает частоту вызова функции, вызывая её только после определенного времени с последнего
  вызова.
- `throttle()`: ограничивает количество вызовов функции, вызывая её не чаще определенного времени.

```javascript
function debounce(func, wait) {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

function throttle(func, limit) {
    let lastFunc;
    let lastRan;
    return function(...args) {
        if (!lastRan) {
            func.apply(this, args);
            lastRan = Date.now();
        } else {
            clearTimeout(lastFunc);
            lastFunc = setTimeout(() => {
                if (Date.now() - lastRan >= limit) {
                    func.apply(this, args);
                    lastRan = Date.now();
                }
            }, limit - (Date.now() - lastRan));
        }
    };
}
```

## 89. **Как в JavaScript работают декораторы? Как они могут быть использованы для модификации поведения классов и методов?**

`Декораторы` - это функции, которые принимают целевой объект, метод или свойство и могут изменять их поведение.

```javascript
function readonly(target, key, descriptor) {
    descriptor.writable = false;
    return descriptor;
}

class Example {
    @readonly
    method() {
        return "This method is readonly";
    }
}
```

# **ECMAScript**

## 1. **Что такое ECMAScript? В чём отличие от JavaScript?**
`ECMAScript` — это спецификация, стандарт скриптовых языков программирования, он является основой JS, поэтому любые изменения ECMAScript отражаются на JS.

`ECMAScript сам по себе - это не язык программирования`. `А вот JavaScript - это язык программирования`, реализующий стандарт ECMAScript.

## 2. **Разница между `let`, `const` и `var`?**
- `var` имеет функции или глобальную область видимости и может быть переназначен. Переменные, объявленные с `var`,
  подвержены всплытию (hoisting), т.е. они доступны в коде до своей фактической декларации.
- `let` имеет блочную область видимости и не подвержен всплытию. Переменная, объявленная с `let`, доступна только
  внутри блока, в котором она была объявлена.
- `const` также имеет блочную область видимости и не подвержен всплытию. `const` используется для объявления
  константных переменных, т.е. переменных, значения которых не могут быть переназначены после инициализации.

## 3. **Можно ли изменить значение, определённое через `const`?**
Значение, определённое через `const`, нельзя переназначить. Однако если `const` ссылается на объект (включая массивы
и функции), содержимое объекта можно изменить, но ссылка на сам объект останется неизменной.

## 4. **Что такое временная мёртвая зона (temporal dead zone)?**
`Временная мёртвая зона` — это период времени между началом блока кода, где объявлена переменная с `let` или `const`, и
моментом, когда эта переменная инициализирована. В этот период доступ к переменной вызывает ошибку.

## 5. **Разница между Rest и Spread операторами?**

- **Spread оператор** (`...`) используется для разложения массива или объекта на отдельные элементы или свойства.
  Например, `[...arr]` или `{...obj}`.
- **Rest оператор** (`...`) используется для сбора всех оставшихся аргументов функции в массив или свойства объекта в
  объект. Например, `function(...args)` или `const {a, ...rest} = obj`.

## 6. **Что такое деструктуризация?**

Деструктуризация — это синтаксическая особенность, позволяющая извлекать значения из массивов или свойств из объектов и
присваивать их переменным. Например, для массива: `const [a, b] = [1, 2]`, для объекта: `const {x, y} = {x: 1, y: 2}`.

## 7. **Для чего используется цикл `for…of`?**
   Цикл `for…of` используется для итерации по итерируемым объектам, таким как массивы, строки, карты, наборы и другие
   объекты, поддерживающие итерацию. Он позволяет получить значения элементов коллекции.

## 8. **Что такое шаблонные литералы (Template Literals)?**
   Шаблонные литералы — это строки, которые могут содержать выражения и многострочные тексты. Они создаются с помощью
   обратных кавычек (`` ` ``). Например: `` `Hello, ${name}` ``. Это позволяет легко вставлять переменные и выполнять
   выражения в строках.

## 9. **Что такое Set, Map, WeakMap и WeakSet?**

### 1. **Map** — коллекция пар "ключ-значение", где ключи могут быть любого типа. Порядок элементов в Map сохраняется.

**Методы и свойства:**

- **new Map()** – создаёт коллекцию.
- **Map.prototype.set(key, value)** – записывает по ключу key значение value.
- **Map.prototype.get(key)** – возвращает значение по ключу или undefined, если ключ key отсутствует.
- **Map.prototype.has(key)** – возвращает true, если ключ key присутствует в коллекции, иначе false.
- **Map.prototype.delete(key)** – удаляет элемент (пару «ключ/значение») по ключу key.
- **Map.prototype.clear()** – очищает коллекцию от всех элементов.
- **Map.prototype.size** – возвращает текущее количество элементов.

**Для перебора коллекции Map:**

- **Map.prototype.keys()** – возвращает итерируемый объект по ключам,
- **Map.prototype.values()** – возвращает итерируемый объект по значениям,
- **Map.prototype.entries()** – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется
  по умолчанию в for..of.

### 2. **Set** — коллекция уникальных значений. Значения в Set могут быть любого типа и не повторяются.

**Его основные методы это:**

- **new Set(iterable)** – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это
  массив), то копирует его значения в новый Set.
- **Set.prototype.add(value)** – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект
  Set.
- **Set.prototype.delete(value)** – удаляет значение, возвращает true, если value было в множестве на момент вызова,
  иначе false.
- **Set.prototype.has(value)** – возвращает true, если значение присутствует в множестве, иначе false.
- **Set.prototype.clear()** – удаляет все имеющиеся значения.
- **Set.prototype.size** – возвращает количество элементов в множестве.

**Для перебора коллекции Set:**

- **Set.prototype.keys()** – возвращает перебираемый объект для значений,
- **Set.prototype.values()** – то же самое, что и set.keys(), присутствует для обратной совместимости с Map,
- **Set.prototype.entries()** – возвращает перебираемый объект для пар вида [значение, значение], присутствует для
  обратной совместимости с Map.

### 3. **WeakMap** — аналог Map, но ключи должны быть объектами, и они не предотвращают сборку мусора. Это позволяет автоматически очищать неиспользуемые ключи.

### 4. **WeakSet** — аналог Set, но элементы могут быть только объектами, и они не предотвращают сборку мусора.

`WeakSet и WeakMap` – это специальные структуры данных в JavaScript, которые отличаются особенностью хранения ссылок на объекты.

В обычных `Set и Map` хранятся сильные ссылки на объекты. Это значит, что пока существует ссылка на объект в этих структурах, сборщик мусора не удалит этот объект из памяти, даже если больше нигде в коде нет ссылок на него.

И напротив, в WeakSet и WeakMap хранятся слабые ссылки. Это означает, что если объект, на который есть ссылка в этих структурах, больше недоступен в коде (т.е. нигде больше нет сильных ссылок на него), то сборщик мусора может удалить этот объект из памяти, даже если в WeakSet или WeakMap все еще есть ссылка на него. Таким образом, использование слабых ссылок позволяет не держать в памяти ненужные больше объекты и экономить память.

Кроме того, в WeakMap в качестве ключей могут использоваться только объекты, а не примитивные значения. А в WeakSet хранятся только объекты, без ключей.

## 10. **Разница между обычными функциями и стрелочными?**
- Обычные функции имеют собственное значение `this`, которое устанавливается в момент вызова функции. Также они
  имеют свою собственную область видимости для `arguments`.
- Стрелочные функции не имеют собственного `this`; вместо этого они захватывают значение `this` из окружающего
  контекста. Они также не имеют `arguments`.

## 11. **Разница между методом `Object.freeze()` и `const`?**
- `Object.freeze()` делает объект неизменным, т.е. нельзя изменять его свойства, добавлять новые или удалять
  существующие.
- `const` позволяет создавать переменные, которые не могут быть переназначены. Однако если `const` ссылается на
  объект, то его содержимое может изменяться.

## 12. **Что такое итераторы?**
`Итераторы` — это объекты, которые позволяют перебирать коллекции данных, такие как массивы, строки, карты и наборы.
Итератор должен реализовывать метод `next()`, который возвращает объект с двумя свойствами: `value` (текущее
значение) и `done` (флаг завершения итерации).

## 13. **Что такое генераторы? Когда стоит использовать генераторы?**
`Генераторы` — это функции, которые могут быть приостановлены и возобновлены. Они объявляются с
использованием `function*` и используют ключевое слово `yield` для возврата значений поэтапно. Генераторы удобны для
работы с итерациями, асинхронным кодом и потоками данных.

## 14. **Что такое ES6 модули?**
ES6 модули позволяют организовывать код в модули, которые могут экспортировать и импортировать функциональность.
Модули поддерживаются нативно в JavaScript и позволяют использовать ключевые слова `import` и `export` для работы с
модулями.

Модули позволяют объединять (использовать) код из разных файлов и избавляют нас от необходимости держать весь код в одном большом файле.

## 15. **Что такое символ (Symbol) в ES6?**
**`Символ (Symbol)`** — примитивный тип, значения которого создаются с помощью вызова функции Symbol. Каждый созданный символ уникален.

Символы могут использоваться в качестве имён свойств в объектах. Символьные свойства могут быть прочитаны только при прямом обращении и не видны при обычных операциях.

Для создания символа нужно вызвать функцию Symbol:

```JavaScript
const sym = Symbol()
const symTwo = Symbol()

console.log(sym === symTwo)
// false
```

Символы используются для создания скрытых свойств объектов. В отличие от свойств, ключом которых является строка, символьные свойства может читать только владелец символа. Скрытые свойства не видны при его обходе с помощью for...in.

Это может пригодиться, когда необходимо добавить свойства объекту, который могут модифицировать другие части программы. Таким образом только вы сможете читать созданное свойство, а гарантия уникальности символов гарантирует и отсутствие конфликтов имён.

Символы активно используются внутри самого JavaScript, чтобы определять поведение объектов. Такие символы называются «хорошо известными» (well-known symbols).

Самый известный символ Symbol.iterator, который позволяет реализовать обход конструкции с помощью синтаксических конструкций for..of и спред-синтаксиса.

Полный список таких символов доступен в спецификации, но на практике он нужен нечасто.

## 16. **Для чего используется метод `.includes()`?**
Метод `.includes()` проверяет, содержит ли массив или строка указанный элемент. Для
массива: `arr.includes(element)`, для строки: `str.includes(substring)`.

## 17. **Для чего используется метод `.getOwnPropertyDescriptors()`?**
Метод `.getOwnPropertyDescriptors()` возвращает объект, содержащий дескрипторы свойств для всех собственных свойств
объекта. Это позволяет получить подробную информацию о свойствах, включая их значение, доступность для чтения/записи
и т.д.

## 18. **Расскажите о методах `.keys()`, `.values()`, `.entries()`?**
- `.keys()` возвращает итератор, содержащий ключи коллекции (например, для объектов Map и Set).
- `.values()` возвращает итератор, содержащий значения коллекции.
- `.entries()` возвращает итератор, содержащий пары [ключ, значение] для коллекций типа Map и Set.

## 19. **Для чего используется метод `.fromEntries()`?**
Метод `.fromEntries()` преобразует список пар ключ-значение в объект.
Например, `Object.fromEntries([['a', 1], ['b', 2]])` вернёт `{a: 1, b: 2}`.

## 20. **Для чего используются методы `.flat()` и `.flatMap()`?**
- `.flat()` используется для выравнивания вложенных массивов на заданную глубину.
- `.flatMap()` сначала применяет функцию к каждому элементу массива, а затем выравнивает результат в один уровень.

## 21. **Для чего используются методы `.padStart()` и `.padEnd()`?**
- `.padStart()` добавляет заданное количество символов в начало строки, чтобы достичь заданной длины.
- `.padEnd()` добавляет символы в конец строки до достижения заданной длины.

## 22. **Для чего используются методы `.startsWith()` и `.endsWith()`?**
- `.startsWith()` проверяет, начинается ли строка с указанного подстроки.
- `.endsWith()` проверяет, заканчивается ли строка указанной подстрокой.

## 23. **Как в JavaScript удалять пробельные символы в начале и в конце строки?**
Для удаления пробельных символов можно использовать метод `.trim()`. Например, `"  Hello  ".trim()`
вернёт `"Hello"`.

## 24. **Расскажите об операторе Optional Chaining (?.)?**
Оператор Optional Chaining (`?.`) позволяет безопасно обращаться к вложенным свойствам объекта, не вызывая ошибку,
если одно из промежуточных свойств `null` или `undefined`. Например, `obj?.property?.subProperty`.

## 25. **Для чего используется метод `.replaceAll()`?**
Метод `.replaceAll()` заменяет все вхождения подстроки или регулярного выражения на другую подстроку. Например, `"
foo foo".replaceAll("foo", "bar")` вернёт `"bar bar"`.

## 26. **Что такое оператор логического присваивания?**
Оператор логического присваивания сочетает логическое действие с присваиванием. Например, `x &&= y`
эквивалентен `x && (x = y)`.

## 27. **Как увеличить читаемость больших чисел?**
Для увеличения читаемости больших чисел можно использовать разделители подчеркивания. Например, `1_000_000`
представляет собой миллион.

## 28. **Что такое приватные аксессоры?**
Приватные аксессоры (или приватные поля и методы) доступны только внутри класса, где они объявлены. Они обозначаются
символом `#`. Например:
```javascript
class MyClass {
  #privateField;
  constructor(value) {
    this.#privateField = value;
  }
}
```

## 29. **Разница между ES6-классами и конструкторами функций?**
- ES6-классы предоставляют более чистый и понятный синтаксис для создания объектов и работы с наследованием.
- Конструкторы функций более старый подход, где объекты создаются с помощью функции-конструктора и прототипного
  наследования.

## 30. **Что такое оператор нулевого слияния (??)?**
`Оператор нулевого слияния` (`??`) возвращает правый операнд, если левый операнд равен `null` или `undefined`. В
противном случае возвращает левый операнд.

## 31. **В чём отличие оператора нулевого слияния (??) и оператора “ИЛИ” (||)?**
Оператор `??` возвращает правый операнд только если левый операнд равен `null` или `undefined`, в то время как `||`
возвращает правый операнд, если левый операнд является falsy значением (например, `0`, `''`, `NaN`).

## 35. **Как работают дефолтные параметры в ES6?**
Дефолтные параметры позволяют задавать значения по умолчанию для параметров функции. Если аргумент функции не
передан или равен `undefined`, используется значение по умолчанию. Например:
```javascript
function greet(name = "Guest") {
  return `Hello, ${name}!`;
}
```

## 36. **Что такое BigInt в ES2020 и для чего он используется?**
`BigInt` — это примитивный тип данных для работы с целыми числами произвольной длины. Он используется, когда числа
превышают пределы стандартного числового типа `Number`. Создается с помощью функции `BigInt()`,
например, `BigInt(123456789012345678901234567890)`.

## 37. **Какие нововведения были представлены в ECMAScript 2021 (ES12)?**
В ECMAScript 2021 были добавлены следующие нововведения:
- Оператор `&&=`, `||=`, `??=` для логического присваивания.
- Метод `String.prototype.replaceAll()` для замены всех вхождений.
- Метод `WeakRef` для создания слабых ссылок.
- Приватные поля и методы класса, доступные только внутри класса.
- Улучшения в `Promise`, такие как `Promise.any()`.
- Изменения в методах работы с объектами, такие как `Object.hasOwn()`.

# **Async JavaScript**

## 1. **Разница между синхронными и асинхронными функциями?**

Синхронные функции выполняются последовательно: одна за другой. Это означает, что следующая строка кода не будет
выполнена, пока текущая функция не завершится. Асинхронные функции позволяют выполнять код параллельно, не блокируя
выполнение последующих строк кода. Они могут завершаться позже, чем последующие операции.

## 2. **Что такое AJAX?**

AJAX (Asynchronous JavaScript and XML) - это набор технологий, который позволяет загружать данные с сервера
асинхронно без перезагрузки страницы. AJAX использует объект XMLHttpRequest или fetch для отправки и получения данных
в различных форматах, включая JSON и XML.

## 3. **Что такое same-origin policy в контексте JavaScript?**

Same-origin policy (политика того же источника) - это механизм безопасности, который ограничивает взаимодействие
скриптов, загруженных с одного источника, с ресурсами, загруженными с другого источника. Это предотвращает атаки,
такие как межсайтовый скриптинг (XSS).

## 4. **Что такое цикл событий (event loop) и как он работает?**

Цикл событий (event loop) — это механизм в JavaScript, который управляет выполнением асинхронных операций, позволяя языку быть **однопоточным**, но при этом эффективно работать с задачами, которые требуют времени, как сетевые запросы или таймеры.

### Как работает цикл событий:

1. **Основной поток (call stack)**: Все синхронные операции выполняются в основном потоке (стеке вызовов). Когда вызывается функция, она помещается в стек и выполняется последовательно.

2. **Асинхронные операции**: Когда JavaScript сталкивается с асинхронной операцией (например, запросом к серверу, таймером или обработчиком события), эта операция передается браузеру или Node.js для обработки на фоне. Основной поток продолжает работать с другими задачами.

3. **Очередь задач (callback queue)**: После завершения асинхронной операции её коллбэк помещается в очередь задач. Однако коллбэк не будет выполнен немедленно — он должен дождаться, пока основной поток освободится.

4. **Цикл событий (event loop)**: Цикл событий постоянно проверяет основной поток и очередь задач. Если основной поток пуст, он забирает задачу из очереди и помещает её в стек вызовов для выполнения.

**Пример:**

```javascript
console.log('Начало');

setTimeout(() => {
  console.log('Асинхронная операция');
}, 1000);

console.log('Конец');
```

**Вывод:**
```
Начало
Конец
Асинхронная операция
```

- Сначала выполняются синхронные операции — вывод "Начало" и "Конец".
- `setTimeout` — это асинхронная операция, её коллбэк попадает в очередь задач и выполнится после того, как основной поток освободится и истечёт время таймера.

## 5. **Разница между микро и макрозадачами в event loop?**
В JavaScript цикл событий (event loop) обрабатывает две разные очереди задач: **микрозадачи** (microtasks) и **макрозадачи** (macrotasks). Различие между ними важно для понимания порядка выполнения операций в асинхронном коде.

### Макрозадачи (macrotasks)
Макрозадачи — это более крупные задачи, такие как:
- `setTimeout`
- `setInterval`
- Ввод-вывод (I/O) операции (например, сетевые запросы)
- Обработчики событий (клики, ввод данных и т.д.)

После выполнения всех синхронных операций из стека вызовов цикл событий выполняет одну макрозадачу, затем переходит к выполнению всех микрозадач.

### Микрозадачи (microtasks)
Микрозадачи — это более мелкие задачи, такие как:
- Промисы (`Promise` и `Promise.then`)
- `process.nextTick()` (в Node.js)
- Обновления DOM (например, мутации в браузере)

Микрозадачи имеют более высокий приоритет по сравнению с макрозадачами. После завершения каждой макрозадачи цикл событий выполняет **все микрозадачи**, находящиеся в очереди, перед тем как перейти к следующей макрозадаче.

### Порядок выполнения:

1. Выполняется синхронный код.
2. Выполняется одна макрозадача из очереди.
3. Выполняются все микрозадачи, которые появились в процессе выполнения макрозадачи.
4. Повторение цикла.

### Пример:

```javascript
console.log('Синхронный код');

setTimeout(() => {
  console.log('Макрозадача');
}, 0);

Promise.resolve().then(() => {
  console.log('Микрозадача');
});

console.log('Конец синхронного кода');
```

**Вывод:**
```
Синхронный код
Конец синхронного кода
Микрозадача
Макрозадача
```

- Сначала выполняется синхронный код: "Синхронный код" и "Конец синхронного кода".
- Затем выполняется микрозадача (Promise): "Микрозадача".
- После этого выполняется макрозадача (setTimeout): "Макрозадача".

### Ключевые моменты:
- Микрозадачи всегда выполняются **до** макрозадач.
- После выполнения макрозадачи цикл событий обязательно завершит все микрозадачи перед переходом к следующей макрозадаче.

Этот механизм позволяет JavaScript более эффективно управлять асинхронностью, обеспечивая предсказуемый порядок выполнения задач.

## 6. **Расскажите о queueMicrotask?**
`queueMicrotask` - это метод, который позволяет добавлять микрозадачи в очередь микрозадач, которые будут выполнены
после текущего синхронного кода и перед любыми макрозадачами.

## 7. **Что такое промисы (Promises)?**
`Promise` - это объект, представляющий результат асинхронной операции. Он может находиться в одном из трёх состояний:
ожидает (pending), выполнен (fulfilled), отклонён (rejected). Промисы позволяют удобнее работать с асинхронным кодом,
избегая вложенных колбэков.

## 8. **Плюсы и минусы использования Ajax?**
`Плюсы:`

- Обновление данных без перезагрузки страницы.
- Улучшение пользовательского опыта.
- Повышение производительности за счет уменьшения объема передаваемых данных.

`Минусы:`

- Сложности с обработкой ошибок.
- Проблемы с кешированием и безопасностью.
- Ограничения same-origin policy.

## 9. **Подходы при работе с асинхронным кодом?**

- Колбэки (Callbacks)
- Промисы (Promises)
- async/await

## 10. **Преимущества использования промисов вместо колбэков?**

- Упрощение обработки ошибок.
- Избежание вложенности колбэков (Callback Hell).
- Четкий и понятный код, работающий с асинхронными операциями.

## 11. **Что такое callback-функция? Что такое Callback Hell?**
`Callback-функция` - это функция, которая передается в другую функцию как аргумент 
и выполняется после того, как закончатся какие-то другие операции.
`Callback Hell` - это проблема вложенных колбэков, приводящая к трудно читаемому и поддерживаемому коду.

## 12. **Проблемы при использовании callback-функций?**

- Callback Hell.
- Трудности с обработкой ошибок.
- Сложность в отладке и поддержке кода.

## 13. **Что такое async/await?**
`async/await` - это синтаксический сахар для работы с промисами, который позволяет писать асинхронный код так, как
если бы он был синхронным. `async` помечает функцию как асинхронную, `await` заставляет ждать выполнения промиса.

## 14. **Разница между Promise.all(), Promise.any() и Promise.race()?**

- `Promise.all()`: Выполняется, когда все промисы завершены. Если один из промисов отклонен, возвращает ошибку.
- `Promise.any()`: Выполняется, когда хотя бы один из промисов выполнен. Если все промисы отклонены, возвращает ошибку.
- `Promise.race()`: Выполняется, когда первый из промисов завершен (выполнен или отклонен).

## 15. **Расскажите про статический метод .allSettled()?**
`Promise.allSettled()` возвращает промис, который выполняется, когда все переданные промисы завершены (выполнены или
отклонены). Результат содержит массив объектов с состоянием и значением/причиной каждого промиса.

## 16. **Плюсы и минусы асинхронного программирования в JavaScript?**
`Плюсы:`

- Улучшение производительности.
- Уменьшение времени ожидания пользователя.
- Эффективное использование ресурсов.

`Минусы:`

- Сложности с отладкой.
- Потенциальные проблемы с гонками данных.
- Необходимость обработки ошибок.

## 17. **Как выполнить несколько асинхронных операций последовательно?**
Использование async/await:

```javascript
async function sequentialExecution() {
    await asyncOperation1();
    await asyncOperation2();
    await asyncOperation3();
}
```

## 18. **Какие проблемы может вызвать неправильное использование асинхронности в JavaScript?**

- Гонки данных (race conditions).
- Зависания и блокировки.
- Утечки памяти.
- Трудности с отладкой и тестированием.

## 19. **Что такое fetch()? Как работает функция fetch()?**
`fetch()` - это современный метод для выполнения HTTP-запросов. Он возвращает промис, который разрешается с объектом
Response. Пример:

```javascript
fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error('Error:', error));
```

## 20. **Что такое JSON в JavaScript? Как его можно использовать?**
`JSON` (JavaScript Object Notation) - это формат для обмена данными, основанный на JavaScript-объектах. Он
используется для передачи данных между сервером и клиентом. В JavaScript его можно парсить и сериализовать с
помощью `JSON.parse()` и `JSON.stringify()`.

## 21. **Что такое и как работает коэффициент сжатия (compression ratio) в контексте веб-разработки?**
`Коэффициент сжатия` - это отношение размера несжатого файла к размеру сжатого файла. В веб-разработке он используется
для уменьшения объема передаваемых данных, что ускоряет загрузку страниц и уменьшает нагрузку на серверы.

# **JavaScript in Browser**

## 1. Что такое DOM?

`DOM (Document Object Model)` — это специальная древовидная структура, которая позволяет управлять HTML-разметкой из JavaScript-кода. Управление обычно состоит из добавления и удаления элементов, изменения их стилей и содержимого.

Браузер создаёт DOM при загрузке страницы, складывает его в переменную document и сообщает, что DOM создан, с помощью
события DOMContentLoaded.

## 2. **Типы узлов DOM-дерева?**
Основные типы узлов DOM-дерева:
- `Element`: узлы элементов, такие как `<div>`, `<p>`, `<a>`.
- `Attribute`: узлы атрибутов, связанные с элементами.
- `Text`: текстовые узлы, содержащие текст внутри элементов.
- `Comment`: узлы комментариев.
- `Document`: корневой узел документа.
- `DocumentFragment`: фрагмент документа, который можно использовать для временного хранения элементов.

## 3. **Методы поиска элементов в DOM?**
- `document.getElementById(id)`: находит элемент по идентификатору.
- `document.getElementsByClassName(className)`: находит элементы по имени класса.
- `document.getElementsByTagName(tagName)`: находит элементы по имени тега.
- `document.querySelector(selector)`: находит первый элемент, соответствующий CSS-селектору.
- `document.querySelectorAll(selector)`: находит все элементы, соответствующие CSS-селектору.

## 4. **Свойства для перемещения по DOM-дереву?**
- `parentNode`: родительский узел.
- `childNodes`: список дочерних узлов.
- `firstChild`: первый дочерний узел.
- `lastChild`: последний дочерний узел.
- `nextSibling`: следующий соседний узел.
- `previousSibling`: предыдущий соседний узел.

## 5. **Разница между attribute и property у DOM-элементов?**
- **Attribute**: относится к HTML-атрибутам, как они указаны в исходном коде. Например, `<input type="text" />`
  имеет атрибут `type`.
- **Property**: относится к свойствам объекта в DOM. Например, `element.type` указывает на текущее значение
  свойства `type`, которое может отличаться от значения атрибута.

## 6. **Что такое BOM?**
   BOM (Browser Object Model) представляет объекты, предоставляемые браузером, которые позволяют взаимодействовать с
   браузерным окружением. Например, `window`, `navigator`, `location`, `history` и `screen` — это объекты BOM.

## 7. **Виды событий в JavaScript?**
- **Мышь
  **: `click`, `dblclick`, `mousedown`, `mouseup`, `mousemove`, `mouseover`, `mouseout`, `mouseenter`, `mouseleave`.
- **Клавиатура**: `keydown`, `keyup`, `keypress`.
- **Форма**: `submit`, `change`, `focus`, `blur`, `input`.
- **Документ и окно**: `load`, `unload`, `resize`, `scroll`, `DOMContentLoaded`.
- **Сетевые события**: `error`, `progress`, `loadend`.

## 8. **Как добавить обработчик события на DOM-элемент?**
   ```javascript
   element.addEventListener('event', function() {
     // обработчик события
   });
   ```
   Например:
   ```javascript
   document.getElementById('myButton').addEventListener('click', function() {
     alert('Button clicked!');
   });
   ```

## 9. **Как удалить обработчик события с DOM-элемента?**
   ```javascript
   element.removeEventListener('event', handler);
   ```
   Пример:
   ```javascript
   function handleClick() {
     alert('Button clicked!');
   }

   const button = document.getElementById('myButton');
   button.addEventListener('click', handleClick);
   // Удаление обработчика
   button.removeEventListener('click', handleClick);
   ```

## 10. **Что такое распространение события (Event Propagation)?**

Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие
«распространяется» от объекта window до вызвавшего его элемента (event.target). При этом событие последовательно
пронизывает всех предков целевого элемента.

Этот процесс называется Event Propagation (распространение события).

**Event Propagation имеет три стадии:**

1. **Фаза погружения** — событие возникает в объекте window и опускается до цели события через всех ее предков.
2. **Целевая фаза** — это когда событие достигает целевого элемента.
3. **Фаза всплытия** — событие поднимается от event.target, последовательно проходит через всех его предков и достигает
   объекта window.

## 11. **Что такое делегирование событий (Event Delegation)?**

**Делегирование событий** — подход при работе с событиями DOM-дерева, при котором обработчики событий добавляются не на
каждый конкретный элемент, а только на общий родительский, в то время как необходимость вызова это обработчика для
конкретного интересующего нас элемента определяется через инициатора события, узнать который можно из свойства объекта
события event.target.

Такой подход возможен благодаря особенностям событийной модели DOM-дерева, а конкретно такой особенности, как всплытие
событий.

## 12. **Как использовать media выражения в JavaScript?**

Media выражения обычно используются в CSS, но также могут быть использованы в JavaScript
через `window.matchMedia()`. Пример:

```javascript
const mediaQuery = window.matchMedia('(max-width: 600px)');
if (mediaQuery.matches) {
    console.log('Экран меньше 600px');
} else {
    console.log('Экран больше 600px');
}
```

## 13. **Расскажите про координаты в браузере?**
Координаты в браузере можно получить с помощью `getBoundingClientRect()`, который возвращает размер элемента и его
позицию относительно видимой области экрана. Пример:
```javascript
const rect = element.getBoundingClientRect();
console.log(rect.top, rect.left, rect.width, rect.height);
```

## 14. **Разница между HTMLCollection и NodeList?**
- **HTMLCollection**: коллекция элементов, которые обновляются автоматически при изменении DOM. Обычно возвращается
  методами типа `getElementsByClassName` или `getElementsByTagName`.
- **NodeList**: коллекция узлов, не обязательно элементов. Возвращается методами типа `querySelectorAll`. NodeList
  может быть как живым (обновляющимся), так и статичным (необновляющимся).

## 15. **Как динамически добавить элемент на HTML-страницу?**
```javascript
const newElement = document.createElement('div');
newElement.textContent = 'Привет, мир!';
document.body.appendChild(newElement);
```

## 16. **Разница между feature detection, feature inference и анализом строки user-agent?**
- **Feature Detection**: проверка поддержки функциональности браузером. Например, проверка наличия метода `fetch`.
- **Feature Inference**: использование существующих методов или свойств для определения поддержки функции.
- **Анализ строки user-agent**: использование строки user-agent для определения типа и версии браузера. Этот метод
  менее надежен, чем feature detection.

## 17. **Разница между e.preventDefault() и e.stopPropagation()?**

- **`Метод event.preventDefault()`** отключает поведение элемента по умолчанию. Если использовать этот метод в элементе
  form, то он предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет
  отключено (данный метод часто используется в keydown для переопределения клавиатуры, например, при создании
  музыкального/видео плеера или текстового редактора — прим. пер.).

- **Метод event.stopPropagation()** отключает распространение события (его всплытие или погружение).

## 18. **Разница между event.target и event.currentTarget?**
- **event.target**: элемент, на котором произошло событие.
- **event.currentTarget**: элемент, на который назначен обработчик события (может отличаться, если используется
  делегирование событий).

## 19. **Разница между .stopPropagation() и .stopImmediatePropagation()?**
- **.stopPropagation()**: останавливает дальнейшее распространение события по дереву DOM.
- **.stopImmediatePropagation()**: останавливает дальнейшее распространение события и предотвращает выполнение
  других обработчиков на том же элементе.

## 20. **Разница между событиями load и DOMContentLoaded?**
- **`load`**: срабатывает, когда полностью загружен весь документ, включая все стили, изображения и другие ресурсы.
- **`DOMContentLoaded`**: срабатывает, когда весь HTML документ был полностью загружен и разобран, но до загрузки
  стилей, изображений и других ресурсов.

## 21. **Сколько аргументов принимает addEventListener?**
Метод `addEventListener` принимает три аргумента:
1. Тип события (строка).
2. Обработчик события (функция).
3. Опции (необязательный объект или логическое значение, указывающее, должно ли событие быть захваченным или
   всплывающим).

## 22. **Разница между innerHTML и outerHTML?**
- **innerHTML**: возвращает или устанавливает HTML-контент внутри элемента.
- **outerHTML**: возвращает или устанавливает HTML-контент элемента, включая сам элемент.

## 23. **Разница между JSON и XML?**
- **JSON** (`JavaScript Object Notation`): легковесный формат данных, используемый для обмена данными, легко
  читается
  человеком и машиной.
- **XML** (`eXtensible Markup Language`): более сложный формат для хранения и передачи данных, использующий разметку
  для определения структуры.

## 24. **Как узнать об использовании метода event.preventDefault()?**
Чтобы определить, вызван ли метод `preventDefault`, можно проверить свойство `defaultPrevented` объекта события:

```javascript
handleEvent(e)
{
    if (e.defaultPrevented) {
        console.log('preventDefault был вызван');
    }
}
```

## 25. **Для чего используется свойство window.navigator?**
Свойство `window.navigator` предоставляет информацию о браузере и операционной системе пользователя, включая имя
браузера, версию, язык и платформу.

## 26. **Для чего используется метод .focus()?**
Метод `.focus()` используется для установки фокуса на элементе формы или вводе текста, чтобы пользователь мог начать
взаимодействие с ним сразу.

## 27. **Для чего используется свойство .forms?**
Свойство `.forms` объекта `document` возвращает коллекцию всех форм в документе.

## 28. **Для чего используется метод .scrollIntoView()?**
Метод `.scrollIntoView()` прокручивает элемент так, чтобы он оказался видимым в области просмотра. Это может быть
полезно для приведения элемента в фокус.

## 29. **Разница между методами .submit() и .requestSubmit()?**
- **.submit()**: отправляет форму, обходя валидацию HTML5 и обработчики события `submit`.
- **.requestSubmit()**: отправляет форму, включая валидацию HTML5 и вызов обработчиков события `submit`.

## 30. **Расскажите о IntersectionObserver?**
`IntersectionObserver` позволяет асинхронно наблюдать за пересечением элемента с областью видимости. Это полезно для
реализации ленивой загрузки изображений или триггеров для анимаций.

Пример:
```javascript
let observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      console.log('Элемент видим!');
    }
  });
});

observer.observe(document.querySelector('#myElement'));
```

## 31. **Расскажите о URLSearchParams?**
`URLSearchParams` предоставляет интерфейс для работы с параметрами строки запроса URL. Он позволяет легко читать,
изменять и добавлять параметры.

Пример:
```javascript
let params = new URLSearchParams('?name=John&age=30');
console.log(params.get('name')); // John
console.log(params.has('age'));  // true
params.append('city', 'New York');
console.log(params.toString()); // name=John&age=30&city=New+York
```

## 32. **Какие есть ограничения у window.close()?**
Метод `window.close()` может быть вызван только для окон, которые были открыты с помощью `window.open()`. Попытка
закрыть окно, которое не было открыто скриптом, может быть заблокирована браузером.

## 33. **Как можно создавать пользовательское событие (custom events) в JavaScript?**
Создание пользовательского события с помощью `CustomEvent`:
```javascript
let event = new CustomEvent('myEvent', { detail: { key: 'value' } });
element.dispatchEvent(event);
```

## 34. **Какие существуют методы для хранения данных в браузере?**
**Есть 3 основных метода хранения данных в браузере:**

`LocalStorage` и `SessionStorage` используются для хранения пар ключ-значение. Данные, сохраненные в них, сохраняются после обновления страницы. При этом только LocalStorage может сохранять данные после перезапуска браузера. Оба хранилища могут использовать только строки в качестве ключей и значений, поэтому объекты необходимо преобразовать с помощью JSON.stringify().

`Cookie` – небольшие строки данных, которые хранятся в браузере. Cookie обычно устанавливаются веб-сервером с использованием заголовка Set-Cookie. Браузер затем автоматически добавляет их почти ко всем запросам на тот же домен с использованием заголовка Cookie. Один экземпляр cookie может содержать до 4 кб данных. В зависимости от браузера, допускается более 20 cookie на сайт.

`IndexedDB` – встроенная база данных, более мощная, чем LocalStorage. Это NoSQL-хранилище данных в формате JSON внутри браузера, где доступны несколько типов ключей, а значения могут быть практически любым. IndexedDB поддерживает асинхронный доступ, транзакции для обеспечения согласованности данных и создание индексов для эффективного поиска. Позволяет хранить больше данных, чем LocalStorage, может быть связана с Service Workers и другими технологиями, которые обеспечивают функционирование PWA в оффлайне.

## 35. **Расскажите о методе requestAnimationFrame()?**
`requestAnimationFrame()` позволяет запланировать выполнение функции перед следующим перерисовыванием экрана. Это
эффективный способ для реализации анимаций, так как браузер оптимизирует их выполнение, чтобы избежать лишних
перерисовок.

Пример:
```javascript
function animate() {
  // обновить состояние анимации
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
    ```
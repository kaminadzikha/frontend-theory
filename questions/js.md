# **JavaScript**

1. **Типы данных в JavaScript?**
   В JavaScript есть следующие типы данных:
    - Примитивные типы: `number`, `string`, `boolean`, `null`, `undefined`, `symbol`, `bigint`.
    - Объектные типы: `object`, `function`.

2. **Разница между == и === (нестрогое/строгое равенство)?**
   `==` (нестрогое равенство) проверяет равенство значений с приведением типов. `===` (строгое равенство) проверяет равенство значений без приведения типов.

3. **Что такое Strict mode в JavaScript?**
   Strict mode ("строгий режим") вводит в код дополнительные проверки и ограничения для улучшения качества и безопасности кода. Включается директивой `"use strict";`.

4. **Разница между function declaration и function expression?**
    - `Function declaration` (объявление функции): `function foo() { }` - имеет имя и доступна везде в текущей области видимости благодаря "поднятию".
    - `Function expression` (функциональное выражение): `const foo = function() { }` - может быть анонимным или именованным, но доступно только после его объявления.

5. **Разница между null и undefined?**
    - `null` - явное отсутствие значения.
    - `undefined` - значение по умолчанию для необъявленных переменных или отсутствующих аргументов функций.

6. **Типы таймеров в JavaScript?**
    - `setTimeout`: выполняет функцию через определённое время.
    - `setInterval`: выполняет функцию с заданным интервалом.
    - `requestAnimationFrame`: выполняет функцию перед следующим перерисовкой экрана.

7. **Что такое поднятие (Hoisting)?**
   Поднятие - это механизм JavaScript, при котором объявления переменных и функций "поднимаются" в верхнюю часть их области видимости во время компиляции.

8. **Что такое область видимости (Scope)?**
   Область видимости - это контекст, в котором определяются переменные и функции. В JavaScript есть глобальная, функциональная и блочная области видимости.

9. **Разница между var, let и const?**
    - `var`: функциональная область видимости, допускает повторное объявление.
    - `let`: блочная область видимости, не допускает повторное объявление.
    - `const`: блочная область видимости, значение нельзя изменить после инициализации.

10. **Что такое замыкание (Closure)?**
    Замыкание - это функция, которая "помнит" окружение, в котором была создана, даже после того, как это окружение исчезло.

11. **Что обозначает this в JavaScript?**
    `this` ссылается на контекст выполнения функции. В глобальной области видимости `this` ссылается на глобальный объект (`window` в браузере).

12. **Что такое функции высшего порядка (Higher Order Functions)?**
    Функции высшего порядка - это функции, которые принимают другие функции в качестве аргументов или возвращают их.

13. **Как превратить любой тип данных в булевый? Перечислите ложные значения в JS?**
    Преобразование в булевый тип можно сделать через функцию `Boolean()` или оператор `!!`. Ложные значения: `false`, `0`, `-0`, `0n`, `""` (пустая строка), `null`, `undefined`, `NaN`.

14. **Методы строк в JavaScript?**
    - `length`
    - `charAt()`
    - `includes()`
    - `indexOf()`
    - `slice()`
    - `substring()`
    - `split()`
    - `toLowerCase()`
    - `toUpperCase()`
    - `trim()`

15. **Методы массивов в JavaScript?**
    - `length`
    - `push()`
    - `pop()`
    - `shift()`
    - `unshift()`
    - `concat()`
    - `slice()`
    - `splice()`
    - `forEach()`
    - `map()`
    - `filter()`
    - `reduce()`
    - `find()`
    - `findIndex()`
    - `includes()`
    - `indexOf()`

16. **Что такое чистая функция?**
    Чистая функция - это функция, которая:
    - Всегда возвращает один и тот же результат для одних и тех же аргументов.
    - Не имеет побочных эффектов.

17. **Разница между .forEach() и .map()?**
    - `.forEach()`: выполняет функцию для каждого элемента массива, не возвращает новое значение.
    - `.map()`: выполняет функцию для каждого элемента массива и возвращает новый массив с результатами.

18. **Разница между .call(), .apply() и bind()?**
    - `.call()`: вызывает функцию с указанным `this` и аргументами, переданными по отдельности.
    - `.apply()`: вызывает функцию с указанным `this` и аргументами, переданными в виде массива.
    - `.bind()`: возвращает новую функцию с указанным `this` и частично переданными аргументами.

19. **Почему в JS функции называют объектами первого класса?**
    Функции являются объектами первого класса, потому что их можно передавать как аргументы, возвращать из других функций и присваивать переменным.

20. **Как определить наличие свойства в объекте?**
    - Оператор `in`: `"property" in object`
    - Метод `.hasOwnProperty()`: `object.hasOwnProperty("property")`

21. **Что такое IIFE?**
    IIFE (Immediately Invoked Function Expression) - это функция, которая вызывается сразу после своего определения:
    ```javascript
    (function() { /* code */ })();
    ```

22. **Что такое псевдомассив arguments?**
    `arguments` - это объект, похожий на массив, доступный внутри всех функций, который содержит переданные функции аргументы.

23. **Разница между host-объектами и нативными объектами?**
    - Нативные объекты - встроенные объекты JavaScript (`Object`, `Array`, и т.д.).
    - Host-объекты - объекты, предоставленные средой выполнения (например, браузерные объекты, такие как `window`, `document`).

24. **Почему результат сравнения 2х объектов это false?**
    В JavaScript объекты сравниваются по ссылке, а не по значению. Два разных объекта будут всегда не равны друг другу, даже если они содержат одинаковые данные.

25. **Что такое прототипное наследование? Как создать объект без прототипа?**
    Прототипное наследование - механизм, при котором объекты могут наследовать свойства и методы от другого объекта (прототипа). Объект без прототипа можно создать с помощью `Object.create(null)`.

26. **Почему расширение нативных JavaScript-объектов это плохая практика?**
    Расширение нативных объектов может привести к конфликтам и проблемам совместимости, особенно если библиотека или другой код делает то же самое.

27. **Что такое NaN? Как определить, что значение равно NaN?**
    `NaN` (Not-a-Number) - специальное значение, которое указывает, что результат операции не является числом. Определить `NaN` можно с помощью функции `isNaN()` или метода `Number.isNaN()`.

28. **Что такое объектная обертка (Wrapper Objects)?**
    Объектные обертки (`String`, `Number`, `Boolean`) позволяют работать с примитивными значениями как с объектами, предоставляя методы и свойства.

29. **Как в JavaScript создать объект?**
    - Литерал объекта: `{ key: value }`
    - `new Object()`
    - `Object.create(proto)`

30. **Для чего используется ключевое слово new?**
    Ключевое слово `new` используется для создания экземпляра объекта на основе функции-конструктора.

31. **Операторы «И» и «ИЛИ» (&& и ||)?**
    - `&&` (И): возвращает первое ложное значение или последнее истинное.
    - `||` (ИЛИ): возвращает первое истинное значение или последнее ложное.

32. **Для чего используется оператор двойного отрицания (!!)?**
    Оператор двойного отрицания используется для приведения значения к булевому типу.

33. **Для чего используется оператор остатка (%)?**
    Оператор остатка возвращает остаток от деления двух чисел.

34. **Как проверить, является ли значение массивом?**
    С помощью метода `Array.isArray()`:
    ```javascript
    Array.isArray(value);
    ```

35. **Как работает boxing/unboxing в JavaScript?**
    Boxing - это процесс оборачивания примитива в объектную обертку, например, при доступе к свойствам или методам примитивного значения. Unboxing - обратный процесс, когда объектная обертка преобразуется обратно в примитив.

36. **Что такое мемоизация? Реализуйте базовую логи

ку функции для мемоизации?**
Мемоизация - это оптимизация, при которой результаты функции сохраняются и используются при последующих вызовах с теми же аргументами.
```javascript
function memoize(fn) {
const cache = {};
return function(...args) {
const key = JSON.stringify(args);
if (!(key in cache)) {
cache[key] = fn(...args);
}
return cache[key];
};
}
```

37. **Разница между оператором in и методом .hasOwnProperty()?**
    - `in` проверяет наличие свойства в объекте и его прототипах.
    - `.hasOwnProperty()` проверяет наличие свойства только в самом объекте.

38. **Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? Как сделать каждую из них?**
    - Поверхностная копия копирует только верхний уровень объекта. Например, с помощью `Object.assign()` или оператора распространения `{ ...obj }`.
    - Глубокая копия копирует все уровни вложенности объекта. Например, с помощью `JSON.parse(JSON.stringify(obj))` или библиотек вроде `lodash`.

39. **Что такое цепочка вызовов функций (chaining)? Как реализовать такой подход?**
    Цепочка вызовов функций позволяет вызывать несколько методов объекта последовательно. Реализуется возвратом `this` в методах объекта.
    ```javascript
    class Chain {
        method1() {
            console.log("method1");
            return this;
        }
        method2() {
            console.log("method2");
            return this;
        }
    }
    const chain = new Chain();
    chain.method1().method2();
    ```

40. **Что такое необъявленная переменная?**
    Необъявленная переменная - это переменная, к которой обращаются без использования ключевых слов `var`, `let` или `const`.

41. **Как передаются параметры в функцию: по ссылке или по значению?**
    Примитивные типы передаются по значению, объекты - по ссылке.

42. **Что такое прототип объекта в JavaScript?**
    Прототип объекта - это объект, от которого другой объект наследует свойства и методы.

43. **Как работает метод Object.create()?**
    Метод `Object.create(proto)` создает новый объект с указанным прототипом `proto`.

44. **Разниц между Object.freeze() и Object.seal()?**
    - `Object.freeze()` замораживает объект, делая его неизменяемым.
    - `Object.seal()` запечатывает объект, позволяя изменять существующие свойства, но не добавлять или удалять их.

45. **Разница между методами .slice() и .splice()?**
    - `.slice()`: возвращает новый массив, содержащий копию части исходного массива.
    - `.splice()`: изменяет исходный массив, удаляя или добавляя элементы.

46. **Как работают методы .find(), .findIndex() и .indexOf()?**
    - `.find()`: возвращает первый элемент, удовлетворяющий условию.
    - `.findIndex()`: возвращает индекс первого элемента, удовлетворяющего условию.
    - `.indexOf()`: возвращает индекс первого вхождения элемента в массиве.

47. **Плюсы и минусы использования use strict?**
    Плюсы:
    - Улучшение производительности.
    - Лучшая диагностика ошибок.
    - Защита от небезопасных действий.

    Минусы:
    - Могут возникнуть проблемы при интеграции с "нестрогим" кодом.

48. **Разница между методами .push(), .pop(), .shift() и .unshift()?**
    - `.push()`: добавляет элемент в конец массива.
    - `.pop()`: удаляет последний элемент массива.
    - `.shift()`: удаляет первый элемент массива.
    - `.unshift()`: добавляет элемент в начало массива.

49. **Плюсы и минусы иммутабельности? Как достичь иммутабельности в JS?**
    Плюсы:
    - Предсказуемость кода.
    - Упрощение отладки.
    - Меньше побочных эффектов.

    Минусы:
    - Возможны проблемы с производительностью.

    Иммутабельность можно достичь с помощью методов, которые возвращают новые объекты вместо изменения старых, и библиотек, таких как Immutable.js.

50. **Типы всплывающих окон в JavaScript?**
    - `alert()`
    - `confirm()`
    - `prompt()`

51. **Типы объектов JavaScript?**
    - `Object`
    - `Array`
    - `Function`
    - `Date`
    - `RegExp`
    - `Error`
    - и др.

52. **Парадигмы программирования в JavaScript?**
    - Императивное программирование.
    - Объектно-ориентированное программирование.
    - Функциональное программирование.

53. **Типы ошибок в JavaScript?**
    - `SyntaxError`
    - `ReferenceError`
    - `TypeError`
    - `RangeError`
    - `EvalError`
    - `URIError`

54. **Разница между typeof и instanceof?**
    - `typeof` возвращает строку, указывающую тип примитива или объекта.
    - `instanceof` проверяет, является ли объект экземпляром определенного конструктора.

55. **JavaScript статически, или динамически типизированный язык?**
    JavaScript - динамически типизированный язык.

56. **Что такое регулярное выражение (Regular Expression)?**
    Регулярное выражение - это шаблон для поиска и замены текста.

57. **Что такое рекурсия?**
    Рекурсия - это метод программирования, при котором функция вызывает саму себя.

58. **Что такое прототип (Prototype) объекта?**
    Прототип объекта - это объект, от которого другой объект наследует свойства и методы.

59. **Какие методы используются в регулярных выражениях?**
    - `test()`
    - `exec()`
    - методы строк: `match()`, `replace()`, `search()`, `split()`

60. **Что такое полифил (polyfill)?**
    Полифил - это код, который реализует функциональность, отсутствующую в старых версиях браузеров.

61. **Что такое switch/case? Правила использования switch/case?**
    `switch/case` - это оператор для сравнения одного выражения с несколькими значениями:
    ```javascript
    switch (expression) {
        case value1:
            // код
            break;
        case value2:
            // код
            break;
        default:
            // код
    }
    ```

62. **Типы функций по способности принимать другие функции?**
    - Функции первого порядка: не принимают и не возвращают другие функции.
    - Функции высшего порядка: принимают или возвращают другие функции.

63. **Что такое выражения (expression) и инструкции (statement) в JavaScript?**
    - Выражение (expression) - это фрагмент кода, который вычисляется и возвращает значение.
    - Инструкция (statement) - это команда, которая выполняет действие.

64. **Разница между .some() и .every()?**
    - `.some()`: возвращает `true`, если хотя бы один элемент массива удовлетворяет условию.
    - `.every()`: возвращает `true`, если все элементы массива удовлетворяют условию.

65. **Как сгенерировать случайное число в JavaScript?**
    С помощью `Math.random()`:
    ```javascript
    Math.random(); // случайное число от 0 до 1 (не включая 1)
    ```

66. **Типы операторов в JavaScript?**
    - Арифметические: `+`, `-`, `*`, `/`, `%`
    - Сравнения: `==`, `===`, `!=`, `!==`, `>`, `<`, `>=`, `<=`
    - Логические: `&&`, `||`, `!`
    - Присваивания: `=`, `+=`, `-=`, `*=`, `/=`
    - Побитовые: `&`, `|`, `^`, `~`, `<<`, `>>`, `>>>`
    - Специальные: `typeof`, `instanceof`, `new`, `delete`, `void`, `in`

67. **Разница между параметром и аргументом функции?**
    Параметры - это переменные, объявленные в определении функции. Аргументы - это значения, передаваемые функции при ее вызове.

68. **Правила задания имён для переменных и функций в JavaScript?**
    - Должны начинаться с буквы, знака доллара `$` или подчеркивания `_`.
    - Не могут начинаться с цифры.
    - Должны быть понятными и описательными.
    - Не должны быть зарезервированными словами.

69. **Разница между явным и неявным преобразованием (Implicit and Explicit Coercion)?**
    - Явное преобразование: программист явно указывает преобразование типа (`Number()`, `String()`, `Boolean()`).
    - Неявное преобразование: JavaScript автоматически преобразует типы в процессе выполнения.

70. **Для чего применяется метод Array

.from()?**
Метод `Array.from()` создает новый массив из массивоподобного или итерируемого объекта.

71. **Назовите способы преобразования массива в объект?**
    - Использование метода `reduce()`:
      ```javascript
      const array = [1, 2, 3];
      const obj = array.reduce((acc, cur, index) => ({ ...acc, [index]: cur }), {});
      ```
    - С помощью `Object.assign()` и оператора распространения:
      ```javascript
      const obj = Object.assign({}, array);
      ```
    - Использование метода `Object.fromEntries()`:
      ```javascript
      const obj = Object.fromEntries(array.map((value, index) => [index, value]));
      ```

72. **Разница между Object и Map?**
    - `Object` позволяет хранить ключи только строкового типа.
    - `Map` позволяет хранить ключи любого типа и сохраняет порядок добавления.

73. **Что такое каррирование?**
    Каррирование - это процесс преобразования функции с множеством аргументов в серию функций, каждая из которых принимает один аргумент.
    ```javascript
    function curry(f) {
        return function(a) {
            return function(b) {
                return f(a, b);
            };
        };
    }
    ```

74. **Для чего используются метод Object.seal()?**
    Метод `Object.seal()` запечатывает объект, предотвращая добавление новых и удаление существующих свойств, но позволяет изменять существующие свойства.

75. **Для чего используется свойство .dataset?**
    Свойство `.dataset` используется для работы с пользовательскими атрибутами данных (data-*) в элементах DOM.

76. **Каким образом можно обмениваться кодом между файлами?**
    - Экспорт и импорт модулей с помощью `export` и `import` (ES6).
    - Использование CommonJS модулей (`module.exports` и `require()`).

77. **Как работает «сборщик мусора» в JavaScript?**
    Сборщик мусора автоматически освобождает память, удаляя объекты, которые больше не доступны или не используются.

78. **Что такое утечки памяти?**
    Утечки памяти возникают, когда программа продолжает потреблять память, не освобождая ее после использования, что может привести к исчерпанию памяти.

79. **Назовите основные типы утечек памяти в JavaScript?**
    - Забытые таймеры и обратные вызовы.
    - Замыкания, удерживающие ссылки на переменные.
    - Ссылки на удаленные DOM-элементы.
    - Глобальные переменные.

80. **Как работает контекст выполнения (execution context) в JavaScript?**
    Контекст выполнения - это окружение, в котором выполняется JavaScript код, состоящий из:
    - Области видимости (Scope)
    - Стек вызовов (Call Stack)
    - Объект окружения (Environment Object)

81. **Разница между примитивом и объектом?**
    - Примитивы (числа, строки, булевые значения, `null`, `undefined`, `symbol`, `bigint`) хранятся непосредственно по значению.
    - Объекты хранятся по ссылке и могут содержать множество значений и методов.

82. **Что значит текст max call stack size exceeded в консоли?**
    Это ошибка, указывающая на переполнение стека вызовов, часто возникающая из-за бесконечной рекурсии.

83. **Как реализовать отложенную загрузку изображений?**
    Отложенная загрузка (lazy loading) изображений может быть реализована с использованием атрибута `loading="lazy"` или библиотеки, такой как `lazysizes`, или с использованием JavaScript:
    ```javascript
    document.addEventListener("DOMContentLoaded", function() {
        const lazyImages = document.querySelectorAll("img.lazy");
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    img.src = img.dataset.src;
                    img.classList.remove("lazy");
                    observer.unobserve(img);
                }
            });
        });
        lazyImages.forEach(img => observer.observe(img));
    });
    ```

84. **Чем отличаются события input и change?**
    - `input` срабатывает каждый раз при изменении значения элемента.
    - `change` срабатывает, когда изменение элемента завершено (например, после потери фокуса).

85. **Почему typeof null возвращает object?**
    Это баг в языке JavaScript, который сохранился для обратной совместимости. Исторически `null` интерпретировался как "нулевой объект".

86. **Зачем нужен конструктор Proxy?**
    `Proxy` позволяет создавать прокси для объекта, который может перехватывать и изменять основные операции (например, чтение/запись свойств, вызов функций).

87. **Что такое хвостовая рекурсия? Оптимизация рекурсии?**
    Хвостовая рекурсия - это рекурсия, при которой рекурсивный вызов является последней операцией функции. Оптимизация хвостовой рекурсии позволяет уменьшить использование памяти.

88. **Что такое и как работает debounce() и throttle() в JavaScript?**
    - `debounce()`: ограничивает частоту вызова функции, вызывая её только после определенного времени с последнего вызова.
    - `throttle()`: ограничивает количество вызовов функции, вызывая её не чаще определенного времени.
    ```javascript
    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }

    function throttle(func, limit) {
        let lastFunc;
        let lastRan;
        return function(...args) {
            if (!lastRan) {
                func.apply(this, args);
                lastRan = Date.now();
            } else {
                clearTimeout(lastFunc);
                lastFunc = setTimeout(() => {
                    if (Date.now() - lastRan >= limit) {
                        func.apply(this, args);
                        lastRan = Date.now();
                    }
                }, limit - (Date.now() - lastRan));
            }
        };
    }
    ```

89. **Как в JavaScript работают декораторы? Как они могут быть использованы для модификации поведения классов и методов?**
    Декораторы - это функции, которые принимают целевой объект, метод или свойство и могут изменять их поведение.
    ```javascript
    function readonly(target, key, descriptor) {
        descriptor.writable = false;
        return descriptor;
    }

    class Example {
        @readonly
        method() {
            return "This method is readonly";
        }
    }
    ```

# **ECMAScript**

1. **Что такое ECMAScript? В чём отличие от JavaScript?**
   ECMAScript (ES) — это стандарт, на основе которого разрабатываются JavaScript, JScript и ActionScript. Он определяет язык программирования, синтаксис, семантику и базовые объекты. JavaScript — это реализация ECMAScript, которая также включает в себя дополнительные возможности и встроенные API, специфичные для браузеров и среды выполнения. Таким образом, JavaScript следует спецификациям ECMAScript, но не ограничивается только ими.

2. **Разница между `let`, `const` и `var`?**
    - `var` имеет функции или глобальную область видимости и может быть переназначен. Переменные, объявленные с `var`, подвержены всплытию (hoisting), т.е. они доступны в коде до своей фактической декларации.
    - `let` имеет блочную область видимости и не подвержен всплытию. Переменная, объявленная с `let`, доступна только внутри блока, в котором она была объявлена.
    - `const` также имеет блочную область видимости и не подвержен всплытию. `const` используется для объявления константных переменных, т.е. переменных, значения которых не могут быть переназначены после инициализации.

3. **Можно ли изменить значение, определённое через `const`?**
   Значение, определённое через `const`, нельзя переназначить. Однако если `const` ссылается на объект (включая массивы и функции), содержимое объекта можно изменить, но ссылка на сам объект останется неизменной.

4. **Что такое временная мёртвая зона (temporal dead zone)?**
   Временная мёртвая зона — это период времени между началом блока кода, где объявлена переменная с `let` или `const`, и моментом, когда эта переменная инициализирована. В этот период доступ к переменной вызывает ошибку.

## 5. **Разница между Rest и Spread операторами?**
- **Spread оператор** (`...`) используется для разложения массива или объекта на отдельные элементы или свойства. Например, `[...arr]` или `{...obj}`.
- **Rest оператор** (`...`) используется для сбора всех оставшихся аргументов функции в массив или свойства объекта в объект. Например, `function(...args)` или `const {a, ...rest} = obj`.

## 6. **Что такое деструктуризация?**
Деструктуризация — это синтаксическая особенность, позволяющая извлекать значения из массивов или свойств из объектов и присваивать их переменным. Например, для массива: `const [a, b] = [1, 2]`, для объекта: `const {x, y} = {x: 1, y: 2}`.

7. **Для чего используется цикл `for…of`?**
   Цикл `for…of` используется для итерации по итерируемым объектам, таким как массивы, строки, карты, наборы и другие объекты, поддерживающие итерацию. Он позволяет получить значения элементов коллекции.

8. **Что такое шаблонные литералы (Template Literals)?**
   Шаблонные литералы — это строки, которые могут содержать выражения и многострочные тексты. Они создаются с помощью обратных кавычек (`` ` ``). Например: `` `Hello, ${name}` ``. Это позволяет легко вставлять переменные и выполнять выражения в строках.

## 9. **Что такое Set, Map, WeakMap и WeakSet?**
### 1. **Map** — коллекция пар "ключ-значение", где ключи могут быть любого типа. Порядок элементов в Map сохраняется.

**Методы и свойства:**

- **new Map()** – создаёт коллекцию.
- **Map.prototype.set(key, value)** – записывает по ключу key значение value.
- **Map.prototype.get(key)** – возвращает значение по ключу или undefined, если ключ key отсутствует.
- **Map.prototype.has(key)** – возвращает true, если ключ key присутствует в коллекции, иначе false.
- **Map.prototype.delete(key)** – удаляет элемент (пару «ключ/значение») по ключу key.
- **Map.prototype.clear()** – очищает коллекцию от всех элементов.
- **Map.prototype.size** – возвращает текущее количество элементов.

**Для перебора коллекции Map:**

- **Map.prototype.keys()** – возвращает итерируемый объект по ключам,
- **Map.prototype.values()** – возвращает итерируемый объект по значениям,
- **Map.prototype.entries()** – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.

### 2. **Set** — коллекция уникальных значений. Значения в Set могут быть любого типа и не повторяются.

**Его основные методы это:**

- **new Set(iterable)** – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
- **Set.prototype.add(value)** – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект Set.
- **Set.prototype.delete(value)** – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
- **Set.prototype.has(value)** – возвращает true, если значение присутствует в множестве, иначе false.
- **Set.prototype.clear()** – удаляет все имеющиеся значения.
- **Set.prototype.size** – возвращает количество элементов в множестве.

**Для перебора коллекции Set:**

- **Set.prototype.keys()** – возвращает перебираемый объект для значений,
- **Set.prototype.values()** – то же самое, что и set.keys(), присутствует для обратной совместимости с Map,
- **Set.prototype.entries()** – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.

### 3. **WeakMap** — аналог Map, но ключи должны быть объектами, и они не предотвращают сборку мусора. Это позволяет автоматически очищать неиспользуемые ключи.
### 4. **WeakSet** — аналог Set, но элементы могут быть только объектами, и они не предотвращают сборку мусора.

10. **Разница между обычными функциями и стрелочными?**
    - Обычные функции имеют собственное значение `this`, которое устанавливается в момент вызова функции. Также они имеют свою собственную область видимости для `arguments`.
    - Стрелочные функции не имеют собственного `this`; вместо этого они захватывают значение `this` из окружающего контекста. Они также не имеют `arguments`.

11. **Разница между методом `Object.freeze()` и `const`?**
    - `Object.freeze()` делает объект неизменным, т.е. нельзя изменять его свойства, добавлять новые или удалять существующие.
    - `const` позволяет создавать переменные, которые не могут быть переназначены. Однако если `const` ссылается на объект, то его содержимое может изменяться.

12. **Что такое итераторы?**
    Итераторы — это объекты, которые позволяют перебирать коллекции данных, такие как массивы, строки, карты и наборы. Итератор должен реализовывать метод `next()`, который возвращает объект с двумя свойствами: `value` (текущее значение) и `done` (флаг завершения итерации).

13. **Что такое генераторы? Когда стоит использовать генераторы?**
    Генераторы — это функции, которые могут быть приостановлены и возобновлены. Они объявляются с использованием `function*` и используют ключевое слово `yield` для возврата значений поэтапно. Генераторы удобны для работы с итерациями, асинхронным кодом и потоками данных.

14. **Что такое ES6 модули?**
    ES6 модули позволяют организовывать код в модули, которые могут экспортировать и импортировать функциональность. Модули поддерживаются нативно в JavaScript и позволяют использовать ключевые слова `import` и `export` для работы с модулями.

15. **Что такое символ (Symbol) в ES6?**
    Символы — это уникальные и неизменяемые примитивные типы данных, которые используются для создания уникальных идентификаторов для свойств объектов. Они создаются с помощью функции `Symbol()` и могут использоваться в качестве ключей для свойств объектов.

16. **Для чего используется метод `.includes()`?**
    Метод `.includes()` проверяет, содержит ли массив или строка указанный элемент. Для массива: `arr.includes(element)`, для строки: `str.includes(substring)`.

17. **Для чего используется метод `.getOwnPropertyDescriptors()`?**
    Метод `.getOwnPropertyDescriptors()` возвращает объект, содержащий дескрипторы свойств для всех собственных свойств объекта. Это позволяет получить подробную информацию о свойствах, включая их значение, доступность для чтения/записи и т.д.

18. **Расскажите о методах `.keys()`, `.values()`, `.entries()`?**
    - `.keys()` возвращает итератор, содержащий ключи коллекции (например, для объектов Map и Set).
    - `.values()` возвращает итератор, содержащий значения коллекции.
    - `.entries()` возвращает итератор, содержащий пары [ключ, значение] для коллекций типа Map и Set.

19. **Для чего используется метод `.fromEntries()`?**
    Метод `.fromEntries()` преобразует список пар ключ-значение в объект. Например, `Object.fromEntries([['a', 1], ['b', 2]])` вернёт `{a: 1, b: 2}`.

20. **Для чего используются методы `.flat()` и `.flatMap()`?**
    - `.flat()` используется для выравнивания вложенных массивов на заданную глубину.
    - `.flatMap()` сначала применяет функцию к каждому элементу массива, а затем выравнивает результат в один уровень.

21. **Для чего используются методы `.padStart()` и `.padEnd()`?**
    - `.padStart()` добавляет заданное количество символов в начало строки, чтобы достичь заданной длины.
    - `.padEnd()` добавляет символы в конец строки до достижения заданной длины.

22. **Для чего используются методы `.startsWith()` и `.endsWith()`?**
    - `.startsWith()` проверяет, начинается ли строка с указанного подстроки.
    - `.endsWith()` проверяет, заканчивается ли строка указанной подстрокой.

23. **Как в JavaScript удалять пробельные символы в начале и в конце строки?**
    Для удаления пробельных символов можно использовать метод `.trim()`. Например, `"  Hello  ".trim()` вернёт `"Hello"`.

24. **Расскажите об операторе Optional Chaining (?.)?**
    Оператор Optional Chaining (`?.`) позволяет безопасно обращаться к вложенным свойствам объекта, не вызывая ошибку, если одно из промежуточных свойств `null` или `undefined`. Например, `obj?.property?.subProperty`.

25. **Для чего используется метод `.replaceAll()`?**
    Метод `.replaceAll()` заменяет все вхождения подстроки или регулярного выражения на другую подстроку. Например, `"foo foo".replaceAll("foo", "bar")

` вернёт `"bar bar"`.

26. **Что такое оператор логического присваивания?**
    Оператор логического присваивания сочетает логическое действие с присваиванием. Например, `x &&= y` эквивалентен `x && (x = y)`.

27. **Как увеличить читаемость больших чисел?**
    Для увеличения читаемости больших чисел можно использовать разделители подчеркивания. Например, `1_000_000` представляет собой миллион.

28. **Что такое приватные аксессоры?**
    Приватные аксессоры (или приватные поля и методы) доступны только внутри класса, где они объявлены. Они обозначаются символом `#`. Например:
    ```javascript
    class MyClass {
      #privateField;
      constructor(value) {
        this.#privateField = value;
      }
    }
    ```

29. **Разница между ES6-классами и конструкторами функций?**
    - ES6-классы предоставляют более чистый и понятный синтаксис для создания объектов и работы с наследованием.
    - Конструкторы функций более старый подход, где объекты создаются с помощью функции-конструктора и прототипного наследования.

30. **Что такое оператор нулевого слияния (??)?**
    Оператор нулевого слияния (`??`) возвращает правый операнд, если левый операнд равен `null` или `undefined`. В противном случае возвращает левый операнд.

31. **В чём отличие оператора нулевого слияния (??) и оператора “ИЛИ” (||)?**
    Оператор `??` возвращает правый операнд только если левый операнд равен `null` или `undefined`, в то время как `||` возвращает правый операнд, если левый операнд является falsy значением (например, `0`, `''`, `NaN`).

32. **Назовите основные методы и свойства работы с коллекцией Map?**
    - `.set(key, value)` — добавляет/обновляет элемент.
    - `.get(key)` — возвращает значение по ключу.
    - `.has(key)` — проверяет наличие ключа.
    - `.delete(key)` — удаляет элемент.
    - `.clear()` — очищает все элементы.
    - `.keys()`, `.values()`, `.entries()` — возвращают итераторы по ключам, значениям и парам [ключ, значение] соответственно.

33. **Назовите основные методы и свойства работы с коллекцией Set?**
    - `.add(value)` — добавляет элемент.
    - `.has(value)` — проверяет наличие элемента.
    - `.delete(value)` — удаляет элемент.
    - `.clear()` — очищает все элементы.
    - `.keys()`, `.values()`, `.entries()` — возвращают итераторы по ключам (которые совпадают с значениями), значениям и парам [значение, значение] соответственно.

34. **Как осуществить перебор элементов в коллекциях Map и Set?**
    - Для `Map`: `for (let [key, value] of map)` или `map.forEach((value, key) => { /* code */ })`.
    - Для `Set`: `for (let value of set)` или `set.forEach(value => { /* code */ })`.

35. **Как работают дефолтные параметры в ES6?**
    Дефолтные параметры позволяют задавать значения по умолчанию для параметров функции. Если аргумент функции не передан или равен `undefined`, используется значение по умолчанию. Например:
    ```javascript
    function greet(name = "Guest") {
      return `Hello, ${name}!`;
    }
    ```

36. **Что такое BigInt в ES2020 и для чего он используется?**
    BigInt — это примитивный тип данных для работы с целыми числами произвольной длины. Он используется, когда числа превышают пределы стандартного числового типа `Number`. Создается с помощью функции `BigInt()`, например, `BigInt(123456789012345678901234567890)`.

37. **Какие нововведения были представлены в ECMAScript 2021 (ES12)?**
    В ECMAScript 2021 были добавлены следующие нововведения:
    - Оператор `&&=`, `||=`, `??=` для логического присваивания.
    - Метод `String.prototype.replaceAll()` для замены всех вхождений.
    - Метод `WeakRef` для создания слабых ссылок.
    - Приватные поля и методы класса, доступные только внутри класса.
    - Улучшения в `Promise`, такие как `Promise.any()`.
    - Изменения в методах работы с объектами, такие как `Object.hasOwn()`.

# **Async JavaScript**

1. **Разница между синхронными и асинхронными функциями?**
   Синхронные функции выполняются последовательно: одна за другой. Это означает, что следующая строка кода не будет выполнена, пока текущая функция не завершится. Асинхронные функции позволяют выполнять код параллельно, не блокируя выполнение последующих строк кода. Они могут завершаться позже, чем последующие операции.

2. **Что такое AJAX?**
   AJAX (Asynchronous JavaScript and XML) - это набор технологий, который позволяет загружать данные с сервера асинхронно без перезагрузки страницы. AJAX использует объект XMLHttpRequest или fetch для отправки и получения данных в различных форматах, включая JSON и XML.

3. **Что такое same-origin policy в контексте JavaScript?**
   Same-origin policy (политика того же источника) - это механизм безопасности, который ограничивает взаимодействие скриптов, загруженных с одного источника, с ресурсами, загруженными с другого источника. Это предотвращает атаки, такие как межсайтовый скриптинг (XSS).

4. **Что такое цикл событий (event loop) и как он работает?**
   Цикл событий (event loop) - это механизм, который позволяет JavaScript выполнять асинхронные операции, такие как обработка событий, сетевые запросы и таймеры. Он постоянно проверяет очередь задач (task queue) и выполнение задач по мере их поступления, обеспечивая непрерывную работу программы.

5. **Разница между микро и макрозадачами в event loop?**
   Микрозадачи (microtasks) имеют более высокий приоритет и выполняются до следующего кадра отрисовки. Примеры: `Promise.then()`, `process.nextTick()`. Макрозадачи (macrotasks) включают в себя таймеры, события и сетевые запросы. Примеры: `setTimeout()`, `setInterval()`, события DOM.

6. **Расскажите о queueMicrotask?**
   `queueMicrotask` - это метод, который позволяет добавлять микрозадачи в очередь микрозадач, которые будут выполнены после текущего синхронного кода и перед любыми макрозадачами.

7. **Что такое промисы (Promises)?**
   Promise - это объект, представляющий результат асинхронной операции. Он может находиться в одном из трёх состояний: ожидает (pending), выполнен (fulfilled), отклонён (rejected). Промисы позволяют удобнее работать с асинхронным кодом, избегая вложенных колбэков.

8. **Плюсы и минусы использования Ajax?**
   Плюсы:
- Обновление данных без перезагрузки страницы.
- Улучшение пользовательского опыта.
- Повышение производительности за счет уменьшения объема передаваемых данных.

Минусы:
- Сложности с обработкой ошибок.
- Проблемы с кешированием и безопасностью.
- Ограничения same-origin policy.

9. **Подходы при работе с асинхронным кодом?**
- Колбэки (Callbacks)
- Промисы (Promises)
- async/await

10. **Преимущества использования промисов вместо колбэков?**
- Упрощение обработки ошибок.
- Избежание вложенности колбэков (Callback Hell).
- Четкий и понятный код, работающий с асинхронными операциями.

11. **Что такое callback-функция? Что такое Callback Hell?**
    Callback-функция - это функция, которая передается в другую функцию в качестве аргумента и вызывается позже. Callback Hell - это проблема вложенных колбэков, приводящая к трудно читаемому и поддерживаемому коду.

12. **Проблемы при использовании callback-функций?**
- Callback Hell.
- Трудности с обработкой ошибок.
- Сложность в отладке и поддержке кода.

13. **Что такое async/await?**
    `async/await` - это синтаксический сахар для работы с промисами, который позволяет писать асинхронный код так, как если бы он был синхронным. `async` помечает функцию как асинхронную, `await` заставляет ждать выполнения промиса.

14. **Разница между Promise.all(), Promise.any() и Promise.race()?**
- `Promise.all()`: Выполняется, когда все промисы завершены. Если один из промисов отклонен, возвращает ошибку.
- `Promise.any()`: Выполняется, когда хотя бы один из промисов выполнен. Если все промисы отклонены, возвращает ошибку.
- `Promise.race()`: Выполняется, когда первый из промисов завершен (выполнен или отклонен).

15. **Расскажите про статический метод .allSettled()?**
    `Promise.allSettled()` возвращает промис, который выполняется, когда все переданные промисы завершены (выполнены или отклонены). Результат содержит массив объектов с состоянием и значением/причиной каждого промиса.

16. **Плюсы и минусы асинхронного программирования в JavaScript?**
    Плюсы:
- Улучшение производительности.
- Уменьшение времени ожидания пользователя.
- Эффективное использование ресурсов.

Минусы:
- Сложности с отладкой.
- Потенциальные проблемы с гонками данных.
- Необходимость обработки ошибок.

17. **Как выполнить несколько асинхронных операций последовательно?**
    Использование async/await:
```javascript
async function sequentialExecution() {
  await asyncOperation1();
  await asyncOperation2();
  await asyncOperation3();
}
```

18. **Какие проблемы может вызвать неправильное использование асинхронности в JavaScript?**
- Гонки данных (race conditions).
- Зависания и блокировки.
- Утечки памяти.
- Трудности с отладкой и тестированием.

19. **Что такое fetch()? Как работает функция fetch()?**
    `fetch()` - это современный метод для выполнения HTTP-запросов. Он возвращает промис, который разрешается с объектом Response. Пример:
```javascript
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
```

20. **Что такое JSON в JavaScript? Как его можно использовать?**
    JSON (JavaScript Object Notation) - это формат для обмена данными, основанный на JavaScript-объектах. Он используется для передачи данных между сервером и клиентом. В JavaScript его можно парсить и сериализовать с помощью `JSON.parse()` и `JSON.stringify()`.

21. **Что такое и как работает коэффициент сжатия (compression ratio) в контексте веб-разработки?**
    Коэффициент сжатия - это отношение размера несжатого файла к размеру сжатого файла. В веб-разработке он используется для уменьшения объема передаваемых данных, что ускоряет загрузку страниц и уменьшает нагрузку на серверы.

# **JavaScript in Browser**

1. **Что такое DOM?**
   DOM (Document Object Model) — это программный интерфейс для веб-документов. Он представляет структуру документа в виде дерева узлов, где каждый узел соответствует части документа, такой как элемент, текст или атрибут. DOM позволяет программам и скриптам динамически изменять содержимое, структуру и стиль веб-страницы.

2. **Типы узлов DOM-дерева?**
   Основные типы узлов DOM-дерева:
    - `Element`: узлы элементов, такие как `<div>`, `<p>`, `<a>`.
    - `Attribute`: узлы атрибутов, связанные с элементами.
    - `Text`: текстовые узлы, содержащие текст внутри элементов.
    - `Comment`: узлы комментариев.
    - `Document`: корневой узел документа.
    - `DocumentFragment`: фрагмент документа, который можно использовать для временного хранения элементов.

3. **Методы поиска элементов в DOM?**
    - `document.getElementById(id)`: находит элемент по идентификатору.
    - `document.getElementsByClassName(className)`: находит элементы по имени класса.
    - `document.getElementsByTagName(tagName)`: находит элементы по имени тега.
    - `document.querySelector(selector)`: находит первый элемент, соответствующий CSS-селектору.
    - `document.querySelectorAll(selector)`: находит все элементы, соответствующие CSS-селектору.

4. **Свойства для перемещения по DOM-дереву?**
    - `parentNode`: родительский узел.
    - `childNodes`: список дочерних узлов.
    - `firstChild`: первый дочерний узел.
    - `lastChild`: последний дочерний узел.
    - `nextSibling`: следующий соседний узел.
    - `previousSibling`: предыдущий соседний узел.

5. **Разница между attribute и property у DOM-элементов?**
    - **Attribute**: относится к HTML-атрибутам, как они указаны в исходном коде. Например, `<input type="text" />` имеет атрибут `type`.
    - **Property**: относится к свойствам объекта в DOM. Например, `element.type` указывает на текущее значение свойства `type`, которое может отличаться от значения атрибута.

6. **Что такое BOM?**
   BOM (Browser Object Model) представляет объекты, предоставляемые браузером, которые позволяют взаимодействовать с браузерным окружением. Например, `window`, `navigator`, `location`, `history` и `screen` — это объекты BOM.

7. **Виды событий в JavaScript?**
    - **Мышь**: `click`, `dblclick`, `mousedown`, `mouseup`, `mousemove`, `mouseover`, `mouseout`, `mouseenter`, `mouseleave`.
    - **Клавиатура**: `keydown`, `keyup`, `keypress`.
    - **Форма**: `submit`, `change`, `focus`, `blur`, `input`.
    - **Документ и окно**: `load`, `unload`, `resize`, `scroll`, `DOMContentLoaded`.
    - **Сетевые события**: `error`, `progress`, `loadend`.

8. **Как добавить обработчик события на DOM-элемент?**
   ```javascript
   element.addEventListener('event', function() {
     // обработчик события
   });
   ```
   Например:
   ```javascript
   document.getElementById('myButton').addEventListener('click', function() {
     alert('Button clicked!');
   });
   ```

9. **Как удалить обработчик события с DOM-элемента?**
   ```javascript
   element.removeEventListener('event', handler);
   ```
   Пример:
   ```javascript
   function handleClick() {
     alert('Button clicked!');
   }

   const button = document.getElementById('myButton');
   button.addEventListener('click', handleClick);
   // Удаление обработчика
   button.removeEventListener('click', handleClick);
   ```

10. **Что такое распространение события (Event Propagation)?**
    Распространение события — это процесс, при котором событие сначала происходит на самом целевом элементе (всплытие события), затем оно перемещается вверх по дереву элементов (сначала к родителю, затем к родителю его родителя и так далее).

11. **Что такое делегирование событий (Event Delegation)?**
    Делегирование событий — это техника, при которой обработчик события назначается на родительский элемент, а не на каждый дочерний элемент. Это позволяет обрабатывать события на дочерних элементах, которые могут быть добавлены динамически.

12. **Как использовать media выражения в JavaScript?**
    Media выражения обычно используются в CSS, но также могут быть использованы в JavaScript через `window.matchMedia()`. Пример:
    ```javascript
    const mediaQuery = window.matchMedia('(max-width: 600px)');
    if (mediaQuery.matches) {
      console.log('Экран меньше 600px');
    } else {
      console.log('Экран больше 600px');
    }
    ```

13. **Расскажите про координаты в браузере?**
    Координаты в браузере можно получить с помощью `getBoundingClientRect()`, который возвращает размер элемента и его позицию относительно видимой области экрана. Пример:
    ```javascript
    const rect = element.getBoundingClientRect();
    console.log(rect.top, rect.left, rect.width, rect.height);
    ```

14. **Разница между HTMLCollection и NodeList?**
    - **HTMLCollection**: коллекция элементов, которые обновляются автоматически при изменении DOM. Обычно возвращается методами типа `getElementsByClassName` или `getElementsByTagName`.
    - **NodeList**: коллекция узлов, не обязательно элементов. Возвращается методами типа `querySelectorAll`. NodeList может быть как живым (обновляющимся), так и статичным (необновляющимся).

15. **Как динамически добавить элемент на HTML-страницу?**
    ```javascript
    const newElement = document.createElement('div');
    newElement.textContent = 'Привет, мир!';
    document.body.appendChild(newElement);
    ```

16. **Разница между feature detection, feature inference и анализом строки user-agent?**
    - **Feature Detection**: проверка поддержки функциональности браузером. Например, проверка наличия метода `fetch`.
    - **Feature Inference**: использование существующих методов или свойств для определения поддержки функции.
    - **Анализ строки user-agent**: использование строки user-agent для определения типа и версии браузера. Этот метод менее надежен, чем feature detection.

17. **Разница между e.preventDefault() и e.stopPropagation()?**
    - **e.preventDefault()**: отменяет действие по умолчанию, связанное с событием (например, отправка формы).
    - **e.stopPropagation()**: останавливает распространение события вверх по дереву DOM (не вызывает обработчики на родительских элементах).

18. **Разница между event.target и event.currentTarget?**
    - **event.target**: элемент, на котором произошло событие.
    - **event.currentTarget**: элемент, на который назначен обработчик события (может отличаться, если используется делегирование событий).

19. **Разница между .stopPropagation() и .stopImmediatePropagation()?**
    - **.stopPropagation()**: останавливает дальнейшее распространение события по дереву DOM.
    - **.stopImmediatePropagation()**: останавливает дальнейшее распространение события и предотвращает выполнение других обработчиков на том же элементе.

20. **Разница между событиями load и DOMContentLoaded?**
    - **load**: срабатывает, когда полностью загружен весь документ, включая все стили, изображения и другие ресурсы.
    - **DOMContentLoaded**: срабатывает, когда весь HTML документ был полностью загружен и разобран, но до загрузки стилей, изображений и других ресурсов.

21. **Сколько аргументов принимает addEventListener?**
    Метод `addEventListener` принимает три аргумента:
    1. Тип события (строка).
    2. Обработчик события (функция).
    3. Опции (необязательный объект или логическое значение, указывающее, должно ли событие быть захваченным или всплывающим).

22. **Разница между innerHTML и outerHTML?**
    - **innerHTML**: возвращает или устанавливает HTML-контент внутри элемента.
    - **outerHTML**: возвращает или устанавливает HTML-контент элемента, включая сам элемент.

23. **Разница между JSON и XML?**
    - **JSON** (JavaScript Object Notation): легковесный формат данных, используемый для обмена данными, легко читается человеком и машиной.
    - **XML** (eXtensible Markup Language): более сложный формат для хранения и передачи данных, использующий разметку для определения структуры.

24. **Как узнать об использовании метода event.preventDefault()?**
    Чтобы определить, вызван ли метод `preventDefault`, можно проверить свойство `defaultPrevented` объекта события:
    ```javascript
    handleEvent(e) {
      if (e.defaultPrevented) {
        console.log('preventDefault был вызван');
      }
    }
    ```

25. **Для чего используется свойство window.navigator?**
    Свойство `window.navigator` предоставляет информацию о браузере и операционной системе пользователя, включая имя браузера, версию, язык и платформу.

26. **Для чего используется метод .focus()?**
    Метод `.focus()` используется для установки фокуса на элементе формы или вводе текста, чтобы пользователь мог начать взаимодействие с ним сразу.

27. **Для чего используется свойство .forms?**
    Свойство `.forms` объекта `document` возвращает коллекцию всех форм в документе.

28. **Для чего используется метод .scrollIntoView()?**
    Метод `.scrollIntoView()` прокручивает элемент так, чтобы он оказался видимым в области просмотра. Это может быть полезно для приведения элемента в фокус.

29. **Разница между методами .submit() и .requestSubmit()?**
    - **.submit()**: отправляет форму, обходя валидацию HTML5 и обработчики события `submit`.
    - **.requestSubmit()**: отправляет форму, включая валидацию HTML5 и вызов обработчиков события `submit`.

30. **Расскажите о IntersectionObserver?**
    `IntersectionObserver` позволяет асинхронно наблюдать за пересечением элемента с областью видимости. Это полезно для реализации ленивой загрузки изображений или триггеров для анимаций.

    Пример:
    ```javascript
    let observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          console.log('Элемент видим!');
        }
      });
    });

    observer.observe(document.querySelector('#myElement'));
    ```

31. **Расскажите о URLSearchParams?**
    `URLSearchParams` предоставляет интерфейс для работы с параметрами строки запроса URL. Он позволяет легко читать, изменять и добавлять параметры.

    Пример:
    ```javascript
    let params = new URLSearchParams('?name=John&age=30');
    console.log(params.get('name')); // John
    console.log(params.has('age'));  // true
    params.append('city', 'New York');
    console.log(params.toString()); // name=John&age=30&city=New+York
    ```

32. **Какие есть ограничения у window.close()?**
    Метод `window.close()` может быть вызван только для окон, которые были открыты с помощью `window.open()`. Попытка закрыть окно, которое не было открыто скриптом, может быть заблокирована браузером.

33. **Как можно создавать пользовательское событие (custom events) в JavaScript?**
    Создание пользовательского события с помощью `CustomEvent`:
    ```javascript
    let event = new CustomEvent('myEvent', { detail: { key: 'value' } });
    element.dispatchEvent(event);
    ```

34. **Что такое IndexedDB? Как работает IndexedDB?**
    IndexedDB — это низкоуровневая база данных, которая позволяет хранить значительные объемы структурированных данных в браузере. Она работает асинхронно и использует ключ-значение для хранения данных. IndexedDB поддерживает транзакции и индексы для улучшения производительности запросов.

35. **Расскажите о методе requestAnimationFrame()?**
    `requestAnimationFrame()` позволяет запланировать выполнение функции перед следующим перерисовыванием экрана. Это эффективный способ для реализации анимаций, так как браузер оптимизирует их выполнение, чтобы избежать лишних перерисовок.

    Пример:
    ```javascript
    function animate() {
      // обновить состояние анимации
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
    ```
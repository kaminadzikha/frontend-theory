# **JavaScript**

## 1. **Что такое ECMAScript? В чём отличие от JavaScript?**
`ECMAScript` — это спецификация, стандарт скриптовых языков программирования, он является основой JS, поэтому любые изменения ECMAScript отражаются на JS.

`ECMAScript сам по себе - это не язык программирования`. `А вот JavaScript - это язык программирования`, реализующий стандарт ECMAScript.

## 2. **Типы данных в JavaScript?**
   В JavaScript есть следующие типы данных:
   `number`, `string`, `boolean`, `null`, `undefined`, `symbol`, `bigint`, `object`

## 3. **Что такое Symbol?**
**`Символ (Symbol)`** — примитивный тип, значения которого создаются с помощью вызова функции Symbol. Каждый созданный символ уникален.

Символы могут использоваться в качестве имён свойств в объектах. Символьные свойства могут быть прочитаны только при прямом обращении и не видны при обычных операциях.

Для создания символа нужно вызвать функцию Symbol:

```JavaScript
const sym = Symbol()
const symTwo = Symbol()

console.log(sym === symTwo)
// false
```

Символы используются для создания скрытых свойств объектов. В отличие от свойств, ключом которых является строка, символьные свойства может читать только владелец символа. Скрытые свойства не видны при его обходе с помощью for...in.

Это может пригодиться, когда необходимо добавить свойства объекту, который могут модифицировать другие части программы. Таким образом только вы сможете читать созданное свойство, а гарантия уникальности символов гарантирует и отсутствие конфликтов имён.

Символы активно используются внутри самого JavaScript, чтобы определять поведение объектов. Такие символы называются «хорошо известными» (well-known symbols).

Самый известный символ Symbol.iterator, который позволяет реализовать обход конструкции с помощью синтаксических конструкций for..of и спред-синтаксиса.

Полный список таких символов доступен в спецификации, но на практике он нужен нечасто.

## 4. **Что такое BigInt?**
`BigInt` — это примитивный тип данных для работы с целыми числами произвольной длины. Он используется, когда числа
превышают пределы стандартного числового типа `Number`. Создается с помощью функции `BigInt()`,
например, `BigInt(123456789012345678901234567890)`.

## 5. **Разница между let, const и var?**

### `var`
- поднимается в начало области видимости функции при компиляции (имеет область видимости функции)
- объявляет переменную, которая может быть перезаписана
- объявляет переменную, которая может быть переопределена

### `let`
- не поднимается в начало области видимости блока при компиляции (имеет блочную область видимости)
- объявляет переменную, которая может быть перезаписана
- объявляет переменную, которая не может быть переопределена

### `const`
- не поднимается в начало области видимости блока при компиляции (имеет блочную область видимости)
- объявляет переменную, которая не может быть перезаписана или переопределена

## 6. **Что такое временная мёртвая зона (temporal dead zone)?**
`Временная мёртвая зона` — это период времени между началом области видимости, где объявлена переменная с `let` или `const`, и
моментом, когда эта переменная инициализирована. В этот период доступ к переменной вызывает ошибку.

## 7. **Разница между Rest и Spread операторами?**

- **Spread оператор** (`...`) используется для разложения массива или объекта на отдельные элементы или свойства.
  Например, `[...arr]` или `{...obj}`.
- **Rest оператор** (`...`) используется для сбора всех оставшихся аргументов функции в массив или свойства объекта в
  объект. Например, `function(...args)` или `const {a, ...rest} = obj`.

## 8. **Что такое деструктуризация?**

Деструктуризация — это синтаксическая особенность, позволяющая извлекать значения из массивов или свойств из объектов и
присваивать их переменным. Например, для массива: `const [a, b] = [1, 2]`, для объекта: `const {x, y} = {x: 1, y: 2}`.

## 9. **Разница между == и === (нестрогое/строгое равенство)?**
`==` (нестрогое равенство) проверяет равенство значений с приведением типов. `===` (строгое равенство) проверяет равенство значений без приведения типов.

## 10. **Что такое Strict mode в JavaScript?**
`Strict mode ("строгий режим")` вводит в код дополнительные проверки и ограничения для улучшения качества и безопасности кода. Включается директивой `"use strict";`.

## 11. **Разница между function declaration и function expression?**
- `Function declaration` (объявление функции): `function foo() { }` - имеет имя и доступна везде в текущей области видимости благодаря "поднятию".
- `Function expression` (функциональное выражение): `const foo = function() { }` - может быть анонимным или именованным, но доступно только после его объявления.

## 12. **Разница между обычными функциями и стрелочными? Что произойдет, если использовать стрелочную функцию как конструктор?**

`Обычные функции` имеют собственное значение `this`, которое устанавливается в момент вызова функции. Также они
  имеют свою собственную область видимости для `arguments`.

`Стрелочные функции` не имеют собственного `this`; вместо этого они захватывают значение `this` из окружающего
контекста. Они также не имеют `arguments`.

`Если попытаться использовать стрелочную функцию как конструктор в JavaScript`, произойдет ошибка. Стрелочные функции не могут быть использованы в качестве конструкторов, так как они не имеют собственного контекста `this`, и не поддерживают метод `new`. 

При вызове стрелочной функции с использованием оператора `new`, вы получите следующую ошибку:

```
TypeError: arrowFunction is not a constructor
```

Пример:

```javascript
const ArrowFunction = () => {};
const instance = new ArrowFunction(); // TypeError: ArrowFunction is not a constructor
```

Вместо стрелочной функции, для создания конструкторов следует использовать обычные функции.

Стрелочные функции и обычные функции в JavaScript имеют разные особенности, особенно когда дело касается использования в классах и объектах:

### `Обычные функции`

1. **Контекст вызова (`this`)**:
   - В обычных функциях контекст (`this`) определяется в момент вызова функции. Это значит, что при вызове функции в контексте объекта, `this` будет ссылаться на этот объект.
   - Если обычная функция вызывается в глобальной области видимости (или как метод объекта, который не определён), `this` будет `undefined` в строгом режиме или глобальным объектом (например, `window` в браузере) в нестрогом.

2. **Пример**:
   ```javascript
   class MyClass {
       constructor(value) {
           this.value = value;
       }

       regularFunction() {
           console.log(this.value); // this ссылается на экземпляр MyClass
       }
   }

   const obj = new MyClass(42);
   obj.regularFunction(); // 42
   ```

### `Стрелочные функции`

**`Контекст вызова (this)`**:
   - Стрелочные функции не имеют собственного контекста. Вместо этого они захватывают `this` из внешнего контекста, в котором были определены. Это особенно полезно в коллбэках, когда нужно сохранить контекст родительского объекта.

Пример:
```javascript
class MyClass {
    constructor(value) {
        this.value = value;
    }

    arrowFunction = () => {
        console.log(this.value); // this ссылается на экземпляр MyClass
    }
}

const obj = new MyClass(42);
obj.arrowFunction(); // 42
```

### `Использование в объектах`

1. **`Обычные методы`**:
- Обычные функции в объектах также ведут себя как методы, и контекст вызова будет определяться по тому, как метод был вызван.
```javascript
const obj = {
    value: 42,
    regularMethod: function() {
        console.log(this.value); // this ссылается на obj
    }
};

obj.regularMethod(); // 42
```

2. **`Стрелочные методы`**:
- Стрелочные функции не могут быть использованы как методы объекта, если вы хотите, чтобы `this` ссылался на сам объект, так как `this` будет определяться по контексту, в котором функция была определена.
```javascript
const obj = {
    value: 42,
    arrowMethod: () => {
        console.log(this.value); // this не ссылается на obj
    }
};

obj.arrowMethod(); // undefined (или будет ссылаться на глобальный объект)
```

### Резюме

- **Обычные функции**: имеют свой собственный контекст `this`, который определяется во время вызова. Подходят для методов объектов и классов.
- **Стрелочные функции**: не имеют своего контекста `this`, и захватывают его из внешней области видимости. Идеально подходят для использования в коллбэках или в местах, где нужно сохранить контекст.

## 13. **Что такое генераторы? Когда стоит использовать генераторы?**
`Генераторы` — это функции, которые могут быть приостановлены и возобновлены. Они объявляются с
использованием `function*` и используют ключевое слово `yield` для возврата значений поэтапно. Генераторы удобны для
работы с итерациями, асинхронным кодом и потоками данных.

## 14. **Разница между null и undefined?**
`undefined` представляет собой значение по умолчанию:
- переменной, которой не было присвоено значение;
- функции, которая ничего не возвращает явно, например, console.log(1);
- несуществующего свойства объекта.

`null` — это значение, которое присваивается переменной явно.

При сравнении null и undefined мы получаем true, когда используем оператор ==, и false при использовании оператора ===.

## 15. **Типы таймеров в JavaScript?**
- `setTimeout`: выполняет функцию через определённое время.
- `setInterval`: выполняет функцию с заданным интервалом.
- `requestAnimationFrame`: выполняет функцию перед следующим перерисовкой экрана.

## 16. **Что такое поднятие (Hoisting)?**
`Поднятие` - это механизм JavaScript, при котором объявления переменных и функций "поднимаются" в верхнюю часть их
области видимости во время компиляции.

**Контекст выполнения** — это среда, в которой выполняется код. Контекст выполнения имеет две фазы — компиляция и выполнение.

**_Компиляция._** В этой фазе функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости - как бы перемещаются в начало нашего кода. Это объясняет, почему мы можем вызывать функции до их объявления

**_Выполнение._** В этой фазе переменным присваиваются значения, а функции вызываются и выполняются.

## 17. **Что такое область видимости (Scope)?**

### **Область видимости** — это область, ограничивающая доступ к переменным и функциям внутри себя, как бы инкапсулирующая их.

**JS имеет три типа областей видимости: глобальная, функциональная и блочная (ES6).**

**Глобальная** — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и
доступны из любого места в коде.

**Функциональная** — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции.

**Блочная** — переменные, объявленные с помощью ключевых слов let и const, доступны только внутри блока {}, в котором
были
объявлены.

**Область видимости** — это также набор правил, по которым осуществляется поиск переменной. Если переменной не
существует в
текущей области видимости, ее поиск производится выше, во внешней по отношению к текущей области видимости. Если и во
внешней области видимости переменная отсутствует, ее поиск продолжается вплоть до глобальной области видимости. Если в
глобальной области видимости переменная обнаружена, поиск прекращается, если нет — выбрасывается исключение. Поиск
осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной. Это называется
цепочкой областей видимости (Scope Chain).

## 18. **Что такое замыкание (Closure)?**

### 1. **`Замыкание`** — это способность функции во время создания запоминать ссылки на переменные и параметры, находящиеся в текущей области видимости. Обычно область видимости определяется при создании функции.

2. **`Замыкание`** - это комбинация функции и лексического окружения, в котором она была определена. Это позволяет ей
  обращаться к переменным и функциям этого лексического окружения в дальнейшем.

## 19. **Что обозначает this в JavaScript? В чем отличие this в объекте и в экземпляре класса?**

`this` ссылается на контекст выполнения функции. В глобальной области видимости `this` ссылается на глобальный
объект (`window` в браузере).

`this` в JavaScript имеет разные значения в зависимости от контекста, в котором он используется. Давайте рассмотрим отличие `this` в объекте и в экземпляре класса:

### 1. **`this в объекте`**
Когда `this` используется внутри метода объекта, он ссылается на сам объект, который вызвал этот метод. Например:

```javascript
const person = {
  name: 'Anton',
  greet() {
    console.log(`Hello, my name is ${this.name}`);
  }
};

person.greet(); // Вывод: Hello, my name is Anton
```

В данном случае `this` ссылается на объект `person`.

### 2. **`this в экземпляре класса`**
Когда `this` используется в классе, он ссылается на экземпляр этого класса. Например:

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
  
  greet() {
    console.log(`Hello, my name is ${this.name}`);
  }
}

const anton = new Person('Anton');
anton.greet(); // Вывод: Hello, my name is Anton
```

В этом случае `this` ссылается на экземпляр `anton` класса `Person`.

## 20. **Что такое функции высшего порядка (Higher Order Functions)?**
    Функции высшего порядка - это функции, которые принимают другие функции в качестве аргументов или возвращают их.

## 21. **Как превратить любой тип данных в булевый? Перечислите ложные значения в JS?**

  Преобразование в булевый тип можно сделать через функцию `Boolean()` или оператор `!!`. Ложные
  значения: `false`, `0`, `-0`, `0n`, `""` (пустая строка), `null`, `undefined`, `NaN`.

## 22. **Что такое шаблонные литералы (Template Literals)?**
`Шаблонные литералы` — это строки, которые могут содержать выражения и многострочные тексты. Они создаются с помощью
обратных кавычек (`` ` ``). Например: `` `Hello, ${name}` ``. Это позволяет легко вставлять переменные и выполнять
выражения в строках.

## 23. **Что такое итераторы?**
`Итераторы` — это объекты, которые позволяют перебирать коллекции данных, такие как массивы, строки, Set, Map.
Итератор должен реализовывать метод `next()`, который возвращает объект с двумя свойствами: `value` (текущее
значение) и `done` (флаг завершения итерации).

## 24. **Методы строк в JavaScript?**

- **`length`** – возвращает длину строки.
   ```js
   const str = "Hello, World!";
   console.log(str.length); // 13
   ```

- **`toUpperCase()`** – преобразует все символы строки в верхний регистр.
   ```js
   const str = "hello";
   console.log(str.toUpperCase()); // "HELLO"
   ```

- **`toLowerCase()`** – преобразует все символы строки в нижний регистр.
   ```js
   const str = "HELLO";
   console.log(str.toLowerCase()); // "hello"
   ```

- **`charAt(index)`** – возвращает символ строки по указанному индексу.
   ```js
   const str = "JavaScript";
   console.log(str.charAt(0)); // "J"
   ```

- **`includes(substring)`** – проверяет, содержит ли строка подстроку.
   ```js
   const str = "Hello, World!";
   console.log(str.includes("World")); // true
   ```

- **`indexOf(substring)`** – возвращает индекс первого вхождения подстроки, или -1, если подстрока не найдена.
   ```js
   const str = "Hello, World!";
   console.log(str.indexOf("World")); // 7
   ```

- **`slice(start, end)`** – извлекает часть строки с указанного индекса до конца или до заданного индекса.
   ```js
   const str = "Hello, World!";
   console.log(str.slice(7, 12)); // "World"
   ```

- **`substring(start, end)`** – аналогичен методу `slice()`, но не поддерживает отрицательные индексы.
   ```js
   const str = "JavaScript";
   console.log(str.substring(4, 10)); // "Script"
   ```

- **`replace(searchValue, newValue)`** – заменяет первую найденную подстроку на новую строку.
   ```js
   const str = "Hello, World!";
   console.log(str.replace("World", "JavaScript")); // "Hello, JavaScript!"
   ```

- **`split(separator)`** – разбивает строку на массив строк по указанному разделителю.
    ```js
    const str = "apple, banana, cherry";
    const arr = str.split(", ");
    console.log(arr); // ["apple", "banana", "cherry"]
    ```

- **`trim()`** – удаляет пробелы в начале и конце строки.
    ```js
    const str = "   Hello, World!   ";
    console.log(str.trim()); // "Hello, World!"
    ```

- **`repeat(count)`** – возвращает новую строку, повторённую указанное количество раз.
    ```js
    const str = "Hi! ";
    console.log(str.repeat(3)); // "Hi! Hi! Hi! "
    ```

- **`concat(...strings)`** – объединяет строки.
    ```js
    const str1 = "Hello";
    const str2 = "World";
    console.log(str1.concat(", ", str2)); // "Hello, World"
    ```

## 25. **Методы массивов в JavaScript? Мутирующие методы массива?**
    
Смотреть большинство методов здесь: - https://doka.guide/js/

`Мутирующие методы` массива в JavaScript изменяют сам массив, на котором они вызываются:

1. **`push()`** — добавляет элементы в конец массива.
2. **`pop()`** — удаляет последний элемент массива.
3. **`shift()`** — удаляет первый элемент массива.
4. **`unshift()`** — добавляет элементы в начало массива.
5. **`splice()`** — добавляет или удаляет элементы по указанному индексу.
6. **`sort()`** — сортирует элементы массива на месте.
7. **`reverse()`** — изменяет порядок элементов на противоположный.
8. **`fill()`** — заполняет массив статическим значением.
9. **`copyWithin()`** — копирует часть массива в другое место внутри этого же массива.
10. **`splice()`** — добавляет или удаляет элементы из массива по указанному индексу.
11. **`shift()`** — удаляет первый элемент массива и возвращает его.
12. **`unshift()`** — добавляет один или несколько элементов в начало массива и возвращает новую длину массива.
13. **`sort()`** — сортирует элементы массива на месте и возвращает отсортированный массив.
14. **`reverse()`** — изменяет порядок элементов массива на противоположный.
15. **`concat()`** — не мутирующий метод, но часто используется вместе с мутирующими методами, добавляя элементы к массиву.

## 26. **Что такое чистая функция?**
`Чистая функция` - это функция, которая:
- Всегда возвращает один и тот же результат для одних и тех же аргументов.
- Не имеет побочных эффектов.

## 27. **Разница между .call(), .apply() и bind()?**
- `.call()`: вызывает функцию с указанным `this` и аргументами, переданными по отдельности.
- `.apply()`: вызывает функцию с указанным `this` и аргументами, переданными в виде массива.
- `.bind()`: возвращает новую функцию с указанным `this` и частично переданными аргументами.

## 28. **Почему в JS функции называют объектами первого класса?**
`Функции являются объектами первого класса`, потому что их можно передавать как аргументы, возвращать из других
функций и присваивать переменным.

## 29. **Что такое IIFE?**
`IIFE или Immediately Invoked Function Expression` — это функция, которая вызывается или выполняется сразу же после создания или объявления.:
```javascript
(function() { /* code */ })();
```

## 30. **Что такое псевдомассив arguments?**
`arguments `— это коллекция аргументов, передаваемых функции. Он имеет свойство length и поддерживает обращение по индексу к элементам, но не является массивом, из-за чего не имеет методов forEach, reduce, filter, map и так далее.

Преобразовать arguments в массив можно, например, с помощью Array.prototype.slice.

В стрелочных функциях объект arguments не работает.

## 31. **Разница между host-объектами и нативными объектами?**
**`Нативные объекты`** - встроенные объекты JavaScript (`Object`, `Array`, и т.д.).

**`Host-объекты`** - объекты, предоставленные средой выполнения (например, браузерные объекты, такие
  как `window`, `document`).

## 32. **Почему результат сравнения 2х объектов это false?**
В JavaScript `объекты сравниваются по ссылке`, а `не по значению`. Два разных объекта будут всегда не равны друг другу,
даже если они содержат одинаковые данные.

## 33. **Что такое прототипное наследование? Как создать объект без прототипа?**
**`Прототипное наследование`** - механизм, при котором объекты могут наследовать свойства и методы от другого объекта (прототипа). Объект без прототипа можно создать с помощью `Object.create(null)`.

## 34. **Почему расширение нативных JavaScript-объектов это плохая практика?**
`Расширение нативных объектов` может привести к конфликтам и проблемам совместимости, особенно если библиотека или
другой код делает то же самое.

## 35. **Что такое NaN? Как определить, что значение равно NaN?**
`NaN` (Not-a-Number) - специальное значение, которое указывает, что результат операции не является числом.
Определить `NaN` можно с помощью функции `isNaN()` или метода `Number.isNaN()`.

## 36. **Что такое объектная обертка (Wrapper Objects)?**
Объектные обертки (`String`, `Number`, `Boolean`, `Symbol` и `BigInt`) позволяют работать с примитивными значениями как с объектами,
предоставляя методы и свойства.

## 37. **Как в JavaScript создать объект?**
- Литерал объекта: `{ key: value }`
- `new Object()`
- `Object.create(proto)`

## 38. **Для чего используется метод .getOwnPropertyDescriptors()?**
Метод `.getOwnPropertyDescriptors()` возвращает объект, содержащий дескрипторы свойств для всех собственных свойств
объекта. Это позволяет получить подробную информацию о свойствах, включая их значение, доступность для чтения/записи
и т.д.

## 39. **Для чего используется ключевое слово new?**
`Ключевое слово new` используется в функциях-конструкторах для создания нового объекта (нового экземпляра класса).

Ключевое слово `new` делает 4 вещи:

1. Создает пустой объект.
2. Привязывает к нему значение this.
3. Функция наследует от functionName.prototype.
4. Возвращает значение this, если не указано иное.

## 40. **Что такое Set, Map, WeakMap и WeakSet?**

### 1. **Map** — коллекция пар "ключ-значение", где ключи могут быть любого типа. Порядок элементов в Map сохраняется.

**Методы и свойства:**

- **new Map()** – создаёт коллекцию.
- **Map.prototype.set(key, value)** – записывает по ключу key значение value.
- **Map.prototype.get(key)** – возвращает значение по ключу или undefined, если ключ key отсутствует.
- **Map.prototype.has(key)** – возвращает true, если ключ key присутствует в коллекции, иначе false.
- **Map.prototype.delete(key)** – удаляет элемент (пару «ключ/значение») по ключу key.
- **Map.prototype.clear()** – очищает коллекцию от всех элементов.
- **Map.prototype.size** – возвращает текущее количество элементов.

**Для перебора коллекции Map:**

- **Map.prototype.keys()** – возвращает итерируемый объект по ключам,
- **Map.prototype.values()** – возвращает итерируемый объект по значениям,
- **Map.prototype.entries()** – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется
  по умолчанию в for..of.

### 2. **Set** — коллекция уникальных значений. Значения в Set могут быть любого типа и не повторяются.

**Его основные методы это:**

- **new Set(iterable)** – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это
  массив), то копирует его значения в новый Set.
- **Set.prototype.add(value)** – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект
  Set.
- **Set.prototype.delete(value)** – удаляет значение, возвращает true, если value было в множестве на момент вызова,
  иначе false.
- **Set.prototype.has(value)** – возвращает true, если значение присутствует в множестве, иначе false.
- **Set.prototype.clear()** – удаляет все имеющиеся значения.
- **Set.prototype.size** – возвращает количество элементов в множестве.

**Для перебора коллекции Set:**

- **Set.prototype.keys()** – возвращает перебираемый объект для значений,
- **Set.prototype.values()** – то же самое, что и set.keys(), присутствует для обратной совместимости с Map,
- **Set.prototype.entries()** – возвращает перебираемый объект для пар вида [значение, значение], присутствует для
  обратной совместимости с Map.

### 3. **WeakMap** — аналог Map, но ключи должны быть объектами, и они не предотвращают сборку мусора. Это позволяет автоматически очищать неиспользуемые ключи.

### 4. **WeakSet** — аналог Set, но элементы могут быть только объектами, и они не предотвращают сборку мусора.

`WeakSet и WeakMap` – это специальные структуры данных в JavaScript, которые отличаются особенностью хранения ссылок на объекты.

В обычных `Set и Map` хранятся сильные ссылки на объекты. Это значит, что пока существует ссылка на объект в этих структурах, сборщик мусора не удалит этот объект из памяти, даже если больше нигде в коде нет ссылок на него.

И напротив, в WeakSet и WeakMap хранятся слабые ссылки. Это означает, что если объект, на который есть ссылка в этих структурах, больше недоступен в коде (т.е. нигде больше нет сильных ссылок на него), то сборщик мусора может удалить этот объект из памяти, даже если в WeakSet или WeakMap все еще есть ссылка на него. Таким образом, использование слабых ссылок позволяет не держать в памяти ненужные больше объекты и экономить память.

Кроме того, в WeakMap в качестве ключей могут использоваться только объекты, а не примитивные значения. А в WeakSet хранятся только объекты, без ключей.

## 41. **Расскажите о методах .keys(), .values(), .entries(), .fromEntries()?**
- `.keys()` возвращает итератор, содержащий ключи коллекции (например, для объектов Map и Set).
- `.values()` возвращает итератор, содержащий значения коллекции.
- `.entries()` возвращает итератор, содержащий пары [ключ, значение] для коллекций типа Map и Set.
- `.fromEntries()` преобразует список пар ключ-значение в объект.
Например, `Object.fromEntries([['a', 1], ['b', 2]])` вернёт `{a: 1, b: 2}`.

## 42. **Операторы «И» и «ИЛИ» (&& и ||)?**

- `&&` (И): возвращает первое ложное значение или последнее истинное.
- `||` (ИЛИ): возвращает первое истинное значение или последнее ложное.

## 43. **Что такое оператор логического присваивания?**
Оператор логического присваивания сочетает логическое действие с присваиванием. Например, `x &&= y`
эквивалентен `x && (x = y)`.

## 44. **Что такое оператор нулевого слияния (??)?**
`Оператор нулевого слияния` (`??`) возвращает правый операнд, если левый операнд равен `null` или `undefined`. В
противном случае возвращает левый операнд.

## 45. **Расскажите об операторе Optional Chaining (?.)?**

Оператор Optional Chaining (`?.`) позволяет безопасно обращаться к вложенным свойствам объекта, не вызывая ошибку,
если одно из промежуточных свойств `null` или `undefined`. Например, `obj?.property?.subProperty`.

## 46. **Для чего используется оператор остатка (%)?**
`Оператор остатка` возвращает остаток от деления двух чисел`.

## 47. **Как проверить, является ли объект массивом?**
С помощью метода `Array.isArray()`:
```javascript
Array.isArray(value);
```

## 48. **Как работает boxing/unboxing в JavaScript?**
`Boxing` - это процесс оборачивания примитива в объектную обертку, например, при доступе к свойствам или методам
примитивного значения. `Unboxing` - обратный процесс, когда объектная обертка преобразуется обратно в примитив.

## 49. **Что такое мемоизация? Реализуйте базовую логи ку функции для мемоизации?**
`Мемоизация` - это оптимизация, при которой результаты функции сохраняются и используются при последующих вызовах с теми
же аргументами.

```javascript
function memoize(fn) {
    const cache = {};
    return function (...args) {
        const key = JSON.stringify(args);
        if (!(key in cache)) {
            cache[key] = fn(...args);
        }
        return cache[key];
    };
}
```

## 50. **Как определить наличие свойства в объекте? Разница между оператором in и методом .hasOwnProperty()?**
- `in` проверяет наличие свойства в объекте и его прототипах.
- `.hasOwnProperty()` проверяет наличие свойства только в самом объекте.

## 51. **Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? Как сделать каждую из них?**
- Поверхностная копия копирует только верхний уровень объекта. Например, с помощью `Object.assign()` или оператора
  распространения `{ ...obj }`.
- Глубокая копия копирует все уровни вложенности объекта. Например, с помощью `JSON.parse(JSON.stringify(obj))` или
  библиотек вроде `lodash`.

## 52. **Что такое цепочка вызовов функций (chaining)? Как реализовать такой подход?**

`Цепочка вызовов функций` позволяет вызывать несколько методов объекта последовательно. Реализуется возвратом `this` в
методах объекта.

```javascript
let ladder = {
  step: 0,
  up() {
    this.step++;
    return this;
  },
  down() {
    this.step--;
    return this;
  },
  showStep() {
    alert( this.step );
    return this;
  }
};

ladder.up().up().down().showStep().down().showStep(); // показывает 1 затем 0
```

```javascript
ladder
  .up()
  .up()
  .down()
  .showStep() // 1
  .down()
  .showStep(); // 0
```

## 53. **Что такое необъявленная переменная?**

`Необъявленная переменная` - это переменная, к которой обращаются без использования ключевых слов `var`, `let`
или `const`.

## 54. **Как передаются параметры в функцию: по ссылке или по значению?**
Примитивные типы передаются `по значению`, объекты - `по ссылке`.

## 55. **Что такое прототип объекта в JavaScript?**
**`Прототип объекта`** - это объект, от которого другой объект наследует свойства и методы.

## 56. **Как работает метод Object.create()?**
Метод `Object.create(proto)` создает новый объект с указанным прототипом `proto`.

## 57. **Разниц между Object.freeze() и Object.seal()?**
- `Object.freeze()` замораживает объект, делая его неизменяемым.
- `Object.seal()` запечатывает объект, позволяя изменять существующие свойства, но не добавлять или удалять их.

## 58. **Разница между методами .slice() и .splice()?**
- `.slice()`: возвращает новый массив, содержащий копию части исходного массива.
- `.splice()`: изменяет исходный массив, удаляя или добавляя элементы.

## 59. **Как работают методы .find(), .findIndex() и .indexOf()?**
- `.find()`: возвращает первый элемент, удовлетворяющий условию.
- `.findIndex()`: возвращает индекс первого элемента, удовлетворяющего условию.
- `.indexOf()`: возвращает индекс первого вхождения элемента в массиве.

## 60. **Плюсы и минусы использования use strict?**

**`Плюсы:`**

- Улучшение производительности.
- Лучшая диагностика ошибок.
- Защита от небезопасных действий.

**`Минусы:`**

- Могут возникнуть проблемы при интеграции с "нестрогим" кодом.

## 61. **Разница между методами .push(), .pop(), .shift() и .unshift()?**
- `.push()`: добавляет элемент в конец массива.
- `.pop()`: удаляет последний элемент массива.
- `.shift()`: удаляет первый элемент массива.
- `.unshift()`: добавляет элемент в начало массива.

## 62. **Плюсы и минусы иммутабельности? Как достичь иммутабельности в JS?**

`Иммутабельность` — это концепция, при которой объект не может быть изменен после его создания. В JavaScript это особенно важно, поскольку помогает избежать непредсказуемого поведения при работе с состоянием, особенно в приложениях с управлением состоянием, таких как те, что используют Redux.

### `Плюсы иммутабельности:`

1. **`Предсказуемость:`** Изменения в данных не влияют на исходные объекты, что облегчает отладку и понимание кода.
2. **`Оптимизация производительности:`** Некоторые библиотеки и фреймворки могут использовать оптимизации (например, сравнение ссылок), чтобы избежать ненужных перерасчетов, если объект не изменился.
3. **`Упрощение работы с состоянием:`** В Redux иммутабельность помогает избежать мутаций состояния, что облегчает управление состоянием приложения.
4. **`Историчность изменений:`** Позволяет легко реализовать такие функции, как отмена и повтор действий, сохраняя версии данных.

### `Минусы иммутабельности:`

1. **`Сложность реализации`**: Иммутабельные структуры данных могут потребовать дополнительного кода и инструментов для их реализации.
2. **`Производительность`**: Создание новых объектов вместо изменения существующих может быть менее производительным для больших структур данных.
3. **`Неподдержка старыми библиотеками`**: Некоторые библиотеки или фреймворки могут не поддерживать иммутабельные структуры данных, что может создать сложности при интеграции.

### `Как достичь иммутабельности в JavaScript:`

1. **`Использование Object.freeze()`**: Этот метод делает объект неизменяемым. Однако это не рекурсивно, то есть вложенные объекты все еще могут изменяться.
```javascript
const obj = Object.freeze({ name: 'Anton', age: 30 });
obj.age = 31; // Ошибки не будет, но age останется 30
```

2. **`Библиотеки для иммутабельности`**: 
- **Immutable.js**: Предоставляет иммутабельные структуры данных, такие как List, Map и другие.
- **Immer**: Позволяет писать мутабельный код, который под капотом создает иммутабельные изменения.
```javascript
import produce from 'immer';

const initialState = { name: 'Anton', age: 30 };

const newState = produce(initialState, draft => {
    draft.age = 31; // Возвращает новый объект, не изменяя исходный
});
```

3. **`Spread-операторы и деструктуризация`**: Используйте их для создания новых объектов или массивов на основе существующих.
```javascript
const original = { name: 'Anton', age: 30 };
const updated = { ...original, age: 31 }; // original остается неизменным
```

4. **`Методы массивов`**: Используйте методы, такие как `map`, `filter` и `reduce`, чтобы создавать новые массивы без изменения исходных.
```javascript
const numbers = [1, 2, 3];
const doubled = numbers.map(num => num * 2); // numbers остается неизменным
```

## 63. **Типы всплывающих окон в JavaScript?**

В JavaScript существует несколько типов всплывающих окон, которые могут использоваться для взаимодействия с пользователем. Вот основные из них:

1. **`alert()`**: 
- Выводит сообщение с кнопкой "ОК". 
- Пример: 
```javascript
alert("Это сообщение!");
```

2. **`confirm()`**: 
- Отображает сообщение с двумя кнопками: "ОК" и "Отмена". Возвращает `true`, если нажата "ОК", и `false`, если "Отмена".
- Пример:
```javascript
let result = confirm("Вы уверены?");
if (result) {
    console.log("Пользователь подтвердил.");
} else {
    console.log("Пользователь отменил.");
}
```

3. **`prompt()`**: 
- Позволяет пользователю ввести текст. Возвращает введенное значение или `null`, если пользователь нажал "Отмена".
- Пример:
```javascript
let name = prompt("Введите ваше имя:");
if (name !== null) {
    console.log("Привет, " + name + "!");
}
```

Эти функции блокируют выполнение кода, пока пользователь не закроет окно, что может быть нежелательным для более современных веб-приложений. Для создания более продвинутых и не блокирующих всплывающих окон часто используются библиотеки и фреймворки, такие как SweetAlert или модальные окна, созданные с помощью HTML/CSS и JavaScript.

## 64. **Парадигмы программирования в JavaScript?**

1. **`Императивное программирование`**:
- В этой парадигме программист описывает, как выполнять задачи с помощью последовательности команд.
- Используются конструкции управления потоком (циклы, условные операторы).
```javascript
for (let i = 0; i < 5; i++) {
    console.log(i);
}
```

2. **`Декларативное программирование`**:
- В этой парадигме программист описывает, что необходимо сделать, не указывая, как это должно быть выполнено.
- Примеры: использование функций высшего порядка, таких как `map`, `filter`, и `reduce`.
```javascript
const arr = [1, 2, 3, 4, 5];
const doubled = arr.map(x => x * 2);
```

3. **`Объектно-ориентированное программирование (ООП)`**:
- JavaScript поддерживает ООП через прототипное наследование.
- Объекты могут наследовать свойства и методы от других объектов.
```javascript
function Animal(name) {
    this.name = name;
}
Animal.prototype.speak = function() {
    console.log(`${this.name} издает звук.`);
};
const dog = new Animal('Собака');
dog.speak(); // Собака издает звук.
```

4. **`Функциональное программирование`**:
- Функции рассматриваются как первоклассные объекты, которые могут передаваться в качестве аргументов, возвращаться из других функций и храниться в переменных.
- Упор на чистые функции, неизменяемость данных и функциональные конструкции.
```javascript
const add = (a, b) => a + b;
const result = add(2, 3);
```

5. **`Асинхронное программирование`**:
- JavaScript поддерживает асинхронное программирование с использованием обратных вызовов (callbacks), промисов и `async/await`.
- Позволяет обрабатывать операции, которые могут занять время, например, сетевые запросы.
```javascript
async function fetchData() {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
}
```

6. **`Модульное программирование`**:
- Разделение кода на независимые модули, что упрощает управление зависимостями и повторное использование кода.
- Используются модули ES6 и CommonJS.
```javascript
// В модуле
export const add = (a, b) => a + b;

// В другом файле
import { add } from './module.js';
```

## 65. **Типы ошибок в JavaScript?**

1. **`Синтаксические ошибки (SyntaxError)`**: Возникают, когда код содержит ошибки в синтаксисе. Например, забытая фигурная скобка или неправильно написанная конструкция.

```javascript
const a = 5 // Пропущена точка с запятой
```

2. **`Ошибки выполнения (RuntimeError)`**: Происходят во время выполнения кода, когда интерпретатор сталкивается с проблемами, например, попытка доступа к неопределенной переменной.

```javascript
console.log(b); // b не определена
```

3. **`Ошибки типа (TypeError)`**: Возникают, когда операция выполняется на значении неправильного типа, например, попытка вызвать не функцию.

```javascript
const str = "Hello";
str(); // Ошибка: str не является функцией
```

4. **`Ошибки диапазона (RangeError)`**: Происходят, когда значение выходит за пределы допустимого диапазона, например, когда передается неверное значение в функцию.

```javascript
const arr = new Array(-1); // Ошибка: недопустимый размер массива
```

5. **`Ошибки ссылки (ReferenceError)`**: Возникают, когда код пытается обратиться к переменной, которая не была объявлена.

```javascript
console.log(nonExistentVariable); // Ошибка: nonExistentVariable не определена
```

6. **`Ошибки оценки (EvalError)`**: Связаны с неправильным использованием функции `eval()`, хотя такие ошибки встречаются реже.

```javascript
// Пример невалидного использования eval
eval("var a = ;"); // Ошибка: некорректное выражение
```

7. **`Ошибки асинхронности (PromiseRejectionError)`**: Возникают при неудачном выполнении промисов, когда они отклоняются.

```javascript
Promise.reject("Ошибка").catch((error) => console.log(error)); // Обработает ошибку
```

## 66. **Разница между typeof и instanceof?**
- `typeof` возвращает строку, указывающую тип примитива или объекта.
- `instanceof` проверяет, является ли объект экземпляром определенного конструктора.

## 67. **Что такое регулярное выражение (Regular Expression)? Какие методы используются в регулярных выражениях?**

`Регулярное выражение (Regular Expression, или regex)` — это последовательность символов, которая описывает шаблон для поиска или обработки строк. Регулярные выражения позволяют выполнять сложные операции поиска и замены, а также валидацию данных в строках.

### `Основные понятия регулярных выражений:`

1. **`Литералы`**: Это простые символы, которые представляют собой сами себя, например, `a`, `b`, `1`, `2` и т.д.

2. **`Специальные символы`**: Некоторые символы имеют специальное значение:
- `.` — любой символ (кроме новой строки)
- `*` — 0 или более повторений предыдущего символа
- `+` — 1 или более повторений предыдущего символа
- `?` — 0 или 1 повторение предыдущего символа
- `^` — начало строки
- `$` — конец строки
- `[]` — класс символов (например, `[a-z]` — любой символ от a до z)
- `()` — группировка (например, `(abc)` будет соответствовать строке "abc")
- `|` — логическое "или" (например, `a|b` соответствует либо "a", либо "b")

3. **`Экранирование`**: Для использования специальных символов как литералов их нужно экранировать с помощью обратного слэша (`\`). Например, чтобы искать символ `.` (точка), нужно использовать `\.`.

### `Методы для работы с регулярными выражениями в JavaScript:`

1. **`RegExp`**: Конструктор для создания регулярных выражений.
```javascript
const regex = new RegExp('abc'); // Создание регулярного выражения
```

2. **`String.prototype.match()`**: Возвращает массив совпадений или `null`, если совпадений не найдено.
```javascript
const str = 'abcdef';
const result = str.match(/abc/); // ['abc']
```

3. **`String.prototype.replace()`**: Заменяет найденные совпадения на другой текст.
```javascript
const str = 'abcdef';
const newStr = str.replace(/abc/, 'xyz'); // 'xyzdef'
```

4. **`String.prototype.search()`**: Возвращает индекс первого совпадения или -1, если совпадения не найдены.
```javascript
const str = 'abcdef';
const index = str.search(/abc/); // 0
```

5. **`String.prototype.split()`**: Разделяет строку на массив по заданному шаблону.
```javascript
const str = 'a,b,c';
const arr = str.split(/,/); // ['a', 'b', 'c']
```

6. **`RegExp.prototype.test()`**: Проверяет, есть ли совпадения с регулярным выражением в строке.
```javascript
const regex = /abc/;
const result = regex.test('abcdef'); // true
```

### `Пример использования:`

```javascript
const email = 'example@test.com';
const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;

if (emailRegex.test(email)) {
    console.log('Email valid');
} else {
    console.log('Email invalid');
}
```

## 68. **Что такое полифил (polyfill)?**

`Полифил (polyfill)` — это код (обычно написанный на JavaScript), который добавляет функциональность в браузеры, которые не поддерживают определенные функции или методы, предусмотренные в современных версиях языков или спецификаций. Полифилы позволяют разработчикам использовать новые возможности без необходимости ожидать, пока все пользователи обновят свои браузеры.

### `Основные аспекты полифилов:`

1. **`Поддержка старых браузеров`**: Полифилы позволяют использовать новые функции JavaScript, такие как методы массива, промисы, `fetch` и другие, в браузерах, которые не поддерживают их.

2. **`Пример реализации`**: Если какой-то метод, например, `Array.prototype.includes`, не поддерживается в старых браузерах, полифил может быть реализован следующим образом:

```javascript
if (!Array.prototype.includes) {
    Array.prototype.includes = function(element) {
        return this.indexOf(element) !== -1;
    };
}
```

3. **`Загрузка`**: Полифилы могут быть загружены через специальные библиотеки, такие как [core-js](https://github.com/zloirock/core-js) или [polyfill.io](https://polyfill.io/v3/url-builder/), которые автоматически предоставляют необходимые полифилы в зависимости от целевых браузеров.

4. **`Проблемы с производительностью`**: Хотя полифилы позволяют использовать новые функции, они могут негативно сказаться на производительности, особенно если они реализованы неэффективно.

5. **`Использование в проектах`**: Полифилы часто используются в больших проектах для обеспечения совместимости с различными версиями браузеров, позволяя разработчикам писать более современный код.

## 69. **Что такое switch/case? Правила использования switch/case?**

`switch/case` - это оператор для сравнения одного выражения с несколькими значениями:

```javascript
switch (expression) {
    case value1:
        // код
        break;
    case value2:
        // код
        break;
    default:
        // код
}
```

## 70. **Что такое выражения (expression) и инструкции (statement) в JavaScript?**

### `Выражения (Expressions)`

`Выражение` — это фрагмент кода, который вычисляется и возвращает значение. Выражения могут включать в себя значения, переменные, операторы и функции. 

Примеры:

1. **`Числовые выражения`**:
```javascript
5 + 3 // Возвращает 8
```

2. **`Строковые выражения`**:
```javascript
'Hello, ' + 'world!' // Возвращает 'Hello, world!'
```

3. **`Логические выражения`**:
```javascript
true && false // Возвращает false
```

4. **`Функции`**:
```javascript
Math.max(5, 10) // Возвращает 10
```

5. **`Вызовы функций`**:
```javascript
const x = 10;
const y = 20;
x + y // Возвращает 30
```

### `Инструкции (Statements)`

`Инструкция` — это более крупный фрагмент кода, который выполняет определенное действие, но не возвращает значение. Инструкции могут включать в себя выражения, условия, циклы и другие конструкции управления.

Примеры:

1. **`Объявление переменной`**:
```javascript
let x = 5; // Это инструкция, которая объявляет переменную x и присваивает ей значение 5
```

2. **`Условная инструкция`**:
```javascript
if (x > 0) {
    console.log('x больше нуля'); // Это инструкция, выполняющая действие в зависимости от условия
}
```

3. **`Цикл`**:
```javascript
for (let i = 0; i < 5; i++) {
    console.log(i); // Это инструкция, выполняющая действие несколько раз
}
```

4. **`Функция`**:
```javascript
function add(a, b) {
    return a + b; // Это инструкция, которая возвращает значение
}
```

## 71. **Разница между .some() и .every()?**
- `.some()`: возвращает `true`, если хотя бы один элемент массива удовлетворяет условию.
- `.every()`: возвращает `true`, если все элементы массива удовлетворяют условию.

## 72. **Как сгенерировать случайное число в JavaScript?**

С помощью `Math.random()`:

```javascript
Math.random(); // случайное число от 0 до 1 (не включая 1)
```

## 73. **Типы операторов в JavaScript?**
- `Арифметические`: `+`, `-`, `*`, `/`, `%`
- `Сравнения`: `==`, `===`, `!=`, `!==`, `>`, `<`, `>=`, `<=`
- `Логические`: `&&`, `||`, `!`
- `Присваивания`: `=`, `+=`, `-=`, `*=`, `/=`
- `Побитовые`: `&`, `|`, `^`, `~`, `<<`, `>>`, `>>>`
- `Специальные`: `typeof`, `instanceof`, `new`, `delete`, `void`, `in`

## 74. **Разница между параметром и аргументом функции?**
`Параметры` - это переменные, объявленные в определении функции. Аргументы - это значения, передаваемые функции при ее
вызове.

## 75. **Правила задания имён для переменных и функций в JavaScript?**
- Должны начинаться с буквы, знака доллара `$` или подчеркивания `_`.
- Не могут начинаться с цифры.
- Должны быть понятными и описательными.
- Не должны быть зарезервированными словами.

## 76. **Разница между явным и неявным преобразованием (Implicit and Explicit Coercion)?**
`Явное преобразование`: программист явно указывает преобразование типа (`Number()`, `String()`, `Boolean()`).

`Неявное преобразование`: JavaScript автоматически преобразует типы в процессе выполнения.

## 77. **Для чего применяется метод Array.from()?**

Метод `Array.from()` создает новый массив из массивоподобного или итерируемого объекта.

## 78. **Назовите способы преобразования массива в объект?**
- Использование метода `reduce()`:
```javascript
const array = [1, 2, 3];
const obj = array.reduce((acc, cur, index) => ({ ...acc, [index]: cur }), {});
```
- С помощью `Object.assign()` и оператора распространения:
```javascript
const obj = Object.assign({}, array);
```
- Использование метода `Object.fromEntries()`:
```javascript
const obj = Object.fromEntries(array.map((value, index) => [index, value]));
```

## 79. **Что такое каррирование?**

`Каррирование` — это техника в функциональном программировании, которая позволяет преобразовывать функцию с несколькими аргументами в последовательность функций, каждая из которых принимает один аргумент. Это означает, что вместо того чтобы передавать все аргументы функции одновременно, вы передаете их по одному.

Например, представим функцию, которая принимает два аргумента:

```javascript
function add(x, y) {
    return x + y;
}
```

С помощью каррирования эту функцию можно преобразовать в следующую:

```javascript
function curriedAdd(x) {
    return function(y) {
        return x + y;
    };
}
```

Теперь вы можете использовать эту функцию так:

```javascript
const addFive = curriedAdd(5);
console.log(addFive(3)); // Вывод: 8
```


## 80. **Как работает «сборщик мусора» в JavaScript?**
`Сборщик мусора` автоматически освобождает память, удаляя объекты, которые больше не доступны или не используются.

## 81. **Что такое утечки памяти? Назовите основные типы утечек памяти в JavaScript?**

`Утечки памяти` возникают, когда программа продолжает потреблять память, не освобождая ее после использования, что
может привести к исчерпанию памяти.

### `Распространенные типы утечек памяти:`

1. **`Задержки ссылок (Reference Retention):`**
   - Когда объект остаётся доступным из других объектов, даже если он больше не нужен. Это может произойти, если вы храните ссылки на объекты в глобальных переменных или в замыканиях.

2. **`Замыкания (Closures):`**
   - Замыкания позволяют функции захватывать переменные из своей внешней области видимости. Если такие функции сохраняются и используются долгое время, они могут удерживать ссылки на объекты, которые должны быть освобождены.

3. **`Обработчики событий (Event Handlers):`**
   - Если обработчики событий не удаляются после их использования, они могут удерживать ссылки на элементы DOM или другие объекты, что мешает сборщику мусора освободить их.

4. **`Неочищенные таймеры и интервалы (Uncleared Timers and Intervals):`**
   - Таймеры (например, `setTimeout` и `setInterval`), которые не очищаются после завершения их работы, могут удерживать ссылки на функции и объекты, предотвращая их освобождение.

5. **`Кэширование (Caching):`**
   - Если объекты кэшируются и не очищаются, это может привести к накоплению ненужных данных в памяти. Нужно следить за тем, чтобы кэш не увеличивался без необходимости.

6. **`Неосвобождённые DOM-элементы:`**
   - Если вы создаёте элементы DOM и не удаляете их, они остаются в памяти, даже если они не отображаются на странице.

7. **`Ошибки в библиотеках и фреймворках:`**
   - Некоторые библиотеки могут иметь свои собственные утечки памяти из-за неправильного управления памятью. Это особенно актуально для устаревших или плохо поддерживаемых библиотек.

## 82. **Как работает контекст выполнения (execution context) в JavaScript?**
`Контекст выполнения` (execution context) в JavaScript — это концепция, которая описывает среду, в которой выполняется текущий код. Это важная часть механизма выполнения JavaScript-кода, которая управляет областью видимости переменных и определяет, как и где они могут быть доступны.

### Основные типы контекстов выполнения:
1. **Глобальный контекст выполнения:**
    - Это контекст выполнения по умолчанию для любого JavaScript-кода.
    - В браузере глобальный контекст привязан к объекту `window`, а в Node.js — к объекту `global`.
    - Все переменные и функции, объявленные на глобальном уровне, принадлежат этому контексту.
    - В глобальном контексте нет "родителя", это самый верхний уровень выполнения.

2. **Контекст выполнения функции:**
    - Создается каждый раз, когда вызывается функция.
    - Внутри функции создается собственное пространство имен для переменных и функций (локальная область видимости).
    - При каждом вызове функции создается новый контекст выполнения для этой конкретной функции.

3. **Контекст выполнения eval():**
    - Код, переданный в функцию `eval()`, выполняется в собственном контексте выполнения.

### Что содержит каждый контекст выполнения?
Каждый контекст выполнения имеет три ключевых компонента:
1. **Область видимости (Scope) и цепочка областей видимости (Scope Chain):**
    - Область видимости — это набор переменных, к которым функция может получить доступ.
    - Цепочка областей видимости обеспечивает поиск переменных в контексте функции, если они не найдены в текущем контексте.

2. **Объект переменных (Variable Object):**
    - Содержит все переменные, функции и аргументы, определенные в контексте функции или глобальном контексте.
    - В случае функции он также содержит параметры, переданные функции.

3. **Ключевое слово `this`:**
    - Значение `this` зависит от того, как была вызвана функция.
    - В глобальном контексте `this` ссылается на глобальный объект (например, `window` в браузере).
    - В контексте функции значение `this` определяется способом вызова функции (например, может быть объектом, который вызывает метод).

### Стек контекстов выполнения (Execution Context Stack):
Когда JavaScript выполняет код, он использует стек контекстов выполнения (также называемый стеком вызовов). Каждый новый контекст выполнения добавляется в стек, когда начинается выполнение функции, и удаляется, когда функция завершает выполнение. Стек работает по принципу LIFO (последний пришел — первый ушел).

Пример:
```javascript
function a() {
  console.log('Function a');
  b();
}

function b() {
  console.log('Function b');
}

a();
```
1. Когда запускается `a()`, создается новый контекст выполнения для функции `a`.
2. Внутри `a()` вызывается `b()`, создается контекст выполнения для функции `b`, и он добавляется в стек.
3. Когда `b()` завершается, его контекст удаляется из стека, и выполнение возвращается в `a()`.

### Фазы контекста выполнения:
1. **Фаза создания (Creation Phase):**
    - JavaScript движок создает контекст выполнения, но не выполняет код.
    - Создается объект переменных, происходит "поднятие" (hoisting) переменных и функций.

2. **Фаза исполнения (Execution Phase):**
    - После завершения фазы создания, движок начинает выполнять код строка за строкой.

Контекст выполнения — это основа работы JavaScript, благодаря которой движок управляет областью видимости и контекстом вызова в процессе выполнения кода.

## 83. **Разница между примитивом и объектом?**
- `Примитивы` (числа, строки, булевые значения, `null`, `undefined`, `symbol`, `bigint`) хранятся непосредственно по
  значению.
- `Объекты` хранятся по ссылке и могут содержать множество значений и методов.

## 84. **Почему typeof null возвращает object?**

`typeof null == 'object'` всегда будет возвращать `true` по историческим причинам.

От сообщества поступало предложение исправить эту ошибку, изменив `typeof null = 'object'` на `typeof null = 'null'`, но оно было отклонено в интересах сохранения обратной совместимости (такое изменение повлекло бы за собой большое количество ошибок).

Для проверки, является ли значение `null` можно использовать оператор строгого равенства `===`:

```javascript
function isNull(value){
  return value === null
}
```

## 85. **Что такое модули?**
ES6 модули позволяют организовывать код в модули, которые могут экспортировать и импортировать функциональность.
Модули поддерживаются нативно в JavaScript и позволяют использовать ключевые слова `import` и `export` для работы с
модулями.

Модули позволяют объединять (использовать) код из разных файлов и избавляют нас от необходимости держать весь код в одном большом файле.

## 86. **Как работают Proxy и Reflect?**

`Proxy` и `Reflect` — это два встроенных объекта в JavaScript, которые часто используются вместе для создания более сложных и мощных объектов.

### `Proxy`

`Proxy` позволяет создавать прокси-объекты, которые перехватывают операции, выполняемые с целевым объектом, и позволяют вам контролировать эти операции. Например, вы можете перехватывать доступ к свойствам, вызовы функций и другие действия.

Вот основные моменты о `Proxy`:

- **`Синтаксис`**:
```javascript
const proxy = new Proxy(target, handler);
```
- `target`: объект, который будет обернут прокси.
- `handler`: объект, содержащий ловушки (trap), которые перехватывают операции.

- **`Ловушки`**: Это методы в объекте `handler`, которые перехватывают различные операции. Например:
- `get`: перехватывает доступ к свойствам.
- `set`: перехватывает запись свойств.
- `apply`: перехватывает вызовы функции.

### `Пример использования Proxy`

```javascript
const target = {
  message: "Hello, World!"
};

const handler = {
  get(target, prop) {
    if (prop in target) {
      return target[prop];
    } else {
      return "Property not found!";
    }
  }
};

const proxy = new Proxy(target, handler);

console.log(proxy.message); // Hello, World!
console.log(proxy.nonExistent); // Property not found!
```

### `Reflect`

`Reflect` — это объект, который предоставляет методы для выполнения операций, которые обычно перехватываются с помощью `Proxy`. Это позволяет вам вызывать стандартные операции JavaScript с помощью методов `Reflect`, которые могут быть использованы внутри ловушек `Proxy`.

Вот основные моменты о `Reflect`:

- **`Синтаксис`**:
  ```javascript
  Reflect.methodName(target, ...args);
  ```

- **`Методы`**: `Reflect` включает в себя различные методы, такие как:
  - `Reflect.get(target, propertyKey)`: получает значение свойства.
  - `Reflect.set(target, propertyKey, value)`: устанавливает значение свойства.
  - `Reflect.apply(target, thisArgument, argumentsList)`: вызывает функцию.

### `Пример использования Reflect`

```javascript
const obj = {
  a: 1,
  b: 2
};

console.log(Reflect.get(obj, 'a')); // 1
Reflect.set(obj, 'c', 3);
console.log(obj.c); // 3
```

### `Пример использования Proxy с Reflect`

```javascript
const target = {
  name: "John"
};

const handler = {
  get(target, prop) {
    return Reflect.get(target, prop);
  },
  set(target, prop, value) {
    console.log(`Setting ${prop} to ${value}`);
    return Reflect.set(target, prop, value);
  }
};

const proxy = new Proxy(target, handler);

console.log(proxy.name); // John
proxy.name = "Doe"; // Setting name to Doe
console.log(proxy.name); // Doe
```

В этом примере `Proxy` использует методы `Reflect` для выполнения стандартных операций на целевом объекте, что позволяет поддерживать ожидаемое поведение при перехвате операций.

## 87. **Web Workers**

`Web Workers` — это JavaScript-потоки, которые позволяют выполнять скрипты в фоновом режиме, не блокируя основной поток выполнения (UI поток) веб-приложения. Это особенно полезно для задач, требующих значительных вычислительных ресурсов, таких как обработка данных или выполнение длительных вычислений.

### `Основные моменты о Web Workers:`

1. **`Фоновое выполнение`**: Web Workers позволяют выполнять код в фоновом режиме, освобождая основной поток от блокировки и улучшая отзывчивость интерфейса.

2. **`Отдельный контекст`**: Каждый Worker работает в своем собственном контексте. Он не имеет доступа к DOM и глобальным объектам, таким как `window` или `document`. Вместо этого он имеет доступ к объекту `self`.

3. **`Сообщения`**: Взаимодействие между основным потоком и Worker осуществляется с помощью асинхронных сообщений. Основной поток отправляет сообщения в Worker с помощью метода `postMessage()`, а Worker может отправлять сообщения обратно через `postMessage()`.

4. **`Ограничения`**: Workers не могут использовать такие API, как `alert()`, `prompt()` или `confirm()`, а также некоторые другие веб-API, такие как `localStorage`.

5. **`Создание Worker`**:
```javascript
const worker = new Worker('worker.js');

worker.postMessage('Hello, Worker!');

worker.onmessage = function(event) {
    console.log('Message from worker:', event.data);
};
```

6. **`Пример использования`**:
- **Фоновая обработка данных**: Например, вы можете использовать Worker для обработки больших массивов данных, чтобы не блокировать интерфейс.
- **Вычисления**: Выполнение интенсивных математических вычислений.

Пример:

**`worker.js`**:
```javascript
self.onmessage = function(event) {
    const data = event.data;
    // Выполните длительные вычисления или обработку данных
    const result = data * 2; // Пример вычисления
    self.postMessage(result); // Отправить результат обратно
};
```

**`Основной скрипт`**:
```javascript
const worker = new Worker('worker.js');

worker.onmessage = function(event) {
    console.log('Результат:', event.data);
};

worker.postMessage(10); // Отправить данные в Worker
```

## 88. **Разница между синхронными и асинхронными функциями?**

`Синхронные функции выполняются последовательно`: одна за другой. Это означает, что следующая строка кода не будет
выполнена, пока текущая функция не завершится. 

`Асинхронные функции позволяют выполнять код параллельно`, не блокируя
выполнение последующих строк кода. Они могут завершаться позже, чем последующие операции.

## 89. **Что такое AJAX?**

`AJAX (Asynchronous JavaScript and XML)` - это набор технологий, который позволяет загружать данные с сервера
асинхронно без перезагрузки страницы. AJAX использует объект XMLHttpRequest или fetch для отправки и получения данных
в различных форматах, включая JSON и XML.

## 90. **Что такое same-origin policy в контексте JavaScript?**

`Same-origin policy (политика того же источника)` - это механизм безопасности, который ограничивает взаимодействие
скриптов, загруженных с одного источника, с ресурсами, загруженными с другого источника. Это предотвращает атаки,
такие как межсайтовый скриптинг (XSS).

## 91. **Что такое цикл событий (event loop) и как он работает?**

`Цикл событий (event loop)` — это механизм в JavaScript, который управляет выполнением асинхронных операций, позволяя языку быть **однопоточным**, но при этом эффективно работать с задачами, которые требуют времени, как сетевые запросы или таймеры.

### `Как работает цикл событий:`

1. **Основной поток (call stack)**: Все синхронные операции выполняются в основном потоке (стеке вызовов). Когда вызывается функция, она помещается в стек и выполняется последовательно.

2. **Асинхронные операции**: Когда JavaScript сталкивается с асинхронной операцией (например, запросом к серверу, таймером или обработчиком события), эта операция передается браузеру или Node.js для обработки на фоне. Основной поток продолжает работать с другими задачами.

3. **Очередь задач (callback queue)**: После завершения асинхронной операции её коллбэк помещается в очередь задач. Однако коллбэк не будет выполнен немедленно — он должен дождаться, пока основной поток освободится.

4. **Цикл событий (event loop)**: Цикл событий постоянно проверяет основной поток и очередь задач. Если основной поток пуст, он забирает задачу из очереди и помещает её в стек вызовов для выполнения.

Пример:

```javascript
console.log('Начало');

setTimeout(() => {
  console.log('Асинхронная операция');
}, 1000);

console.log('Конец');
```

Вывод:
```
Начало
Конец
Асинхронная операция
```

- Сначала выполняются синхронные операции — вывод "Начало" и "Конец".
- `setTimeout` — это асинхронная операция, её коллбэк попадает в очередь задач и выполнится после того, как основной поток освободится и истечёт время таймера.

## 92. **Разница между микро и макрозадачами в event loop?**
В JavaScript цикл событий (event loop) обрабатывает две разные очереди задач: **микрозадачи** (microtasks) и **макрозадачи** (macrotasks). Различие между ними важно для понимания порядка выполнения операций в асинхронном коде.

### `Макрозадачи (macrotasks)`
`Макрозадачи` — это более крупные задачи, такие как:
- `setTimeout`
- `setInterval`
- Ввод-вывод (I/O) операции (например, сетевые запросы)
- Обработчики событий (клики, ввод данных и т.д.)

После выполнения всех синхронных операций из стека вызовов цикл событий выполняет одну макрозадачу, затем переходит к выполнению всех микрозадач.

### `Микрозадачи (microtasks)`
`Микрозадачи` — это более мелкие задачи, такие как:
- Промисы (`Promise` и `Promise.then`)
- `process.nextTick()` (в Node.js)
- Обновления DOM (например, мутации в браузере)

Микрозадачи имеют более высокий приоритет по сравнению с макрозадачами. После завершения каждой макрозадачи цикл событий выполняет **все микрозадачи**, находящиеся в очереди, перед тем как перейти к следующей макрозадаче.

## 93. **Расскажите о queueMicrotask?**
`queueMicrotask` - это метод, который позволяет добавлять микрозадачи в очередь микрозадач, которые будут выполнены
после текущего синхронного кода и перед любыми макрозадачами.

## 94. **Что такое callback-функция? Что такое Callback Hell?**

**`Callback-функция`** — это функция, передаваемая в качестве аргумента другой функции и вызываемая по мере выполнения этой функции. Это позволяет выполнять асинхронные операции и обрабатывать их результаты, когда они становятся доступны. Callback-функции широко используются в JavaScript, особенно в таких контекстах, как работа с событиями, асинхронные запросы (например, Ajax) и обработка промисов.

Пример:

```javascript
function fetchData(callback) {
    setTimeout(() => {
        const data = "Данные загружены";
        callback(data);
    }, 1000);
}

fetchData((result) => {
    console.log(result); // Выводит "Данные загружены" через 1 секунду
});
```

**`Callback Hell`** (или "ад обратных вызовов") — это ситуация, когда используются несколько вложенных callback-функций. Это может привести к трудночитаемому и труднопонимаемому коду, где каждую последующую функцию нужно помещать внутрь предыдущей. Такой стиль кода затрудняет отладку и поддержку, а также может привести к проблемам с управлением потоком выполнения.

Пример:

```javascript
fetchData((result1) => {
    console.log(result1);
    fetchData((result2) => {
        console.log(result2);
        fetchData((result3) => {
            console.log(result3);
            // И так далее...
        });
    });
});
```

## 95. **Что такое промисы (Promises)?**
`Promise` - это объект, представляющий результат асинхронной операции. Он может находиться в одном из трёх состояний:
`ожидание (pending)`, `выполнено (fulfilled)`, `отклонено (rejected)`. Промисы позволяют удобнее работать с асинхронным кодом,
избегая вложенных колбэков.

## 96. **Что такое async/await?**
`async/await` - это синтаксический сахар для работы с промисами, который позволяет писать асинхронный код так, как
если бы он был синхронным. `async` помечает функцию как асинхронную, `await` заставляет ждать выполнения промиса.

## 97. **Разница между Promise.all(), Promise.any() и Promise.race()и Promise.allSettled()?**

- `Promise.all()`: Выполняется, когда все промисы завершены. Если один из промисов отклонен, возвращает ошибку.
- `Promise.any()`: Выполняется, когда хотя бы один из промисов выполнен. Если все промисы отклонены, возвращает ошибку.
- `Promise.race()`: Выполняется, когда первый из промисов завершен (выполнен или отклонен).
- `Promise.allSettled()` возвращает промис, который выполняется, когда все переданные промисы завершены (выполнены или
отклонены). Результат содержит массив объектов с состоянием и значением/причиной каждого промиса.

## 98. **Что такое fetch()?**

`fetch()` — это встроенная функция JavaScript, используемая для выполнения HTTP-запросов. Она возвращает промис, который разрешается в ответ на запрос. `fetch()` обеспечивает более простой и удобный способ работы с сетью по сравнению с `XMLHttpRequest`.

### `Основные характеристики fetch():`

1. **`Асинхронность`:**
   `fetch()` работает асинхронно, возвращая промис, который будет разрешен, когда ответ будет получен.

2. **`Поддержка Promise:`**
   Это значит, что можно использовать `.then()` для обработки ответа и `.catch()` для обработки ошибок.

3. **`Поддержка CORS:`**
   `fetch()` поддерживает кросс-доменные запросы (Cross-Origin Resource Sharing), что позволяет делать запросы к другим доменам.

### `Синтаксис`

```javascript
fetch(url, options)
  .then(response => {
    // Обработка ответа
  })
  .catch(error => {
    // Обработка ошибки
  });
```

- **`url`**: URL-адрес, к которому вы хотите сделать запрос.
- **`options`**: (необязательный) объект с настройками, такими как метод запроса (`GET`, `POST` и т.д.), заголовки, тело запроса и другие параметры.

### `Пример использования`

#### `Простой GET-запрос`

```javascript
fetch('https://api.example.com/data')
  .then(response => {
    if (!response.ok) {
      throw new Error('Сеть не в порядке: ' + response.statusText);
    }
    return response.json(); // Преобразование ответа в JSON
  })
  .then(data => {
    console.log(data); // Обработка данных
  })
  .catch(error => {
    console.error('Ошибка:', error);
  });
```

#### `POST-запрос`

```javascript
fetch('https://api.example.com/data', {
  method: 'POST', // Метод запроса
  headers: {
    'Content-Type': 'application/json' // Установка заголовка
  },
  body: JSON.stringify({ key: 'value' }) // Тело запроса
})
  .then(response => {
    if (!response.ok) {
      throw new Error('Сеть не в порядке: ' + response.statusText);
    }
    return response.json();
  })
  .then(data => {
    console.log(data); // Обработка ответа
  })
  .catch(error => {
    console.error('Ошибка:', error);
  });
```

### `Как работает fetch():`

1. **Инициализация запроса:** Когда вызывается `fetch()`, он инициализирует HTTP-запрос.
  
2. **Обработка ответа:** После получения ответа, промис разрешается, и объект `Response` передается в следующий `.then()`.

3. **Проверка статуса:** Вы можете проверить свойство `ok` объекта `Response`, чтобы убедиться, что запрос прошел успешно (статусы от 200 до 299).

4. **Парсинг ответа:** Для работы с данными, вы можете использовать методы, такие как `.json()`, `.text()`, `.blob()` и другие, чтобы преобразовать ответ в нужный формат.

5. **Обработка ошибок:** Если запрос не прошел (например, сеть недоступна), промис будет отклонен, и выполнение перейдет в блок `.catch()`.

## 99. **Что такое JSON в JavaScript? Отличие от XML?**
`JSON (JavaScript Object Notation)` - это формат для обмена данными, основанный на JavaScript-объектах. Он
используется для передачи данных между сервером и клиентом. В JavaScript его можно парсить и сериализовать с
помощью `JSON.parse()` и `JSON.stringify()`.

### `Различия JSON и XML:`

- **JSON** (`JavaScript Object Notation`): легковесный формат данных, используемый для обмена данными, легко
  читается человеком и машиной.
- **XML** (`eXtensible Markup Language`): более сложный формат для хранения и передачи данных, использующий разметку
  для определения структуры.

## 100. **Что такое DOM?**

`DOM (Document Object Model)` — это специальная древовидная структура, которая позволяет управлять HTML-разметкой из JavaScript-кода. Управление обычно состоит из добавления и удаления элементов, изменения их стилей и содержимого.

Браузер создаёт DOM при загрузке страницы, складывает его в переменную document и сообщает, что DOM создан, с помощью
события DOMContentLoaded.

## 101. **Что такое BOM?**
`BOM (Browser Object Model)` представляет объекты, предоставляемые браузером, которые позволяют взаимодействовать с
браузерным окружением. Например, `window`, `navigator`, `location`, `history` и `screen` — это объекты BOM.

## 102. **Типы узлов DOM-дерева?**
Основные типы узлов DOM-дерева:
- `Element`: узлы элементов, такие как `<div>`, `<p>`, `<a>`.
- `Attribute`: узлы атрибутов, связанные с элементами.
- `Text`: текстовые узлы, содержащие текст внутри элементов.
- `Comment`: узлы комментариев.
- `Document`: корневой узел документа.
- `DocumentFragment`: фрагмент документа, который можно использовать для временного хранения элементов.

## 103. **Методы поиска элементов в DOM?**
- `document.getElementById(id)`: находит элемент по идентификатору.
- `document.getElementsByClassName(className)`: находит элементы по имени класса.
- `document.getElementsByTagName(tagName)`: находит элементы по имени тега.
- `document.querySelector(selector)`: находит первый элемент, соответствующий CSS-селектору.
- `document.querySelectorAll(selector)`: находит все элементы, соответствующие CSS-селектору.

## 104. **Свойства для перемещения по DOM-дереву?**
- `parentNode`: родительский узел.
- `childNodes`: список дочерних узлов.
- `firstChild`: первый дочерний узел.
- `lastChild`: последний дочерний узел.
- `nextSibling`: следующий соседний узел.
- `previousSibling`: предыдущий соседний узел.

## 105. **Разница между attribute и property у DOM-элементов?**
- **Attribute**: относится к HTML-атрибутам, как они указаны в исходном коде. Например, `<input type="text" />`
  имеет атрибут `type`.
- **Property**: относится к свойствам объекта в DOM. Например, `element.type` указывает на текущее значение
  свойства `type`, которое может отличаться от значения атрибута.



## 106. **Виды событий в JavaScript?**
- **Мышь**: 
`click`, `dblclick`, `mousedown`, `mouseup`, `mousemove`, `mouseover`, `mouseout`, `mouseenter`, `mouseleave`.
- **Клавиатура**: `keydown`, `keyup`, `keypress`.
- **Форма**: `submit`, `change`, `focus`, `blur`, `input`.
- **Документ и окно**: `load`, `unload`, `resize`, `scroll`, `DOMContentLoaded`.
- **Сетевые события**: `error`, `progress`, `loadend`.

## 107. **Как добавить обработчик события на DOM-элемент?**
   ```javascript
   element.addEventListener('event', function() {
     // обработчик события
   });
   ```
   Например:
   ```javascript
   document.getElementById('myButton').addEventListener('click', function() {
     alert('Button clicked!');
   });
   ```

## 108. **Как удалить обработчик события с DOM-элемента?**
   ```javascript
   element.removeEventListener('event', handler);
   ```
   Пример:
   ```javascript
   function handleClick() {
     alert('Button clicked!');
   }

   const button = document.getElementById('myButton');
   button.addEventListener('click', handleClick);
   // Удаление обработчика
   button.removeEventListener('click', handleClick);
   ```

## 109. **Что такое распространение события (Event Propagation)?**

Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие
«распространяется» от объекта window до вызвавшего его элемента (event.target). При этом событие последовательно
пронизывает всех предков целевого элемента.

Этот процесс называется Event Propagation (распространение события).

**Event Propagation имеет три стадии:**

1. **Фаза погружения** — событие возникает в объекте window и опускается до цели события через всех ее предков.
2. **Целевая фаза** — это когда событие достигает целевого элемента.
3. **Фаза всплытия** — событие поднимается от event.target, последовательно проходит через всех его предков и достигает
   объекта window.

## 110. **Что такое делегирование событий (Event Delegation)?**

`Делегирование событий` — подход при работе с событиями DOM-дерева, при котором обработчики событий добавляются не на
каждый конкретный элемент, а только на общий родительский, в то время как необходимость вызова это обработчика для
конкретного интересующего нас элемента определяется через инициатора события, узнать который можно из свойства объекта
события event.target.

Такой подход возможен благодаря особенностям событийной модели DOM-дерева, а конкретно такой особенности, как всплытие
событий.

## 111. **Как использовать media выражения в JavaScript?**

Media выражения обычно используются в CSS, но также могут быть использованы в JavaScript
через `window.matchMedia()`. 

Пример:
```javascript
const mediaQuery = window.matchMedia('(max-width: 600px)');
if (mediaQuery.matches) {
    console.log('Экран меньше 600px');
} else {
    console.log('Экран больше 600px');
}
```

## 112. **Расскажите про координаты в браузере?**

Координаты в браузере можно получить с помощью `getBoundingClientRect()`, который возвращает размер элемента и его
позицию относительно видимой области экрана. 

Пример:
```javascript
const rect = element.getBoundingClientRect();
console.log(rect.top, rect.left, rect.width, rect.height);
```

## 113. **Разница между HTMLCollection и NodeList?**
- `HTMLCollection`: коллекция элементов, которые обновляются автоматически при изменении DOM. Обычно возвращается
  методами типа `getElementsByClassName` или `getElementsByTagName`.
- `NodeList`: коллекция узлов, не обязательно элементов. Возвращается методами типа `querySelectorAll`. NodeList
  может быть как живым (обновляющимся), так и статичным (необновляющимся).

## 114. **Как динамически добавить элемент на HTML-страницу?**
```javascript
const newElement = document.createElement('div');
newElement.textContent = 'Привет, мир!';
document.body.appendChild(newElement);
```

## 115. **Разница между feature detection, feature inference и анализом строки user-agent?**

- `Feature Detection`: проверка поддержки функциональности браузером. Например, проверка наличия метода `fetch`.
- `Feature Inference`: использование существующих методов или свойств для определения поддержки функции.
- `Анализ строки user-agent`: использование строки user-agent для определения типа и версии браузера. Этот метод
  менее надежен, чем feature detection.

## 116. **Разница между e.preventDefault() и e.stopPropagation(), .stopImmediatePropagation()?**

- `.preventDefault()` отключает поведение элемента по умолчанию. Если использовать этот метод в элементе
  form, то он предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет
  отключено (данный метод часто используется в keydown для переопределения клавиатуры, например, при создании
  музыкального/видео плеера или текстового редактора — прим. пер.).

- `.stopPropagation()` отключает распространение события (его всплытие или погружение).

- `.stopImmediatePropagation()`: останавливает дальнейшее распространение события и предотвращает выполнение
  других обработчиков на том же элементе.

## 117. **Как узнать об использовании метода event.preventDefault()?**
Чтобы определить, вызван ли метод `preventDefault`, можно проверить свойство `defaultPrevented` объекта события:

```javascript
handleEvent(e)
{
    if (e.defaultPrevented) {
        console.log('preventDefault был вызван');
    }
}
```

## 118. **Разница между event.target и event.currentTarget?**

- `event.target`: элемент, на котором произошло событие.
- `event.currentTarget`: элемент, на который назначен обработчик события (может отличаться, если используется
  делегирование событий).

## 119. **Разница между событиями load и DOMContentLoaded?**

- `load`: срабатывает, когда полностью загружен весь документ, включая все стили, изображения и другие ресурсы.
- `DOMContentLoaded`: срабатывает, когда весь HTML документ был полностью загружен и разобран, но до загрузки
  стилей, изображений и других ресурсов.

## 120. **Сколько аргументов принимает addEventListener?**

Метод `addEventListener` принимает три аргумента:
1. Тип события (строка).
2. Обработчик события (функция).
3. Опции (необязательный объект или логическое значение, указывающее, должно ли событие быть захваченным или
   всплывающим).

## 121. **Разница между innerHTML и outerHTML?**

- `innerHTML`: возвращает или устанавливает HTML-контент внутри элемента.
- `outerHTML`: возвращает или устанавливает HTML-контент элемента, включая сам элемент.

## 122. **Для чего используется свойство window.navigator?**

Свойство `window.navigator` предоставляет информацию о браузере и операционной системе пользователя, включая имя
браузера, версию, язык и платформу.

## 123. **Для чего используется метод .focus()?**

Метод `.focus()` используется для установки фокуса на элементе формы или вводе текста, чтобы пользователь мог начать
взаимодействие с ним сразу.

## 124. **Для чего используется свойство .forms?**

Свойство `.forms` объекта `document` возвращает коллекцию всех форм в документе.

## 125. **Для чего используется метод .scrollIntoView()?**

Метод `.scrollIntoView()` прокручивает элемент так, чтобы он оказался видимым в области просмотра. Это может быть
полезно для приведения элемента в фокус.

## 126. **Разница между методами .submit() и .requestSubmit()?**

- `.submit()`: отправляет форму, обходя валидацию HTML5 и обработчики события `submit`.
- `.requestSubmit()`: отправляет форму, включая валидацию HTML5 и вызов обработчиков события `submit`.

## 127. **Расскажите о IntersectionObserver?**

`IntersectionObserver` позволяет асинхронно наблюдать за пересечением элемента с областью видимости. Это полезно для
реализации ленивой загрузки изображений или триггеров для анимаций.

Пример:
```javascript
let observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      console.log('Элемент видим!');
    }
  });
});

observer.observe(document.querySelector('#myElement'));
```

## 128. **Расскажите о URLSearchParams?**

`URLSearchParams` предоставляет интерфейс для работы с параметрами строки запроса URL. Он позволяет легко читать,
изменять и добавлять параметры.

Пример:
```javascript
let params = new URLSearchParams('?name=John&age=30');
console.log(params.get('name')); // John
console.log(params.has('age'));  // true
params.append('city', 'New York');
console.log(params.toString()); // name=John&age=30&city=New+York
```

## 129. **Какие есть ограничения у window.close()?**

Метод `window.close()` может быть вызван только для окон, которые были открыты с помощью `window.open()`. Попытка
закрыть окно, которое не было открыто скриптом, может быть заблокирована браузером.

## 130. **Как можно создавать пользовательское событие (custom events) в JavaScript?**

Создание пользовательского события с помощью `CustomEvent`:
```javascript
let event = new CustomEvent('myEvent', { detail: { key: 'value' } });
element.dispatchEvent(event);
```

## 131. **Расскажите о методе requestAnimationFrame()?**

`requestAnimationFrame()` позволяет запланировать выполнение функции перед следующим перерисовыванием экрана. Это
эффективный способ для реализации анимаций, так как браузер оптимизирует их выполнение, чтобы избежать лишних
перерисовок.

Пример:
```javascript
function animate() {
  // обновить состояние анимации
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
```

## 132. **Для чего используется свойство .dataset?**

Свойство `.dataset` в JavaScript используется для работы с пользовательскими атрибутами данных (data attributes) HTML-элементов. Эти атрибуты позволяют хранить дополнительную информацию в элементах без необходимости использования дополнительных классов или идентификаторов.

### `Основные моменты о .dataset:`

1. **`Синтаксис`**: Чтобы получить доступ к данным, заданным через атрибуты `data-*`, вы можете использовать `element.dataset`. Например, если у вас есть элемент с атрибутом `data-user-id`, вы можете получить его значение как `element.dataset.userId`.

2. **`Автоматическое преобразование`**: Имена атрибутов преобразуются в camelCase. Например:
- `data-user-name` будет доступен как `element.dataset.userName`.
- `data-item-count` будет доступен как `element.dataset.itemCount`.

3. **`Чтение и запись`**: Вы можете как читать, так и записывать данные с помощью `.dataset`. Например:
```javascript
const element = document.querySelector('#myElement');
console.log(element.dataset.userId); // Чтение
element.dataset.userId = '123'; // Запись
```

4. **`Полезно для динамических данных`**: `.dataset` удобно использовать для хранения и передачи данных между JavaScript и HTML, особенно в интерактивных веб-приложениях.

Пример:

```html
<div id="myElement" data-user-id="42" data-user-name="Антон"></div>

<script>
  const element = document.getElementById('myElement');
  console.log(element.dataset.userId); // '42'
  console.log(element.dataset.userName); // 'Антон'

  // Изменение значения
  element.dataset.userId = '99';
  console.log(element.dataset.userId); // '99'
</script>
```

## 133. **Какие существуют методы для хранения данных в браузере?**

`LocalStorage` и `SessionStorage` используются для хранения пар ключ-значение. Данные, сохраненные в них, сохраняются после обновления страницы. При этом только LocalStorage может сохранять данные после перезапуска браузера. Оба хранилища могут использовать только строки в качестве ключей и значений, поэтому объекты необходимо преобразовать с помощью JSON.stringify().

`Cookie` – небольшие строки данных, которые хранятся в браузере. Cookie обычно устанавливаются веб-сервером с использованием заголовка Set-Cookie. Браузер затем автоматически добавляет их почти ко всем запросам на тот же домен с использованием заголовка Cookie. Один экземпляр cookie может содержать до 4 кб данных. В зависимости от браузера, допускается более 20 cookie на сайт.

`IndexedDB` – встроенная база данных, более мощная, чем LocalStorage. Это NoSQL-хранилище данных в формате JSON внутри браузера, где доступны несколько типов ключей, а значения могут быть практически любым. IndexedDB поддерживает асинхронный доступ, транзакции для обеспечения согласованности данных и создание индексов для эффективного поиска. Позволяет хранить больше данных, чем LocalStorage, может быть связана с Service Workers и другими технологиями, которые обеспечивают функционирование PWA в оффлайне.
# **React**

## 1.  **Что такое React?**(Требуется доработка)

`React` — это JavaScript библиотека для создания пользовательских интерфейсов, разработанная Facebook в 2011. Она
позволяет разработчикам строить
интерфейсы, разделяя их на компоненты и упрощая управление состоянием приложения.

### Особенности React:

1. **`Компонентный подход`**: React основан на создании компонентов — небольших, повторно используемых блоков кода,
   которые инкапсулируют логику, разметку и стиль.
2. **`Виртуальный DOM`**: React использует Virtual DOM, чтобы эффективно обновлять и перерисовывать изменения в
   интерфейсе. Это повышает производительность по сравнению с прямыми манипуляциями с реальным DOM.
3. **`Односторонняя привязка данных (One-way data binding)`**: Данные в React передаются от родительских компонентов к
   дочерним через свойства (props), что делает поток данных предсказуемым и управляемым.
4. **`JSX`**: React использует JSX — расширение синтаксиса JavaScript, которое позволяет писать код, похожий на HTML,
   прямо в JavaScript, что упрощает работу с разметкой в компонентах.
5. **`Функциональные и классовые компоненты`**: В React можно использовать как классовые, так и функциональные
   компоненты.
   Современные версии React отдают предпочтение функциональным компонентам благодаря хукам.
6. **`Хуки (Hooks)`**: React предоставляет хуки, такие как `useState`, `useEffect`, `useContext`, которые позволяют
   управлять состоянием и побочными эффектами в функциональных компонентах, заменяя классы.
7. **`Одностраничные приложения (SPA)`**: React идеально подходит для создания SPA, где вся навигация происходит без
   перезагрузки страницы, обеспечивая быстрый и плавный пользовательский интерфейс.
8. **`Контроль состояния`**: React поддерживает управление состоянием как внутри компонентов, так и через внешние
   библиотеки, такие как Redux или Context API.
9. **`Обширная экосистема`**: Вокруг React сформировалась большая экосистема, включающая различные библиотеки для
   управления состоянием, маршрутизации, тестирования и стилизации компонентов.

## 2. **Что такое React Fiber?**

`React Fiber` — это новая архитектура внутреннего механизма рендеринга в React, представленная в версии React 16. Она
заменила предыдущую реализацию, известную как "React Stack". Основная цель React Fiber — улучшить производительность и
управляемость рендеринга за счет приоритизации задач.

### Особенности React Fiber:

1. **Асинхронный рендеринг (Concurrent Mode)**:
   Fiber поддерживает асинхронный рендеринг, что позволяет React разбивать большие задачи на мелкие части и выполнять их
   поэтапно. Это особенно важно для улучшения отзывчивости пользовательского интерфейса, поскольку теперь React может
   приостанавливать работу над менее приоритетными задачами и продолжать их выполнение позже, чтобы интерфейс оставался
   отзывчивым.

2. **Приоритизация задач**:
   Fiber позволяет назначать приоритеты для различных задач рендеринга. Например, обновления пользовательского ввода
   могут быть выполнены быстрее, чем обновления, не влияющие напрямую на пользовательский интерфейс (UI).

3. **Инкрементальное обновление**:
   React теперь может разделять обновления на части и обновлять компоненты поэтапно, не блокируя основной поток. Это
   позволяет улучшить перформанс, особенно в сложных приложениях с большим количеством компонентов.

4. **Переработанная структура работы с виртуальным DOM**:
   Fiber реализует более гибкую и детализированную модель работы с виртуальным DOM. Это позволяет более точно
   отслеживать изменения, их влияние на производительность и управлять рендерингом на более глубоком уровне.

Fiber улучшает возможности React в создании сложных и интерактивных приложений, особенно в сценариях с тяжелыми
операциями рендеринга и необходимостью быстрого отклика на пользовательские действия.

## 3. **Что такое Virtual DOM? Как он работает с React?** (Устарело)

`Virtual DOM (виртуальный DOM)` — это легковесная копия реального DOM-дерева в памяти, которая используется в
React для повышения производительности веб-приложений.

**Как работает Virtual DOM в React:**

1. **Создание виртуального представления**: Когда компонент React рендерится, создаётся его виртуальная копия в памяти.
   Этот виртуальный DOM — это JavaScript-объекты, которые отражают структуру UI, но не взаимодействуют напрямую с
   реальным DOM.
2. **Обновление виртуального DOM**: При изменении состояния (state) или пропсов (props) компонента создаётся новое
   виртуальное DOM-дерево, которое представляет обновлённый UI.
3. **Сравнение с предыдущей версией**: React использует алгоритм "reconciliation" (согласование), который сравнивает
   новое виртуальное DOM-дерево с предыдущей версией. Этот процесс называется **diffing**. React определяет, какие части
   виртуального DOM изменились.
4. **Минимальные изменения в реальном DOM**: После нахождения различий между старым и новым виртуальным DOM, React
   применяет только те изменения, которые необходимы, к реальному DOM. Это делает обновления эффективными и минимизирует
   количество взаимодействий с реальным DOM, которые могут быть дорогими с точки зрения производительности.

## 4. **Все о хуках?**

`Хуки` — это функции, которые позволяют использовать состояние и другие возможности React без необходимости писать классовые компоненты.

### Базовые:

1. `useState` управления состоянием в функциональных компонентах.

2. `useEffect` выполнения побочных эффектов в функциональных компонентах.

3. `useLayoutEffect` выполнения побочных эффектов подобно useEffect, с той разницей, что эффект запускается синхронно после всех мутаций DOM.

4. `useRef`	создания изменяемых ссылок на элементы или значения, которые сохраняются во время рендеринга.

5. `useContext`	доступа к значению контекста React в функциональном компоненте.

6. `useReducer` управления состоянием с помощью функции reducer, аналогично тому, как это делается в Redux.

8. `useCallback` мемоизации функций для предотвращения ненужных повторных рендеров.

### **Правила (ограничения) использования хуков:**

1. **`Только в функциональных компонентах и кастомных хуках`**: Хуки можно использовать только в функциональных
   компонентах или других кастомных хуках. Нельзя использовать хуки в обычных JavaScript-функциях или в классовых
   компонентах.

2. **`Вызов хуков только на верхнем уровне`**: Хуки должны быть вызваны на верхнем уровне вашего компонента. Это означает,
   что их нельзя вызывать внутри циклов, условий или вложенных функций. Это позволяет React правильно отслеживать
   порядок вызовов хуков между рендерами.

3. **`Вызов хуков в одном и том же порядке`**: Хуки должны быть вызваны в одном и том же порядке при каждом рендере
   компонента. Это также помогает React корректно сопоставлять состояние и эффекты между рендерами.

4. **`Использование` `useEffect`, `useState`, и других хуков**: `useEffect` и `useState` являются наиболее часто
   используемыми хуками, но существуют и другие встроенные хуки, такие как `useContext`, `useReducer`, и `useCallback`,
   которые следует использовать в соответствии с их предназначением.

5. **`Соблюдение правил вызова хуков`**: Кастомные хуки могут быть использованы внутри других кастомных хуков, при этом
   важно соблюдать правила вызова хуков. Это позволяет создавать более сложные и переиспользуемые логики.

### **Преимущества:**

1. **`Упрощение кода`**: Хуки позволяют избегать использования классов и упрощают написание компонентов. Это делает код
   более читаемым и удобным для поддержки.

2. **`Переиспользуемость логики`**: Хуки позволяют легко переиспользовать логику между компонентами без необходимости
   создания высоких порядковых компонентов или использования сложных паттернов.

3. **`Чистота и организация кода`**: Хуки могут помочь организовать код, разбивая его на маленькие части, что делает его
   более управляемым. Например, можно выделить отдельные хуки для работы с состоянием или эффектами.

4. **`Гибкость`**: Хуки дают возможность использовать состояния и эффекты в функциональных компонентах, что делает их
   более гибкими. Например, `useEffect` позволяет выполнять побочные эффекты, а `useReducer` может использоваться для
   управления сложными состояниями.

5. **`Лучшее управление состоянием`**: `useState` и `useReducer` позволяют управлять состоянием компонента более удобно и
   эффективно.

6. **`Отсутствие проблемы this`**: В функциональных компонентах, использующих хуки, нет необходимости работать с
   контекстом `this`, что упрощает работу с состоянием и методами.

7. **`Оптимизация производительности`**: Хуки вроде `useMemo` и `useCallback` позволяют оптимизировать производительность,
   предотвращая ненужные перерисовки и вычисления.

### **Недостатки:**

1. **`Сложность понимания`**: Для новичков хуки могут быть сложными для понимания, особенно если проект использует сложные
   кастомные хуки или большое количество зависимостей. Проблемы могут возникать из-за непонимания
   работы `useEffect`, `useCallback`, `useMemo` и других хуков.

2. **`Проблемы с производительностью`**: Неправильное использование хуков, таких как `useMemo` и `useCallback`, может
   привести к ухудшению производительности, если они используются без должной необходимости или неправильно настроены.

3. **`Более сложные компоненты`**: В больших компонентах использование хуков может привести к запутанности и трудностям в
   поддержке кода. Например, если `useEffect` и другие хуки используются без четкой структуры, это может усложнить
   отслеживание логики компонента.

4. **`Сложность тестирования`**: Хуки могут усложнить тестирование компонентов, особенно если они имеют сложные состояния
   или зависимости. Хотя это не является неразрешимой проблемой, написание тестов для компонентов с хуками может
   потребовать дополнительных усилий.

5. **`Отсутствие четкой структуры`**: Хуки позволяют писать логику прямо внутри компонентов, что может привести к тому,
   что компоненты будут содержать большое количество кода, связанного с состоянием и эффектами. Это может затруднить
   организацию и поддержку кода.

## 5. **Что Такое JSX?**

`JSX (JavaScript XML)` — это синтаксический сахар для описания структуры UI в JavaScript, который позволяет писать
HTML-подобный код внутри JavaScript-файлов.

## 6. **Для чего нужен атрибут key при рендере списков?**

`Атрибут key` используется React для идентификации элементов в списке. Это помогает React более эффективно обновлять и
перерисовывать только измененные элементы списка, минимизируя затраты на рендеринг.

## 7. **Что такое Компонент высшего порядка (Higher-Order Component/HOC)?**

`Компонент высшего порядка (Higher-Order Component, HOC)` — это паттерн, который позволяет повторно использовать
логику между разными компонентами. HOC представляет собой функцию, которая принимает компонент и возвращает новый
компонент с добавленной функциональностью.

Основная идея HOC заключается в том, чтобы «оборачивать» компоненты для добавления им дополнительных свойств или логики
без изменения исходного компонента. Это особенно полезно для повторного использования кода, управления состоянием,
работы с побочными эффектами и т. д.

**Пример использования HOC:**

```jsx
// Функция HOC
const withLogging = (WrappedComponent) => {
    return (props) => {
        console.log('Props:', props);
        return <WrappedComponent {...props} />;
    };
};

// Компонент, который мы оборачиваем
const MyComponent = ({message}) => {
    return <div>{message}</div>;
};

// Использование HOC для оборачивания компонента
const MyComponentWithLogging = withLogging(MyComponent);

// В рендере
<MyComponentWithLogging message="Hello, HOC!"/>
```

В этом примере `withLogging` — это HOC, который оборачивает `MyComponent`, добавляя вывод логов для всех пропсов,
переданных в компонент.

Важно отметить, что HOC не изменяет или не мутирует оригинальный компонент; он создает новый компонент с добавленными
возможностями.

## 8. **Разница между управляемыми (controlled) и не управляемыми (uncontrolled) компонентами?**

В React `управляемые (controlled) и неуправляемые (uncontrolled) компоненты` отличаются подходом к управлению состоянием
ввода.

1. **Управляемые компоненты (Controlled Components)**: Управляемый компонент получает свое значение и обновляет его
   через `props`, а его состояние полностью контролируется компонентом. Например, для управления полем ввода
   используется состояние в компоненте, а значение обновляется через обработчик событий.

**Пример:**

```jsx
function ControlledInput() {
    const [inputValue, setInputValue] = useState('');

    const handleChange = (e) => {
        setInputValue(e.target.value);
    };

    return (
        <input
            type="text"
            value={inputValue}
            onChange={handleChange}
        />
    );
}
```

- Состояние (`inputValue`) полностью контролируется React-компонентом.
- Любые изменения происходят через обновление состояния компонента, что делает его предсказуемым и синхронизированным с
  React.

2. **Неуправляемые компоненты (Uncontrolled Components)**: Неуправляемый компонент хранит свое внутреннее состояние
   самостоятельно, вне контроля React. Обычно они используют ссылки (`ref`) для доступа к DOM-элементу и его значению
   напрямую.

**Пример:**

```jsx
function UncontrolledInput() {
    const inputRef = useRef(null);

    const handleSubmit = () => {
        console.log(inputRef.current.value);
    };

    return (
        <>
            <input type="text" ref={inputRef}/>
            <button onClick={handleSubmit}>Submit</button>
        </>
    );
}
```

- Состояние инпута здесь не контролируется React, а доступ к значению происходит через прямой доступ к DOM.
- Такие компоненты могут быть полезны, если нет необходимости в частом обновлении состояния.

### Основные различия:

- **Управляемые компоненты:** React контролирует состояние, что делает компонент более предсказуемым и
  синхронизированным с общим состоянием приложения.
- **Неуправляемые компоненты:** Ввод напрямую управляется DOM, и доступ к значению осуществляется через ссылки, что
  может быть полезно для оптимизации производительности в отдельных случаях.

## 9. **Методы жизненного цикла компонента в React?**

В React методы жизненного цикла компонента помогают управлять поведением компонента на разных этапах его существования.
Для классовых компонентов используются следующие методы жизненного цикла:

1. **`constructor(props)`**: Вызывается при создании компонента. Используется для инициализации состояния и привязки
   методов.

2. **`static getDerivedStateFromProps(nextProps, prevState)`**: Вызывается перед рендерингом, как при обновлении, так и
   при создании компонента. Позволяет обновить состояние в ответ на изменения свойств.

3. **`componentDidMount()`**: Вызывается сразу после монтирования компонента в DOM. Полезен для загрузки данных или
   выполнения побочных эффектов.

4. **`shouldComponentUpdate(nextProps, nextState)`**: Вызывается перед обновлением компонента. Позволяет оптимизировать
   производительность, определяя, нужно ли перерисовывать компонент.

5. **`render()`**: Метод рендеринга, который возвращает JSX, описывающее, как должен выглядеть компонент.

6. **`componentDidUpdate(prevProps, prevState)`**: Вызывается сразу после обновления компонента. Используется для
   выполнения побочных эффектов после изменения состояния или свойств.

7. **`componentWillUnmount()`**: Вызывается непосредственно перед размонтированием компонента из DOM. Подходит для
   очистки ресурсов или отмены подписок.

8. **`componentDidCatch(error, info)`**: Вызывается при ошибке в любом дочернем компоненте. Используется для обработки
   ошибок и логирования.

## 10. **Стадии жизненного цикла компонента в React?**

В React жизненный цикл компонента включает несколько стадий, которые можно разделить на три основные фазы: **`монтирование`**, **`обновление`** и **`размонтирование`**. Каждая из них имеет свои методы жизненного цикла, которые вызываются в определённые моменты.

### 1. Монтирование (Mounting)
Это фаза, когда компонент создаётся и вставляется в DOM.
- **`constructor(props)`** — вызывается перед монтированием компонента, используется для инициализации состояния и привязки методов.
- **`static getDerivedStateFromProps(props, state)`** — вызывается перед каждым рендером, в том числе и на стадии монтирования. Используется для синхронизации состояния с изменениями в props.
- **`render()`** — единственный обязательный метод. Возвращает JSX, который описывает UI компонента.
- **`componentDidMount()`** — вызывается сразу после монтирования компонента в DOM. Здесь обычно выполняются побочные эффекты (например, запросы к API).

### 2. Обновление (Updating)
Происходит при изменении props или состояния компонента.
- **`static getDerivedStateFromProps(props, state)`** — вызывается перед каждым рендером при обновлении.
- **`shouldComponentUpdate(nextProps, nextState)`** — позволяет предотвратить перерисовку компонента. Возвращает `true` (по умолчанию) или `false`.
- **`render()`** — перерисовывает компонент на основе новых данных.
- **`getSnapshotBeforeUpdate(prevProps, prevState)`** — вызывается перед обновлением в DOM и может использоваться для получения данных до самого обновления (например, позиция прокрутки).
- **`componentDidUpdate(prevProps, prevState, snapshot)`** — вызывается после обновления компонента в DOM. Здесь можно совершить действия на основе изменений.

### 3. Размонтирование (Unmounting)
Когда компонент удаляется из DOM.
- **`componentWillUnmount()`** — вызывается перед размонтированием компонента. Используется для очистки ресурсов (таймеров, подписок и т.д.).

### Дополнительные методы:
- **`componentDidCatch(error, info)`** — используется для обработки ошибок, возникших в процессе рендеринга дочерних компонентов.
- **`static getDerivedStateFromError(error)`** — вызывается при возникновении ошибки в компоненте. Позволяет обновить состояние на основе ошибки.

## 11. **Что такое портал (Portal)?**

`Портал (Portal)` — это способ рендеринга дочерних компонентов в произвольном месте в DOM, вне родительского компонента, в
котором они объявлены. Это полезно, когда нужно поместить элемент в другой DOM-узел, например, для модальных окон,
всплывающих подсказок или других элементов, которые должны отображаться поверх остального контента.

## 12. **Что такое контекст (Context)?**

`В React контекст (Context)` — это способ передавать данные через дерево компонентов, минуя промежуточные компоненты. Это
полезно, когда некоторые данные или функции должны быть доступны многим компонентам на разных уровнях дерева, но
передача их через пропсы на каждом уровне может быть трудоемкой и неэффективной.

### Основные элементы контекста:

1. **Создание контекста**: Используйте `React.createContext` для создания контекста. Это возвращает объект с двумя
   компонентами: `Provider` и `Consumer`.

    ```jsx
    const MyContext = React.createContext(defaultValue);
    ```

2. **Provider**: Компонент `Provider` предоставляет данные контекста для всех дочерних компонентов. Он принимает
   проп `value`, который будет доступен для всех потребителей контекста.

    ```jsx
    <MyContext.Provider value={/* значение контекста */}>
      {/* дочерние компоненты */}
    </MyContext.Provider>
    ```

3. **Consumer**: Компонент `Consumer` позволяет компонентам получать данные из контекста. С помощью функции как
   ребенка (render prop) вы можете получить доступ к данным контекста.

    ```jsx
    <MyContext.Consumer>
      {/*{value =>  использование значения контекста }*/}
    </MyContext.Consumer>
    ```

4. **useContext**: С React 16.8 и выше можно использовать хук `useContext` для доступа к контексту в функциональных
   компонентах.

    ```jsx
    const value = useContext(MyContext);
    ```

### Пример использования контекста:

```jsx
// Создание контекста
const LanguageContext = React.createContext('en');

// Компонент Provider
const LanguageProvider = ({children}) => {
    const [language, setLanguage] = React.useState('en');

    return (
        <LanguageContext.Provider value={{language, setLanguage}}>
            {children}
        </LanguageContext.Provider>
    );
};

// Компонент Consumer
const Greeting = () => {
    const {language} = React.useContext(LanguageContext);

    return <h1>{language === 'en' ? 'Hello!' : '¡Hola!'}</h1>;
};

// Использование
const App = () => (
    <LanguageProvider>
        <Greeting/>
    </LanguageProvider>
);
```

## 13. **Разница между состоянием(state) и пропсами(props)?**

В React `state` и `props` — это два ключевых концепта для управления данными и их отображением в компонентах. Вот
основные различия между ними:

1. **Свойство (props)**:
    - **Передача данных**: `props` (свойства) передаются в компонент извне, то есть родительский компонент передает
      данные дочернему компоненту.
    - **Неизменяемость**: Компонент не должен изменять свои `props`. Если нужно изменить данные, их нужно передать снова
      от родительского компонента.
    - **Использование**: Используются для настройки компонента и передачи данных от родителя к ребенку.

2. **Состояние (state)**:
    - **Локальное состояние**: `state` — это локальное состояние компонента, которое управляется самим компонентом.
      Компонент может изменять свое состояние с помощью функции обновления состояния.
    - **Изменяемость**: Компонент может изменять свое состояние, что приводит к перерисовке компонента с новыми данными.
    - **Использование**: Используется для хранения и управления данными, которые могут изменяться в процессе работы
      компонента (например, форма, счетчик, данные от API и т.д.).

Пример:

```jsx
// Родительский компонент
function ParentComponent() {
    const [value, setValue] = useState('Hello');

    return <ChildComponent value={value} onChange={setValue}/>;
}

// Дочерний компонент
function ChildComponent({value, onChange}) {
    return (
        <div>
            <p>{value}</p>
            <button onClick={() => onChange('World')}>Change</button>
        </div>
    );
}
```

В этом примере `value` и `onChange` — это `props`, которые передаются из родительского компонента в
дочерний. `ChildComponent` использует их для отображения данных и обновления их при нажатии на кнопку.

## 14. **Что такое фрагмент (Fragment)? Почему фрагмент лучше, чем div?**

`Фрагмент (Fragment) в React` — это специальный элемент в React, позволяющий возвращать группу элементов без
дополнительного родительского DOM элемента.

Вот основные преимущества использования `Fragment` по сравнению с `div`:

1. **Отсутствие лишних узлов в DOM**: Используя `Fragment`, вы избегаете добавления лишних `div`-ов или других
   контейнеров в DOM. Это помогает поддерживать чистоту и простоту структуры HTML и может улучшить производительность.

2. **Семантическая чистота**: Когда вы используете только `Fragment`, ваша структура HTML остается семантически чистой,
   потому что вы избегаете ненужных элементов, которые могут затруднить чтение и понимание разметки.

3. **Упрощение стилей**: Избежание добавления лишних элементов помогает предотвратить возможные проблемы с CSS,
   связанные с дополнительными обертками, которые могут влиять на стили и макет.

## 15. **Что такое синтетические события в React?**

`В React синтетические события` — это обертка над нативными событиями браузера. Они создаются React для обеспечения
кросс-браузерной совместимости и улучшения производительности. Вот несколько ключевых моментов о синтетических событиях:

1. **Кросс-браузерная совместимость**: Синтетические события предоставляют единый интерфейс для событий, который
   работает одинаково во всех поддерживаемых браузерах, избегая различий в реализации событий между браузерами.

2. **Упрощение работы с событиями**: Синтетические события обеспечивают такие же свойства и методы, как и нативные
   события, например, `event.target`, `event.currentTarget`, `event.preventDefault()`, и `event.stopPropagation()`.

3. **Пул событий**: React использует пул событий, чтобы уменьшить количество объектов событий, создаваемых при каждом
   событии. Это позволяет эффективно управлять памятью. После того как событие обработано, React возвращает его в пул,
   что означает, что доступ к свойствам события возможен только внутри обработчика.

4. **Проброс событий**: Синтетические события поддерживают концепцию проброса событий (event bubbling), то есть они
   проходят через цепочку элементов от целевого элемента до корня дерева.

Пример использования синтетического события:

```jsx
function handleClick(event) {
    // Событие здесь будет синтетическим
    console.log(event.type); // 'click'
    console.log(event.target); // Целевой элемент
}

function App() {
    return (
        <button onClick={handleClick}>Click me</button>
    );
}
```

## 16. **Что такое React-ссылка (ref)? Как создать ссылку?**

`В React ref (или ссылка)` — это способ получить доступ к DOM-узлам, созданным с помощью React,
напрямую, а не через состояние или пропсы.

**Ситуации, в которых использование рефов является оправданным:**

- Управление фокусом
- Выделение текста
- Вызов scrollTo
- Вызов анимаций
- Интеграция со сторонними DOM-библиотеками
- Другие случаи

В рефах можно хранить любое значение, а не обязательно ссылку на элемент. **Изменение поля ref.current не приводит к
реренденру компонента.**

## 17. **Что такое условный рендеринг (Conditional Rendering)? Как его выполнить?**

`Условный рендеринг` позволяет отображать компоненты или элементы в зависимости от условий. Это можно сделать с помощью
условных операторов (`if`, тернарный оператор) внутри метода рендера или функции.

## 18. **Разница между React и ReactDOM?**

- **`React`**: Библиотека для создания компонентов и управления состоянием.
- **`ReactDOM`**: Библиотека, которая отвечает за рендеринг React-компонентов в реальный DOM.

## 19. **Разница между элементом и компонентом?**

- **`Элемент`**: Основной строительный блок React, описывающий, что отображается на экране (например, `<div>`).
- **`Компонент`**: Функция или класс, возвращающий элемент или элементы для отображения.

## 20. **Разница между компонентом и контейнером?**

- **`Компонент`**: Переиспользуемая часть UI, которая может быть как визуальным элементом, так и логическим элементом.
- **`Контейнер`**: Компонент, который управляет состоянием и передачей данных другим компонентам. Часто служит для
  управления состоянием и логикой.

## 21. **Что такое строгий режим в React? Его преимущества?**

`Строгий режим (<React.StrictMode>)` помогает выявлять потенциальные проблемы в приложении, такие как устаревшие API и
небезопасные методы. Он активирует дополнительные проверки и предупреждения в режиме разработки.

## 22. **Что такое «бурение пропсов» (Prop Drilling)? Как его избежать?**

`Бурение пропсов` — это процесс передачи данных от родительского компонента через несколько уровней дочерних компонентов.
Это можно избежать, используя контекст или менеджера состояния.

## 23. **Что такое «опрос» (Polling)? Как его реализовать в React?**

`Опрос (Polling)` — это метод регулярного получения данных от сервера. Реализуется с помощью `setInterval` для периодического вызова
API в компоненте и обновления состояния.

## 24. **Что такое сhildren?**

`children` — это специальный пропс, который используется для передачи вложенных элементов или компонентов в компонент.
Он позволяет создавать компоненты с гибкой структурой.

## 25. **Что такое инверсия наследования (Inheritance Inversion)?**

`Инверсия наследования (Inheritance Inversion)` — это концепция, связанная с изменением подхода к проектированию
компонентов, чтобы уменьшить зависимость от классов и наследования. Вместо использования классов и наследования, React
рекомендует использовать композицию и функции для достижения нужной функциональности.

### Основные моменты:

1. **Композиция вместо наследования:** Вместо создания иерархий классов, которые могут усложнить структуру и
   тестирование кода, React советует использовать композицию компонентов. Это позволяет создавать более гибкие и
   переиспользуемые компоненты.

2. **Функциональные компоненты и хуки:** В современных версиях React предпочтение отдается функциональным компонентам и
   хукам вместо классовых компонентов. Хуки позволяют "вытягивать" логику из компонентов без необходимости наследования.

3. **Высший порядок компоненты (HOC) и Render Props:** Эти паттерны также поддерживают инверсию наследования,
   обеспечивая возможность динамического добавления функциональности компонентам без использования наследования.

**Примеры:**

- **Композиция:** Вместо создания базового компонента и нескольких дочерних классов, вы можете создать несколько мелких
  функциональных компонентов и комбинировать их по мере необходимости.

- **Хуки:** Вместо создания базового класса с методами жизненного цикла, вы можете использовать хуки, такие
  как `useEffect`, для управления побочными эффектами.

Вот простой пример использования композиции:

```jsx
// Вместо наследования
class Button extends React.Component {
    render() {
        return (
            <button>
                {this.props.label}
            </button>
        );
    }
}

class IconButton extends Button {
    render() {
        return (
            <button>
                <i className="icon"/>
                {this.props.label}
            </button>
        );
    }
}

// Используем композицию
const Button = ({label}) => (
    <button>
        {label}
    </button>
);

const IconButton = ({label}) => (
    <div>
        <i className="icon"/>
        <Button label={label}/>
    </div>
);
```

Здесь `IconButton` использует `Button` как часть своей композиции, а не наследует его.

Использование композиции и функциональных компонентов делает код более гибким и поддерживаемым.

## 26. **Как в React реализовать двустороннее связывание данных?**

`Двустороннее связывание данных (two-way data binding)` можно реализовать с помощью контролируемых компонентов.
Это процесс, когда изменения в интерфейсе пользователя (например, в форме) обновляют состояние компонента, и, наоборот,
изменения в состоянии компонента обновляют интерфейс.

**Шаги для реализации двустороннего связывания:**

1. **Создание состояния для хранения данных.**
   Используйте хук `useState`, чтобы создать состояние для отслеживания данных в форме.

2. **Привязка значения к элементу формы.**
   Установите значение элемента формы (например, `input`) равным состоянию компонента.

3. **Обработка изменений.**
   Используйте обработчик событий (например, `onChange`), чтобы обновлять состояние при изменении значения элемента
   формы.

### Пример:

```jsx
import React, {useState} from 'react';

function MyForm() {
    // Состояние для отслеживания значения инпута
    const [inputValue, setInputValue] = useState('');

    // Обработчик для обновления состояния при изменении инпута
    const handleInputChange = (event) => {
        setInputValue(event.target.value);
    };

    return (
        <div>
            {/* Привязка состояния к значению инпута и обработка изменений */}
            <input
                type="text"
                value={inputValue}
                onChange={handleInputChange}
            />
            <p>Вы ввели: {inputValue}</p>
        </div>
    );
}

export default MyForm;
```

### Как это работает:

1. Поле ввода получает значение из состояния `inputValue` через атрибут `value`.
2. Когда пользователь вводит текст, вызывается функция `handleInputChange`, которая обновляет состояние с
   помощью `setInputValue`.
3. Обновлённое состояние снова передаётся в компонент, что приводит к обновлению значения в элементе `input`.

Таким образом, изменения в интерфейсе (ввод текста) обновляют состояние, а изменения в состоянии обновляют интерфейс.
Это и есть двустороннее связывание данных в React.

## 27. **Разница между классовым и функциональным компонентами?**

- **`Классовые компоненты`**: Используют классы для определения компонентов, поддерживают методы жизненного цикла и могут
  использовать состояние.
- **`Функциональные компоненты`**: Определяются как функции и могут использовать хуки для управления состоянием и
  побочными эффектами.

## 28. **Что такое поднятие состояния вверх (Lifting State Up)?**

`Поднятие состояния вверх (Lifting State Up)` — это паттерн, который используется, когда нескольким компонентам
нужно делиться одним и тем же состоянием. Вместо того чтобы хранить состояние в каждом из этих компонентов отдельно,
состояние поднимается в ближайший общий родительский компонент, который может управлять им и передавать его как пропсы
дочерним компонентам.

### Пример:

Допустим, у нас есть два компонента, которые должны работать с одним и тем же состоянием, скажем, с состоянием `count`.
Один компонент должен отображать текущее значение, а другой — изменять его.

1. **Дочерние компоненты**:
    - Один компонент отображает значение.
    - Второй компонент изменяет его.

2. **Поднятие состояния**: Вместо того, чтобы оба компонента управляли своим состоянием независимо, состояние `count`
   хранится в родительском компоненте. Родитель передаёт его значение и функции для изменения состояния через пропсы
   дочерним компонентам.

```jsx
// Родительский компонент
function ParentComponent() {
    const [count, setCount] = useState(0);

    return (
        <div>
            <DisplayComponent count={count}/>
            <ChangeComponent setCount={setCount}/>
        </div>
    );
}

// Компонент для отображения значения
function DisplayComponent({count}) {
    return <div>Current count: {count}</div>;
}

// Компонент для изменения значения
function ChangeComponent({setCount}) {
    return <button onClick={() => setCount((prev) => prev + 1)}>Increment</button>;
}
```

В этом примере состояние `count` хранится в родительском компоненте `ParentComponent`, а его значение и функция для
изменения передаются дочерним компонентам `DisplayComponent` и `ChangeComponent` через пропсы.

Таким образом, если состояние нужно нескольким компонентам, оно управляется из одного места, что делает код более
предсказуемым и структурированным.

## 29. **Разница между createElement() и cloneElement()?**

`createElement()` и `cloneElement()` — это методы из библиотеки React, но они выполняют разные функции:

1. **`createElement()`**:
    - Используется для создания нового элемента React.
    - Формат вызова: `React.createElement(type, props, ...children)`.
    - `type` — это тип элемента (например, строка для HTML-элемента или класс/функция для пользовательского компонента).
    - `props` — объект с атрибутами и свойствами элемента.
    - `children` — дочерние элементы, которые будут вложены в создаваемый элемент.

   Пример:
   ```jsx
   const element = React.createElement('div', { className: 'my-class' }, 'Hello, world!');
   ```

   Этот код создаст элемент `<div className="my-class">Hello, world!</div>`.

2. **`cloneElement()`**:
    - Используется для создания копии существующего элемента React с возможностью изменения его свойств.
    - Формат вызова: `React.cloneElement(element, [props], [...children])`.
    - `element` — это React-элемент, который вы хотите клонировать.
    - `props` — объект с новыми или измененными свойствами, которые вы хотите применить к клонированному элементу.
    - `children` — новые дочерние элементы, которые вы хотите добавить или заменить в клонированном элементе.

   Пример:
   ```jsx
   const element = <div className="my-class">Hello, world!</div>;
   const clonedElement = React.cloneElement(element, { className: 'new-class' });
   ```

В этом примере `clonedElement` будет `<div className="new-class">Hello, world!</div>`.

Основное различие в том, что `createElement()` создает новый элемент, тогда как `cloneElement()` клонирует уже
существующий элемент с возможностью изменения его свойств и детей.

## 30. **Что такое распределенный компонент?**

`В React распределенный компонент (или "composed component")` — это компонент, который построен из нескольких других
компонентов. Такая структура позволяет разделять функциональность на более мелкие и переиспользуемые части. Это улучшает
организацию кода, облегчает его поддержку и тестирование.

Например, вместо создания одного большого компонента, который отвечает за всё, можно создать несколько меньших
компонентов и использовать их вместе:

```jsx
// Крупный компонент
const UserProfile = () => {
    return (
        <div>
            <UserAvatar/>
            <UserName/>
            <UserBio/>
        </div>
    );
};

// Меньшие компоненты
const UserAvatar = () => <img src="avatar.jpg" alt="User Avatar"/>;
const UserName = () => <h1>John Doe</h1>;
const UserBio = () => <p>This is a user bio.</p>;
```

Здесь `UserProfile` — это распределенный компонент, который использует `UserAvatar`, `UserName` и `UserBio` в своем
рендере. Такая структура упрощает работу с компонентами и делает их более гибкими.

**Пример ленивой загрузки распределенного компонента:**

```js
import React, {Suspense} from 'react';

const DistributedComponent = React.lazy(() => import('./DistributedComponent'));

function App() {
    return (
        <div>
            <Suspense fallback={<div>Loading...</div>}>
                <DistributedComponent/>
            </Suspense>
        </div>
    );
}

export default App;
```

### Преимущества распределенных компонентов:

- **Уменьшение дублирования кода**: Компонент используется в нескольких местах с разной конфигурацией.
- **Оптимизация производительности**: Компоненты загружаются только тогда, когда они действительно необходимы.
- **Упрощение управления состоянием**: Можно использовать контекст или другие подходы для передачи состояния между
  распределенными компонентами.

## 31. **Как отрендерить HTML код в React-компоненте?**

Можно использовать `dangerouslySetInnerHTML`, чтобы вставить HTML-код непосредственно в компонент. Это
позволяет вам рендерить HTML-код, который вы получили из внешнего источника или динамически сгенерировали. Однако, как
следует из названия, этот метод может представлять риски безопасности, такие как XSS-атаки, если HTML-код не был должным
образом очищен или проверен.

Вот пример использования `dangerouslySetInnerHTML`:

```jsx
import React from 'react';

const HtmlRenderer = ({html}) => {
    return (
        <div dangerouslySetInnerHTML={{__html: html}}/>
    );
};

export default HtmlRenderer;
```

В этом примере компонент `HtmlRenderer` принимает строку `html` в качестве пропса и вставляет её как HTML в `div`.
Убедитесь, что HTML-код, который вы вставляете, безопасен и не содержит потенциальных уязвимостей.

## 32. **Разница между memo и useMemo?**

`memo` и `useMemo` — это две разные вещи в React, которые служат для оптимизации производительности, но используются в
разных контекстах.

**`React.memo`**:

- Это компонент высшего порядка (HOC), который предотвращает повторный рендеринг компонента, если его пропсы не
  изменились.
- Применяется к функциональным компонентам.
- Например:

```jsx
const MyComponent = React.memo((props) => {
// компонент рендерится только если props изменяются
    return <div>{props.value}</div>;
});
```

**`useMemo`**:

- Это хук, который кэширует результат вычислений, чтобы избежать повторных вычислений при каждом рендеринге компонента.
- Полезен для оптимизации производительных вычислений или создания объектов и массивов, которые зависят от пропсов или
  состояния.
- Например:

```jsx
const MyComponent = ({items}) => {
    const processedItems = useMemo(() => {
// дорогая операция
        return items.map(item => item * 2);
    }, [items]); // зависимости

    return (
        <ul>
            {processedItems.map(item => <li key={item}>{item}</li>)}
        </ul>
    );
};
```

В целом, `React.memo` используется для предотвращения лишних рендеров компонент, а `useMemo`
помогает избежать ненужных пересчетов и переопределений значений при каждом рендере.

## 33. **Является ли React реактивным?**

`Да`, но с некоторыми уточнениями. В традиционном смысле реактивного программирования (
например, в таких библиотеках, как RxJS), реактивность подразумевает работу с потоками данных и асинхронными событиями.
React же фокусируется на декларативном подходе к созданию пользовательских интерфейсов, предоставляя средства для
управления состоянием компонентов и их обновлением.

В React реактивность проявляется в том, что когда состояние компонента изменяется, React автоматически обновляет
интерфейс, чтобы отразить эти изменения. Это происходит благодаря концепции виртуального DOM, который сравнивает текущее
состояние с новым и обновляет только те части интерфейса, которые изменились.

Таким образом, React реализует свою собственную форму реактивности через обновление интерфейса на основе изменений
состояния и пропсов.

## 34. **Техники оптимизации перфоманса React?**

Оптимизация производительности в React может быть критически важной для обеспечения плавного и быстрого
пользовательского интерфейса. Вот несколько техник, которые могут помочь:

- избавиться от причин лишних ререндеров
- вынести тяжелые вычисления в отдельный поток (Web Workers)
- использовать useMemo, useCallback, React.memo для мемоизации вычислений
- избавиться от утечек памяти
- использовать атрибут key в списках
- кэшировать негорячие вычисления
- кэшировать ответы запросов сервера на N минут/секунд (применимо не всегда)
- и так далее

## 35. **Лучшие практики безопасности в React?**

Для обеспечения безопасности в приложениях на React важно учитывать несколько практик. Вот некоторые из них:

1. **Защита от XSS (Cross-Site Scripting)**:
    - Используйте библиотеку `dangerouslySetInnerHTML` осторожно. Старайтесь избегать её использования, если это
      возможно.
    - Всегда проверяйте и экранируйте пользовательский ввод.
    - Если необходимо вставлять HTML-контент, используйте библиотеки для безопасного рендеринга, такие как `dompurify`.

2. **Избегайте использования `eval` и `Function`**:
    - Не используйте функции, которые могут выполнять произвольный код. Это может создать уязвимости.

3. **Обновление зависимостей**:
    - Регулярно обновляйте библиотеки и зависимости до последних версий, чтобы быть защищённым от известных уязвимостей.

4. **Настройка CSP (Content Security Policy)**:
    - Настройте CSP для ограничения источников контента и предотвращения внедрения вредоносного кода.

5. **Безопасное управление состоянием**:
    - Избегайте хранения чувствительных данных (например, токенов) в локальном хранилище или куках. Вместо этого
      используйте более безопасные способы хранения и управления данными.

6. **Использование безопасных заголовков**:
    - Настройте заголовки HTTP (например, `X-Content-Type-Options`, `X-Frame-Options`, `Strict-Transport-Security`) на
      сервере для повышения безопасности.

7. **Проверка пользовательских данных**:
    - Валидация и проверка пользовательских данных на серверной стороне перед их сохранением или обработкой.

8. **Секреты и конфиденциальность**:
    - Не включайте секретные ключи или конфиденциальную информацию в исходный код или в файлы, которые могут быть видимы
      клиентам.

## 36. **Что такое обратный поток данных в React?**

`Обратный поток данных (или обратный поток)` в React относится к ситуации, когда данные передаются от дочернего
компонента
к родительскому. В React данные обычно передаются от родительского компонента к дочернему через пропсы. Однако иногда
бывает нужно, чтобы дочерний компонент сообщал родительскому о каких-то изменениях или событиях. Это и есть обратный
поток данных.

Вот как это можно реализовать:

1. **Объявление функции в родительском компоненте**: Родительский компонент определяет функцию, которая будет
   обрабатывать изменения данных.

   ```jsx
   function ParentComponent() {
     const handleDataChange = (newData) => {
       console.log('Received data from child:', newData);
     };

     return <ChildComponent onDataChange={handleDataChange} />;
   }
   ```

2. **Передача функции в дочерний компонент через пропсы**: Родительский компонент передает функцию в дочерний компонент
   через пропсы.

   ```jsx
   function ChildComponent({ onDataChange }) {
     const sendData = () => {
       onDataChange('Some data');
     };

     return <button onClick={sendData}>Send Data to Parent</button>;
   }
   ```

3. **Использование функции в дочернем компоненте**: Дочерний компонент вызывает переданную функцию при наступлении
   определенных событий (например, при нажатии кнопки).

В этом примере функция `handleDataChange` в родительском компоненте будет вызвана с данными, переданными из дочернего
компонента, когда будет выполнено событие (нажатие на кнопку).

## 37. **Что такое батчинг ререндеров?**

`Батчингом` в React называют процесс группировки нескольких вызовов обновления состояния в один этап ререндера. Это
положительно сказывается на производительности.

До React 18 батчинг автоматически работал только для обработчиков DOM событий.

В React 18 все обновления состояния внутри Promise, таймаутов, fetch-запросов будут батчиться также, как для
обработчиков DOM-событий.

## 38. **Как отменить батчинг?**

Обычно батчинг безопасен и не вызывает проблем при разработке, но если сразу после обновления состояния нужно прочитать
изменения в DOM, то можно использовать `ReactDOM.flushSync()` для отмены батчинга

## 39. **Что такое конкурентный режим?**

`Конкурентный режим` предназначен для более плавной работы приложения на устройстве пользователя.

Одна из областей, где данная фича применяется, это прерываемый рендеринг. Представьте, что пользователь вводит в строку
поиска текст. Это событие обновляет состояние компонента, и происходит рендер нового списка результатов. Во время этого
процесса залипает ввод: браузер не может обновить введенный в поле текст, так как занимается рендером нового списка
результатов. Конкурентный режим исправляет это ограничение, делая рендер прерываемым.

## 40. **Что такое предохранители (Error Boundaries)?**

`ErrorBoundary` - это механизм перехвата ошибок. С их помощью можно обработать ошибку и дать пользователю обратную
связь, если что-то пошло не так. В идеале - показать кнопку для повторения действия, в результате которого прозошла
ошибка.

Вот как это работает:

1. **Создание предохранителя**: Создайте компонент класса, который реализует метод `componentDidCatch(error, info)`.
   Этот метод вызывается, когда возникает ошибка в любом из дочерних компонентов. В этом методе вы можете логировать
   ошибку или показать пользователю запасной UI.

2. **Использование предохранителя**: Оберните компоненты, которые могут вызывать ошибки, в созданный вами компонент
   предохранителя.

Пример кода:

```jsx
class ErrorBoundary extends React.Component {
    constructor(props) {
        super(props);
        this.state = {hasError: false};
    }

    static getDerivedStateFromError() {
        // Обновление состояния, чтобы показать запасной UI после возникновения ошибки
        return {hasError: true};
    }

    componentDidCatch(error, info) {
        // Логирование ошибки
        console.error('Error caught by Error Boundary:', error, info);
    }

    render() {
        if (this.state.hasError) {
            // Вывод запасного UI
            return <h1>Что-то пошло не так.</h1>;
        }

        return this.props.children;
    }
}

// Использование ErrorBoundary
function App() {
    return (
        <ErrorBoundary>
            <MyComponent/>
        </ErrorBoundary>
    );
}
```

В этом примере, если в `MyComponent` произойдет ошибка, `ErrorBoundary` перехватит её и покажет запасной UI. Это
позволяет улучшить устойчивость вашего приложения и предоставить пользователю более дружественный интерфейс в случае
возникновения ошибок.

## 41. **Что такое PureComponent?**

`PureComponent` — это специальный тип компонента в React, который оптимизирует производительность за счет предотвращения
ненужных рендеров. `PureComponent` выполняет поверхностное сравнение пропсов и состояния, и если они не изменились,
компонент не перерисовывается.

Вот основные моменты о `PureComponent`:

1. **Поверхностное сравнение:** `PureComponent` использует метод `shouldComponentUpdate`, который делает поверхностное
   сравнение (т.е. сравнение на уровне примитивных значений) между новыми и старыми пропсами и состоянием. Если значения
   не изменились, рендеринг компонента не выполняется.

2. **Использование:** `PureComponent` обычно используется для оптимизации функциональных компонентов, когда известно,
   что пропсы и состояние не изменяются часто или изменяются в предсказуемом режиме.

3. **Заменяет `Component`:** `PureComponent` является расширением базового класса `Component`. Вы можете использовать
   его так же, как и обычный компонент, но с преимуществом автоматической оптимизации.

Пример использования `PureComponent`:

```jsx
import React, {PureComponent} from 'react';

class MyComponent extends PureComponent {
    render() {
        return <div>{this.props.value}</div>;
    }
}
```

Обратите внимание, что для сложных объектов или массивов `PureComponent` может не быть идеальным решением, так как
поверхностное сравнение может не обнаружить изменения внутри вложенных структур. В таких случаях лучше использовать
мемоизацию или другие методы оптимизации.
# **TypeScript**

## 1. **Что такое TypeScript?**

`TypeScript` — это язык программирования, разработанный Microsoft, который является надмножеством JavaScript и добавляет
к
нему строгую типизацию и другие возможности. TypeScript компилируется в обычный JavaScript, что позволяет
использовать его в любом окружении, поддерживающем JavaScript.

### Назовите особенности TypeScript

- **`Статическая типизация`**: Типы проверяются на этапе компиляции, что помогает находить ошибки до выполнения кода.
- **`Интерфейсы и типы`**: Возможность описывать структуры объектов и их контракты.
- **`ООП`**: Поддержка объектно-ориентированного программирования.
- **`Декораторы`**: Механизм для метаданных и аннотаций.
- **`Generics`**: Поддержка обобщенных типов.
- **`Поддержка новых стандартов JavaScript`**: TypeScript поддерживает современные функции JavaScript и даже новые
  возможности, еще не доступные в стандартном JS.

### Плюсы использования TypeScript

Использование TypeScript (TS) имеет множество преимуществ, особенно в контексте крупных и долгосрочных проектов:

1. **`Статическая типизация`**:
   TypeScript позволяет определять типы переменных, функций и объектов, что помогает избежать многих ошибок на этапе
   компиляции, а не в процессе выполнения программы. Это повышает надежность кода.

2. **`Автокомплит и рефакторинг`**:
   Благодаря статической типизации, IDE (например, WebStorm) может предлагать автодополнение, а также улучшает поддержку
   рефакторинга, делая код более управляемым.

3. **`Поддержка современных возможностей JavaScript`**:
   TypeScript поддерживает все последние версии ECMAScript, что позволяет использовать новые возможности языка до их
   официальной поддержки браузерами.

4. **`Интерфейсы и классы`**:
   TypeScript расширяет возможности JavaScript, предлагая дополнительные инструменты для работы с
   объектно-ориентированным программированием. Это помогает сделать архитектуру приложения более структурированной и
   предсказуемой.

5. **`Документирование через код`**:
   Типы в TypeScript выступают в роли документации, позволяя разработчикам быстрее понимать, что ожидается на вход и
   выход функции, а также как работают разные части системы.

6. **`Совместимость с JavaScript`**:
   TypeScript компилируется в обычный JavaScript, что позволяет легко интегрировать его в уже существующие проекты без
   необходимости полной миграции.

7. **`Масштабируемость`**:
   TypeScript особенно полезен в крупных командах и проектах, так как строгая типизация и возможность раннего
   обнаружения ошибок помогают поддерживать высокий уровень качества кода.

8. **`Активное сообщество и поддержка`**:
   TypeScript поддерживается Microsoft и имеет большое сообщество разработчиков. Это означает, что он будет долго
   развиваться, и для него существует множество библиотек и инструментов.

### Минусы использования TypeScript

Хотя у TypeScript много преимуществ, у него есть и некоторые недостатки, которые стоит учитывать при выборе этого языка
для разработки:

1. **`Крутая кривая обучения`**:
   Для разработчиков, знакомых только с JavaScript, переход на TypeScript может быть сложным. Понимание системы типов,
   интерфейсов, дженериков и других особенностей требует времени и усилий.

2. **`Повышенная сложность`**:
   Статическая типизация добавляет дополнительный уровень сложности в проект. В некоторых случаях это может привести к
   тому, что код становится более громоздким, особенно если типы сильно усложнены.

3. **`Замедление разработки на ранних этапах`**:
   Хотя TypeScript помогает избегать ошибок на этапе компиляции, на начальном этапе разработки написание и настройка
   типизации может замедлить процесс разработки, особенно для небольших проектов, где нет необходимости в строгой
   типизации.

4. **`Требует дополнительных инструментов и настройки`**:
   TypeScript требует настройки компиляции (например, с помощью `tsconfig.json`), что усложняет первоначальную настройку
   проекта по сравнению с обычным JavaScript. Кроме того, не все библиотеки имеют полные типы, и иногда приходится
   писать собственные определения типов.

5. **`Замедленная обратная связь`**:
   Из-за необходимости компиляции TypeScript в JavaScript разработчики могут получать обратную связь о своих изменениях
   медленнее по сравнению с JavaScript, особенно при использовании сложных сборщиков и инструментов.

6. **`Совместимость с существующими проектами`**:
   Внедрение TypeScript в проект, который изначально был написан на чистом JavaScript, может потребовать значительных
   усилий и рефакторинга кода, особенно если кодовая база большая.

7. **`Типизация может не всегда быть полезной`**:
   В некоторых случаях строгая типизация не приносит ожидаемой пользы. Например, для небольших проектов с динамическими
   данными или быстрого прототипирования TypeScript может оказаться излишним.

8. **`Лишние типы`**:
   Иногда приходится писать много дополнительных типов и интерфейсов, особенно для сложных данных, что может усложнить
   код и сделать его менее читабельным.

## 2. **Типы в TypeScript**

В TypeScript существуют несколько типов данных, которые делятся на:

### Примитивные типы:

1. **`number`** – для чисел.
   ```ts
   let age: number = 25;
   ```

2. **`string`** – для строк.
   ```ts
   let name: string = "Anton";
   ```

3. **`boolean`** – для логических значений (истина/ложь).
   ```ts
   let isActive: boolean = true;
   ```

4. **`null`** – специальное значение для "ничего".
   ```ts
   let emptyValue: null = null;
   ```

5. **`undefined`** – переменная без присвоенного значения.
   ```ts
   let notAssigned: undefined = undefined;
   ```

6. **`symbol`** – уникальные и неизменяемые идентификаторы.
   ```ts
   let sym: symbol = Symbol();
   ```

7. **`bigint`** – для работы с большими целыми числами.
   ```ts
   let largeNumber: bigint = 9007199254740991n;
   ```

### Объектные типы:

1. **`Array`** – массивы, могут быть определены через generic.
   ```ts
   let numbers: number[] = [1, 2, 3];
   let strings: Array<string> = ["a", "b", "c"];
   ```

2. **`Tuple`** – кортежи, фиксированная длина массива с разными типами данных.
   ```ts
   let person: [string, number] = ["Anton", 25];
   ```

3. **`Object`** – любой объект.
   ```ts
   let user: { name: string, age: number } = { name: "Anton", age: 25 };
   ```

4. **`Function`** – типизация функций.
   ```ts
   let add: (a: number, b: number) => number = (a, b) => a + b;
   ```

### Специальные типы:

1. **`any`** – для переменных, тип которых заранее неизвестен.
   ```ts
   let randomValue: any = "Hello";
   ```

2. **`unknown`** – похож на `any`, но требует проверки типа перед использованием.
   ```ts
   let someValue: unknown = "Hello";
   if (typeof someValue === "string") {
     console.log(someValue.toUpperCase());
   }
   ```

3. **`void`** – для функций, которые ничего не возвращают.
   ```ts
   function greet(): void {
     console.log("Hello!");
   }
   ```

4. **`never`** – для функций, которые никогда не завершаются или всегда бросают ошибку.
   ```ts
   function throwError(message: string): never {
     throw new Error(message);
   }
   ```

5. **`enum`** – перечисления для наборов значений.
   ```ts
   enum Color {
     Red,
     Green,
     Blue
   }
   let c: Color = Color.Green;
   ```

6. **`literal`** – литеральные типы для фиксированных значений.
   ```ts
   let direction: "left" | "right" = "left";
   ```

### Унион и пересечения:

1. **Union (`|`)** – объединение нескольких типов.
   ```ts
   let id: string | number;
   ```

2. **Intersection (`&`)** – пересечение нескольких типов.
   ```ts
   let user: { name: string } & { age: number };
   ```

## 3. **Что такое декораторы?**

`В TypeScript декораторы` — это особые функции, которые могут быть прикреплены к классам, методам, свойствам или
параметрам, чтобы модифицировать или расширять их поведение. Декораторы позволяют добавлять функциональность к
существующему коду, не изменяя его напрямую, что делает код более модульным и повторно используемым.

### Типы декораторов:

1. **Декораторы классов**: применяются к классу и позволяют изменить его поведение или добавить дополнительные
   возможности.

   ```ts
   function sealed(constructor: Function) {
       Object.seal(constructor);
       Object.seal(constructor.prototype);
   }

   @sealed
   class MyClass {
       // тело класса
   }
   ```

2. **Декораторы методов**: применяются к методам класса и могут изменить их поведение, например, логировать вызовы или
   кешировать результаты.

   ```ts
   function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
       const originalMethod = descriptor.value;

       descriptor.value = function (...args: any[]) {
           console.log(`Вызван метод: ${propertyKey}, с аргументами: ${JSON.stringify(args)}`);
           return originalMethod.apply(this, args);
       };
   }

   class MyClass {
       @log
       myMethod(param: string) {
           console.log(`Выполнение метода с параметром: ${param}`);
       }
   }
   ```

3. **Декораторы свойств**: применяются к свойствам класса и могут использоваться, например, для управления доступом к
   свойству или валидации.

   ```ts
   function format(target: any, propertyKey: string) {
       let value: string;

       const getter = function () {
           return value;
       };

       const setter = function (newVal: string) {
           value = newVal.toUpperCase();
       };

       Object.defineProperty(target, propertyKey, {
           get: getter,
           set: setter,
           enumerable: true,
           configurable: true,
       });
   }

   class MyClass {
       @format
       public name: string;

       constructor(name: string) {
           this.name = name;
       }
   }

   const instance = new MyClass('anton');
   console.log(instance.name); // 'ANTON'
   ```

4. **Декораторы параметров**: применяются к параметрам метода, чтобы изменить их поведение.

   ```ts
   function logParam(target: Object, propertyKey: string | symbol, parameterIndex: number) {
       console.log(`Параметр декорирован в методе: ${String(propertyKey)} на индексе: ${parameterIndex}`);
   }

   class MyClass {
       myMethod(@logParam param: string) {
           console.log(`Параметр: ${param}`);
       }
   }
   ```

### Примечания:

- Декораторы являются экспериментальной функцией в TypeScript, и для их использования необходимо включить
  флаг `experimentalDecorators` в `tsconfig.json`:
  ```json
  {
    "compilerOptions": {
      "experimentalDecorators": true
    }
  }
  ```

- Декораторы позволяют гибко добавлять функциональность, упрощая логику кода и делая его более поддерживаемым и
  расширяемым.

## 4. **Поддерживает ли TypeScript перегрузку функций?**

`TypeScript поддерживает перегрузку функций`, но её реализация отличается от той, которую можно видеть в других языках.
А именно, описывается лишь одна функция и некоторое количество её объявлений с разными параметрами. Когда такой код
компилируется в JavaScript, в нём остаётся лишь одна функция. Этот механизм работает благодаря тому, что JS-функции
можно вызывать с любым количеством параметров.

## 5. **Разница между типом (type) и интерфейсом (interface)?**

В ряде случаев они взаимозаменяемы.

Однако, различия присутствуют:

- с `типами` можно использовать пересечение и объединение
- `интерфейс` можно расширять, строя цепочку наследований
- `интерфейс` может быть использован для описания класса
- `интерфейс` может быть использован для описания функции
- в случае, если в одной области видимости объявлено несколько одноимённых `интерфейсов`, они будут объединены в один
- если в нескольких одноимённых `интерфейсах` будут описаны одноимённые методы с разными сигнатурами, они будут
  расценены,
  как описание `перегрузки`.

В целом, можно сказать, что ключевое слово `type` больше подходит для типизации примитивных значений или объектных
значений, не являющихся звеньями сложной цепочки. `interface` же необходим и удобен при осознанном построении
объектно-ориентированной архитектуры.

## 6. **Какие режимы JSX поддерживает TypeScript?**

`TypeScript поддерживает
несколько режимов JSX:`

- **React**: Для работы с React.
- **Preserve**: Сохранение JSX как есть, без преобразования.
- **React Native**: Для разработки приложений с React Native.

## 7. **Как TypeScript поддерживает необязательные и дефолтные параметры в функции?**

- `Необязательные параметры`: Указываются с помощью `?`, например `function foo(x?: number)`.
- `Дефолтные параметры`: Имеют значение по умолчанию, например `function foo(x: number = 5)`.

## 8. **Что такое перечисление (enum)? Различие enum и const enum?**

`Перечисление (enum)` — это тип данных, представляющий собой набор именованных значений.

### Основные характеристики перечислений в TypeScript:

1. **Именованные константы**: Перечисления позволяют создавать набор связанных значений с уникальными именами.

2. **Тип безопасности**: TypeScript обеспечивает строгую типизацию, что позволяет избежать ошибок, связанных с
   использованием "магических" чисел или строк.

3. **Удобство чтения**: Код становится более понятным, так как имена перечислений часто описывают их назначение.

Пример использования:

```typescript
enum Color {
    Red = "RED",
    Green = "GREEN",
    Blue = "BLUE",
}

let myColor: Color = Color.Green;
console.log(myColor); // Выведет: GREEN
```

### Виды перечислений:

1. **Числовые перечисления**: Значения автоматически присваиваются с 0, если не указано иное.

   ```typescript
   enum Direction {
       Up,    // 0
       Down,  // 1
       Left,  // 2
       Right  // 3
   }
   ```

2. **Строковые перечисления**: Каждому элементу явно присваивается строковое значение.

   ```typescript
   enum Status {
       Success = "SUCCESS",
       Error = "ERROR",
       Pending = "PENDING"
   }
   ```

3. **Гетерогенные перечисления**: Смешивание числовых и строковых значений в одном перечислении (не рекомендуется, так
   как может запутать).

   ```typescript
   enum Mixed {
       No = 0,
       Yes = "YES"
   }
   ```

### `Различие enum и const enum:` 

**`Сборка и использование`**
- **`enum`**: Создает объект в JavaScript, который содержит все значения перечисления. Это означает, что вы можете использовать его в рантайме и обращаться к его значениям через имя.
- **`const enum`**: На этапе компиляции `const enum` удаляется и заменяется соответствующими значениями. Это приводит к более компактному коду и лучшей производительности, так как не создается дополнительный объект.

Пример:
```typescript
enum Color {
    Red,
    Green,
    Blue
}

const enum Direction {
    Up,
    Down,
    Left,
    Right
}

// Использование enum
const myColor: Color = Color.Red; // скомпилируется в "var myColor = Color.Red;"
console.log(myColor); // доступ к объекту Color

// Использование const enum
const myDirection: Direction = Direction.Up; // скомпилируется в "var myDirection = 0;"
console.log(myDirection); // доступ к значению без объекта
```

### Применение
- Используйте **`enum`**, когда вам нужно, чтобы значения перечисления были доступны во время выполнения и если вы хотите использовать их как объекты.
- Используйте **`const enum`**, если вам важна производительность и если значения перечисления не нужны во время выполнения, а только во время компиляции.

## 9. **Для чего в TypeScript используется NoImplicitAny?**

`NoImplicitAny` — это флаг компилятора TypeScript, который предотвращает автоматическое присвоение типа `any` переменным
и параметрам, если тип не указан явно. Это помогает предотвратить неявные ошибки типизации.

## 10. **Разница между типами “Объединение” (|) и “Пересечение” (&)?**

- `Объединение (`|`)`: Тип может быть одним из нескольких указанных типов. Например, `string | number` означает, что
  значение может быть либо строкой, либо числом.
- `Пересечение (`&`)`: Тип включает в себя свойства нескольких типов. Например, `A & B` означает, что значение должно
  соответствовать как типу `A`, так и типу `B`.

## 11. **Что такое общие типы (generic) в TypeScript?**

`Общие типы (generic)` позволяют создавать функции, классы и интерфейсы, которые работают с любыми типами данных, не
зная
их конкретного типа заранее. Например:

```typescript
function identity<T>(arg: T): T {
    return arg;
}
```

## 12. **Какие области видимости доступны в TypeScript?**

`Глобальная область видимости:`

Переменные и функции, объявленные вне любых блоков, функций или классов, находятся в глобальной области видимости. Они
доступны везде в коде.
Глобальные переменные могут привести к конфликтам имен, особенно в больших проектах.

`Область видимости функции:`

Переменные, объявленные внутри функции с помощью var, let, или const, доступны только внутри этой функции. Это
называется функциональной областью видимости.
Переменные не видны за пределами функции.

`Блочная область видимости:`

Введена в ES6 с ключевыми словами let и const. Переменные, объявленные внутри блока (например, в конструкции if, for,
while, и т.д.), доступны только внутри этого блока.
В отличие от var, который игнорирует блочную область, let и const обеспечивают блочную область видимости.

`Область видимости класса:`

Переменные и методы, объявленные внутри класса с использованием ключевого слова private, имеют область видимости только
в этом классе.
Свойства и методы могут также быть объявлены как protected, что делает их доступными только в классе и его подклассах.
Свойства и методы с модификатором доступа public доступны везде, где виден объект класса.

`Модульная область видимости:`

В TypeScript (и ES6) модули имеют свою собственную область видимости. Экспортируемые переменные и функции из одного
модуля доступны только в других модулях через import.
Это помогает изолировать код и предотвращает загрязнение глобального пространства имен.

## 13. **Что такое .map файл, как и зачем его использовать?**

`Файл .map` — это source map, который связывает скомпилированный JavaScript код с исходным TypeScript кодом. Это
позволяет отлаживать TypeScript код в
браузере, показывая исходный код вместо скомпилированного JavaScript.

## 14. **Для чего в TypeScript используют ключевое слово declare?**

Ключевое слово `declare` используется для объявления переменных, функций или модулей, которые существуют, но TypeScript
не знает о них. Это часто используется для объявления глобальных переменных или для работы с библиотеками, написанными
на JavaScript.

## 15. **Разница между типами void, never и unknown?**

### 1. **`void`**

Тип `void` используется для функций, которые **ничего не возвращают**. Это похоже на `undefined` в JavaScript, но
используется специально для того, чтобы указать, что функция не возвращает значения.

Пример:

```typescript
function logMessage(message: string): void {
    console.log(message);
}
```

Здесь функция `logMessage` ничего не возвращает, поэтому ее возвращаемый тип — `void`.

### 2. **`never`**

Тип `never` обозначает, что **функция никогда не завершится успешно** или **никогда не вернет значение**. Это может быть
либо функция, которая вызывает ошибку (и выбрасывает исключение), либо бесконечный цикл.

Пример:

```typescript
function throwError(message: string): never {
    throw new Error(message);
}

function infiniteLoop(): never {
    while (true) {
    }
}
```

switch case 


Здесь функции либо выбрасывают ошибку, либо зацикливаются бесконечно, и потому они никогда не возвращают значение.

### 3. `unknown`

Тип `unknown` используется, когда мы не знаем точный тип значения. Это более строгий аналог `any`. Работать с переменной
типа `unknown` можно только после того, как убедитесь в ее типе (с помощью проверки типа, приведения или других
методов).

Пример:

```typescript
let something: unknown;

something = "Hello";
something = 42;

if (typeof something === "string") {
    console.log(something.toUpperCase());  // Здесь безопасно использовать строковые методы
}
```

Тип `unknown` заставляет нас явно проверять тип перед тем, как использовать его, в отличие от `any`, где этого не
требуется.

### Краткое резюме:

- `void`: функция ничего не возвращает.
- `never`: функция не завершится нормально или не вернет значение.
- `unknown`: значение может быть любого типа, и требуется проверка перед использованием.

## 16. **Зачем нужны .d.ts файлы?**

`.d.ts файлы` - это файлы декларации типов. Они содержат описание типов без реализации. Например, сигнатуры функций без
тела, название и тип глобальных переменных без значений. В основном файлы декларации типов нужны для написания библиотек
или при их использовании.

```JavaScript
declare

class Vector {
    readonly
    x: number;
    readonly
    y: number;
    static readonly
    zero: Vector;

    constructor(x: number, y: number);

    add(vector: Vector): Vector;
}
```

## 17. **Как реализовать const в классе?**

В TypeScript при объявлении свойств классов `нельзя использовать ключевое слово const`.

Начиная со второй версии TS, можно использовать модификатор `readonly`, позволяющий объявлять свойства класса,
предназначенные только для чтения.

## 18. **Что такое пространства имён? Разница между внутренним (Internal Module) и внешним модулями (External Module)?**

`Пространства имен в TypeScript` — это способ организации и группировки связанного кода. Они помогают избежать
столкновения имен и способствуют модульности, инкапсулируя связанный код. Пространства имен могут содержать классы,
интерфейсы, функции, переменные и другие пространства имен.

**Определение пространств имен**

Чтобы определить пространство имен, используйте ключевое слово namespace, за которым следует имя пространства имен.
Затем можно добавить любой связанный код внутри фигурных скобок.

```JavaScript
namespace MyNamespace {
    export class MyClass {
        constructor(public value: number) {
    }

    displayValue() {
        console.log(`The value is: ${this.value}`);
    }
}
}
```

В этом примере определяем пространство имен MyNamespace и добавляем в него класс MyClass. Учтите, что ключевое слово
export используется, чтобы сделать класс доступным за пределами пространства имен.

**Применение пространств имен**

Чтобы применить код из пространства имен, можно либо использовать полностью определенное имя, либо импортировать код с
помощью импорта пространства имен.

```JavaScript
// Использование полностью определенного имени
const instance1 = new MyNamespace.MyClass(5);
instance1.displayValue(); // Вывод: Значение - 5

// Использование импорта пространства имен
import MyClass = MyNamespace.MyClass;

const instance2 = new MyClass(10);
instance2.displayValue(); // Вывод: Значение - 10
```

Этот пример демонстрирует два способа использования класса MyClass из пространства имен MyNamespace. В первом случае
используем полностью определенное имя MyNamespace.MyClass. Во втором — применяем оператор импорта пространства имен,
чтобы импортировать класс MyClass и использовать его с более коротким именем.

**Вложенные пространства имен**

Пространства имен могут быть вложенными для создания иерархии и дальнейшей организации кода.

```JavaScript 
namespace OuterNamespace {
export namespace InnerNamespace {
        export class MyClass {
            constructor(public value: number) {
        }

        displayValue() {
            console.log(`The value is: ${this.value}`);
        }
    }
    }
}

// Использование полностью определенного имени
const instance = new OuterNamespace.InnerNamespace.MyClass(15);
instance.displayValue(); // Вывод: Значение - 15

```

В этом примере определяем вложенное пространство имен InnerNamespace внутри OuterNamespace. Затем определяем класс
MyClass внутри вложенного пространства имен и используем его с полным именем OuterNamespace.InnerNamespace.MyClass.

### В TypeScript различают `внутренние (Internal) и внешние (External) модули`. Вот основные различия между ними:

### `Внутренние модули (Internal Modules)`

- **Определение**: Внутренние модули, также известные как пространства имен (namespaces), используются для организации
  кода внутри одного файла или группы файлов. Они помогают избежать конфликтов имен.
- **Синтаксис**: Внутренние модули определяются с помощью ключевого слова `namespace`.

Пример:
```typescript
namespace MyNamespace {
    export class MyClass {
        // ...
    }
}
```
- **Использование**: Внутренние модули полезны для группировки связанных типов и функций, особенно в больших
  приложениях.

### `Внешние модули (External Modules)`

- **Определение**: Внешние модули представляют собой отдельные файлы, которые могут экспортировать и импортировать
  функциональность. Они используют систему модулей ES6 (ES2015) или CommonJS.
- **Синтаксис**: Внешние модули используют ключевые слова `import` и `export` для импорта и экспорта функциональности.

Пример:
```typescript
// файл myModule.ts
export class MyClass {
    // ...
}

// другой файл
import { MyClass } from './myModule';
```
- **Использование**: Внешние модули позволяют разделять код на файлы, что упрощает его повторное использование и
  тестирование.

### Краткое сравнение

- **Структура**: Внутренние модули — это логическая организация кода внутри одного файла, в то время как внешние
  модули — это физическое разделение кода на разные файлы.
- **Импорт/Экспорт**: Внутренние модули используют `namespace`, а внешние — `import` и `export`.
- **Современные практики**: Внешние модули предпочтительнее для новых проектов, так как они лучше соответствуют
  стандартам ES6 и упрощают работу с инструментами сборки.

## 20. **Что такое предохранители типов?**

`Предохранители типов в TypeScript` — это способ сузить тип переменной или параметра в определенном блоке кода. Они
позволяют дифференцировать различные типы и получать доступ к свойствам и методам, специфичным для этих типов,
обеспечивая безопасность типов и снижая вероятность ошибок во время выполнения.

**Определение предохранителей типов**

Чтобы определить предохранитель типа, создайте функцию, которая принимает переменную или параметр и возвращает предикат
типа. Предикат типа — это булево выражение, которое сужает тип параметра в пределах области видимости функции.

```JavaScript
function isString(value: any): value is string
{
    return typeof value === "string";
}
```

В этом примере определяем функцию предохранителя типа isString, которая проверяет, является ли заданное значение типом
string. Функция возвращает предикат типа value is string, который сужает тип параметра value в пределах области
видимости функции.

**Использование предохранителей типов**

Чтобы использовать предохранитель типа, просто вызовите функцию предохранителя типа в условном операторе, например в if
и switch.

```JavaScript
  function processValue(value: string | number) {
    if (isString(value)) {
        console.log(`The length of the string is: ${value.length}`);
    } else {
        console.log(`The square of the number is: ${value * value}`);
    }
}
```

В этом примере определяем функцию processValue , которая принимает значение типа string | number. Используем функцию
предохранителя типа isString, чтобы проверить, является ли значение строкой. Если это так, обращаемся к свойству length,
характерному для string типа. В противном случае принимаем значение за number и вычисляем его квадрат.

**Теперь продемонстрируем, как работает предохранитель типа на практике.**

```JavaScript
  processValue("hello"); // Вывод: Длина строки - 5
processValue(42); // Вывод: Квадрат числа равен 1764
```

В этом примере вызываем функцию processValue как со строкой, так и с числом. Функция предохранителя типа isString
обеспечивает выполнение соответствующего блока кода для каждого типа, что позволяет получить доступ к свойствам и
методам, специфичным для конкретного типа, без ошибок типа.

## 21. **Зачем нужен keyof?**

Оператор keyof возвращает в качестве типа перечисление ключей объекта, по отношению к которому он применяется.

```JavaScript
  type
Point = {x: number; y: number};

type
P = keyof
Point;

// type P = “x” | “y”
```

## 22. **Что такое утилитарные типы (Utility Types)?**

`Утилитарные типы (Utility Types)` — это встроенные типы, которые помогают создавать новые типы на основе существующих, упрощая работу с типами и обеспечивая более чистый и поддерживаемый код.

Чтобы создать собственный утилитарный тип в TypeScript, вам нужно использовать обобщения(generics) и условные типы.

## 23. **Что такое Partial<>?**

`Утилитарный тип Partial<T>` позволяет сделать все свойства типа T необязательными. Можно сказать, что он добавит
отметку ? рядом с каждым полем.

```JavaScript
interface
Todo
{
    title: string;
    description: string;
}

function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {
    return {...todo, ...fieldsToUpdate};
}
```

## 24. **Что такое Required<>?**

В отличие от Partial утилитарный тип `Required<T>` принудительно делает все свойства объекта T обязательными.

```javascript
interface
Props
{
    a ? : number;
    b ? : string;
}

const obj: Props = {a: 5};

const obj2: Required<Props> = {a: 5};

// Property 'b' is missing in type '{ a: number; }' but required in type 'Required<Props>'.
```

## 25. **Что такое Pick<>?**

Утилитарный тип `Pick<Type, Keys>` позволяет создать новый тип, взяв из Type свойства Keys.

```javascript
interface
Todo
{
    title: string;
    description: string;
    completed: boolean;
}

type
TodoPreview = Pick < Todo, "title" | "completed" >;

const todo: TodoPreview = {
    title: "Clean room",
    completed: false,
};
```

## 26. **Что такое Omit<>?**

Утилитарный тип `Omit<Type, Keys>` является противоположностью утилитарного типа Pick<Type, Keys>. С помощью Omit можно
создать тип на основе имеющегося, исключив перечисленные свойства.

```javascript
interface
Todo
{
    title: string;
    description: string;
    completed: boolean;
    createdAt: number;
}

type
TodoPreview = Omit < Todo, "description" >;

const todo: TodoPreview = {
    title: "Clean room",
    completed: false,
    createdAt: 1615544252770,
};
```

## 27. **Что такое Exclude<>?**

`Exclude<UnionType, ExcludedMembers>` похож на Omit с тем лишь отличием, что первым параметром принимает UnionType, а не
конкретный тип.

Он создает тип, исключая из UnionType указанные ExcludedMembers.

Обратите внимание на третий пример, это может работать даже так.

```javascript
type
T0 = Exclude < "a" | "b" | "c", "a" >;
// type T0 = "b" | "c"

type
T1 = Exclude < "a" | "b" | "c", "a" | "b" >;
// type T1 = "c"

type
T2 = Exclude < string | number | (() => void), Function >;
// type T2 = string | number
```

## 28. **Что такое Extract<>?**

`Extract<Type, Union>` создает тип на основе извлеченного Union из Type.

```javascript
type
T0 = Extract < "a" | "b" | "c", "a" | "f" >;
// type T0 = "a"

type
T1 = Extract < string | number | (() => void), Function >;
// type T1 = () => void
```

## 29. **Что такое NonNullable<>?**

`NonNullable<Type>` просто возвращает переданный тип, лишив его типов null и undefined.

```javascript
type
T0 = NonNullable < string | number | undefined >;
// type T0 = string | number

type
T1 = NonNullable < string[] | null | undefined >;
// type T1 = string[]
```

## 30. **Что такое Parameters<>?**

`Parameters<Type>` принимает на вход функцию и возвращает тип, описывающий её параметры.

```javascript
declare

function myFunc(arg: { a: number; b: string }): void;

type
Params = Parameters < typeof myFunc >;
//  type Params = [arg: {
//    a: number;
//    b: string;
//  }]
```

## 31. **Что такое ReturnType<>?**

`ReturnType<Type>` принимает на вход функцию и возвращает тип, описывающий возвращаемое ею значение.

```javascript
declare

function f1(): { a: number; b: string };

type
T1 = ReturnType < typeof f1 >;
//  type T1= {
//    a: number;
//    b: string;
//  }

type
T2 = ReturnType < ()
=>
string >;
// type T2 = string
```
# **TypeScript**

## 1. Что такое TypeScript?

`TypeScript` — это язык программирования, разработанный Microsoft, который является надмножеством JavaScript и добавляет
к
нему строгую типизацию и другие возможности. TypeScript компилируется в обычный JavaScript, что позволяет
использовать его в любом окружении, поддерживающем JavaScript.

## 2. Основные компоненты TypeScript

Основные компоненты TypeScript включают:

- **Типы данных**: Основные типы, такие как `number`, `string`, `boolean`, и сложные типы, такие как массивы, кортежи,
  интерфейсы и классы.
- **Файлы конфигурации**: `tsconfig.json`, который настраивает поведение компилятора TypeScript.
- **Декораторы**: Специальные аннотации для классов и их членов.
- **Модули**: Для управления зависимостями и разбиения кода на части.
- **Интерфейсы и типы**: Для определения структуры объектов и контрактов.

## 3. Назовите особенности TypeScript

- **Статическая типизация**: Типы проверяются на этапе компиляции, что помогает находить ошибки до выполнения кода.
- **Интерфейсы и типы**: Возможность описывать структуры объектов и их контракты.
- **Классы и объекты**: Поддержка объектно-ориентированного программирования.
- **Декораторы**: Механизм для метаданных и аннотаций.
- **Generics**: Поддержка обобщенных типов.
- **Поддержка новых стандартов JavaScript**: TypeScript поддерживает современные функции JavaScript и даже новые
  возможности, еще не доступные в стандартном JS.

## 4. Плюсы использования TypeScript

- **Раннее обнаружение ошибок**: Благодаря статической типизации многие ошибки могут быть обнаружены до выполнения.
- **Лучшее автодополнение и навигация**: IDE могут предоставлять более точное автодополнение и помощь в навигации.
- **Модульность и масштабируемость**: Упрощает организацию и поддержку больших кодовых баз.
- **Совместимость с JavaScript**: Можно использовать существующий JavaScript код и постепенно мигрировать к TypeScript.

## 5. Минусы использования TypeScript

- **Крутая кривая обучения**: Может потребоваться время для освоения, особенно для тех, кто не знаком с типизацией.
- **Избыточность кода**: В некоторых случаях может потребоваться написание дополнительного кода для описания типов.
- **Компиляция**: Код нужно компилировать из TypeScript в JavaScript, что добавляет шаг в сборке.

## 6. Типы в TypeScript

- **Простые типы**: `number`, `string`, `boolean`, `void`, `null`, `undefined`.
- **Композитные типы**: Массивы, кортежи, перечисления (`enum`).
- **Объектные типы**: Интерфейсы, классы, функции.
- **Обобщенные типы**: Используются для создания обобщенных функций и классов.

## 7. Что такое декораторы?

`Декораторы` — это специальный синтаксис в TypeScript, который позволяет добавлять аннотации и изменять поведение
классов
и их членов (методов, свойств). Они используют синтаксис `@decorator`.

`Декораторы` используются для расширения поведения функций. Самые распространённые примеры - добавление декоратором
возможности логирования или кэширования функции.

## 8. Поддерживает ли TypeScript перегрузку функций?

`TypeScript поддерживает перегрузку функций`, но её реализация отличается от той, которую можно видеть в других языках.
А именно, описывается лишь одна функция и некоторое количество её объявлений с разными параметрами. Когда такой код
компилируется в JavaScript, в нём остаётся лишь одна функция. Этот механизм работает благодаря тому, что JS-функции
можно вызывать с любым количеством параметров.

## 9. Разница между типом (type) и интерфейсом (interface)?

В ряде случаев они взаимозаменяемы.

Однако, различия присутствуют:

- с `типами` можно использовать пересечение и объединение
- `интерфейс` можно расширять, строя цепочку наследований
- `интерфейс` может быть использован для описания класса
- `интерфейс` может быть использован для описания функции
- в случае, если в одной области видимости объявлено несколько одноимённых `интерфейсов`, они будут объединены в один
- если в нескольких одноимённых `интерфейсах` будут описаны одноимённые методы с разными сигнатурами, они будут
  расценены,
  как описание `перегрузки`.

В целом, можно сказать, что ключевое слово `type` больше подходит для типизации примитивных значений или объектных
значений, не являющихся звеньями сложной цепочки. `interface` же необходим и удобен при осознанном построении
объектно-ориентированной архитектуры.

## 10. Что такое JSX в TypeScript? Какие режимы JSX поддерживает TypeScript?

`JSX` — это синтаксический сахар для описания структуры UI, который компилируется в JavaScript. TypeScript поддерживает
несколько режимов JSX:

- **React**: Для работы с React.
- **Preserve**: Сохранение JSX как есть, без преобразования.
- **React Native**: Для разработки приложений с React Native.

## 11. Что такое директивы с тремя наклонными чертами (Triple-Slash Directives), их типы?

`Triple-slash директивы` — это особые комментарии, начинающиеся с `/// <` и служат для указания на файлы деклараций,
которые нужно включить. Основные типы:

- `/// <reference path="..." />`
- `/// <reference types="..." />`
- `/// <reference lib="..." />`

## 12. Разница между абстрактным классом (abstract class) и интерфейсом (interface)?

- `Абстрактный класс`: Может содержать реализацию методов, а также абстрактные методы, которые должны быть реализованы
  в подклассах. Поддерживает модификаторы доступа.
- `Интерфейс`: Описывает структуру объекта без реализации. Может быть реализован несколькими классами, но не
  поддерживает реализацию методов.

## 13. Какие элементы ООП поддерживаются в TypeScript?

- `Классы`: Поддержка классов и объектов.
- `Наследование`: Классы могут наследовать другие классы.
- `Интерфейсы`: Определяют контракты для объектов.
- `Полиморфизм`: Возможность замены реализаций и переопределения методов.
- `Инкапсуляция`: Модификаторы доступа и приватные члены классов.

## 14. Модификаторы доступа в TypeScript?

- `public`: Доступен везде.
- `private`: Доступен только внутри класса.
- `protected`: Доступен внутри класса и его подклассов.

## 15. Разница между внутренним (Internal Module) и внешним модулями (External Module)?

- `Внутренние модули`: Используются для организации кода внутри одного файла или проекта, но с устаревшим
  синтаксисом `module`.
- `Внешние модули`: Используют ключевое слово `import` и `export` для управления зависимостями между файлами и
  являются более современным подходом к модульности.

## 16. Как TypeScript поддерживает необязательные и дефолтные параметры в функции?

- `Необязательные параметры`: Указываются с помощью `?`, например `function foo(x?: number)`.
- `Дефолтные параметры`: Имеют значение по умолчанию, например `function foo(x: number = 5)`.

## 17. Что такое перечисление (enum)?

`Перечисление (enum)` — это тип данных, представляющий собой набор именованных значений. Например:

```typescript
enum Color {
    Red,
    Green,
    Blue
}
```

## 18. Для чего в TypeScript используется NoImplicitAny?

`NoImplicitAny` — это флаг компилятора TypeScript, который предотвращает автоматическое присвоение типа `any` переменным
и параметрам, если тип не указан явно. Это помогает предотвратить неявные ошибки типизации.

## 19. Разница между типами “Объединение” (|) и “Пересечение” (&)?

- `Объединение (`|`)`: Тип может быть одним из нескольких указанных типов. Например, `string | number` означает, что
  значение может быть либо строкой, либо числом.
- `Пересечение (`&`)`: Тип включает в себя свойства нескольких типов. Например, `A & B` означает, что значение должно
  соответствовать как типу `A`, так и типу `B`.

## 20. Что такое общие типы (generic) в TypeScript?

`Общие типы (generic)` позволяют создавать функции, классы и интерфейсы, которые работают с любыми типами данных, не
зная
их конкретного типа заранее. Например:

```typescript
function identity<T>(arg: T): T {
    return arg;
}
```

## 21. Какие области видимости доступны в TypeScript?

`Глобальная область видимости:`

Переменные и функции, объявленные вне любых блоков, функций или классов, находятся в глобальной области видимости. Они доступны везде в коде.
Глобальные переменные могут привести к конфликтам имен, особенно в больших проектах.

`Область видимости функции:`

Переменные, объявленные внутри функции с помощью var, let, или const, доступны только внутри этой функции. Это называется функциональной областью видимости.
Переменные не видны за пределами функции.

`Блочная область видимости:`

Введена в ES6 с ключевыми словами let и const. Переменные, объявленные внутри блока (например, в конструкции if, for, while, и т.д.), доступны только внутри этого блока.
В отличие от var, который игнорирует блочную область, let и const обеспечивают блочную область видимости.

`Область видимости класса:`

Переменные и методы, объявленные внутри класса с использованием ключевого слова private, имеют область видимости только в этом классе.
Свойства и методы могут также быть объявлены как protected, что делает их доступными только в классе и его подклассах.
Свойства и методы с модификатором доступа public доступны везде, где виден объект класса.

`Модульная область видимости:`

В TypeScript (и ES6) модули имеют свою собственную область видимости. Экспортируемые переменные и функции из одного модуля доступны только в других модулях через import.
Это помогает изолировать код и предотвращает загрязнение глобального пространства имен.

## 22. Что такое .map файл, как и зачем его использовать?

`Файл .map` — это source map, который связывает скомпилированный JavaScript код с исходным TypeScript кодом. Это
позволяет отлаживать TypeScript код в
браузере, показывая исходный код вместо скомпилированного JavaScript.

## 23. Можно ли использовать TypeScript в серверной разработке?

`Да`, TypeScript можно использовать в серверной разработке, например, с Node.js. TypeScript предоставляет преимущества
статической типизации и улучшенного автодополнения и проверки типов.

## 24. Для чего в TypeScript используют ключевое слово declare?

Ключевое слово `declare` используется для объявления переменных, функций или модулей, которые существуют, но TypeScript
не знает о них. Это часто используется для объявления глобальных переменных или для работы с библиотеками, написанными
на JavaScript.

## 25. Разница между типами void, never и unknown?

### 1. **`void`**
Тип `void` используется для функций, которые **ничего не возвращают**. Это похоже на `undefined` в JavaScript, но используется специально для того, чтобы указать, что функция не возвращает значения.

Пример:
```typescript
function logMessage(message: string): void {
  console.log(message);
}
```
Здесь функция `logMessage` ничего не возвращает, поэтому ее возвращаемый тип — `void`.

### 2. **`never`**
Тип `never` обозначает, что **функция никогда не завершится успешно** или **никогда не вернет значение**. Это может быть либо функция, которая вызывает ошибку (и выбрасывает исключение), либо бесконечный цикл.

Пример:
```typescript
function throwError(message: string): never {
  throw new Error(message);
}

function infiniteLoop(): never {
  while (true) {}
}
```
Здесь функции либо выбрасывают ошибку, либо зацикливаются бесконечно, и потому они никогда не возвращают значение.

### 3. `unknown`
Тип `unknown` используется, когда мы не знаем точный тип значения. Это более строгий аналог `any`. Работать с переменной типа `unknown` можно только после того, как убедитесь в ее типе (с помощью проверки типа, приведения или других методов).

Пример:
```typescript
let something: unknown;

something = "Hello";
something = 42;

if (typeof something === "string") {
  console.log(something.toUpperCase());  // Здесь безопасно использовать строковые методы
}
```
Тип `unknown` заставляет нас явно проверять тип перед тем, как использовать его, в отличие от `any`, где этого не требуется.

### Краткое резюме:
- `void`: функция ничего не возвращает.
- `never`: функция не завершится нормально или не вернет значение.
- `unknown`: значение может быть любого типа, и требуется проверка перед использованием.

## 26. Как вы отлавливаете ошибки в TypeScript коде?

Ошибки в TypeScript коде можно отлавливать с помощью:

- **Компилятора TypeScript**: Он выявляет ошибки на этапе компиляции.
- **Интегрированных средств разработки (IDE)**: IDE, такие как Visual Studio Code, предоставляют поддержку для
  обнаружения и исправления ошибок в реальном времени.
- **Unit тестов**: Написание тестов помогает находить и исправлять ошибки в коде.

## 27. Зачем нужны .d.ts файлы?

`.d.ts файлы` - это файлы декларации типов. Они содержат описание типов без реализации. Например, сигнатуры функций без
тела, название и тип глобальных переменных без значений. В основном файлы декларации типов нужны для написания библиотек
или при их использовании.

```JavaScript
declare

class Vector {
    readonly
    x: number;
    readonly
    y: number;
    static readonly
    zero: Vector;

    constructor(x: number, y: number);

    add(vector: Vector): Vector;
}
```

## 28. Как реализовать const в классе?

В TypeScript при объявлении свойств классов нельзя использовать ключевое слово const.

Начиная со второй версии TS, можно использовать модификатор readonly, позволяющий объявлять свойства класса,
предназначенные только для чтения.

## 29. Что такое пространства имён?

`Пространства имен в TypeScript` — это способ организации и группировки связанного кода. Они помогают избежать
столкновения имен и способствуют модульности, инкапсулируя связанный код. Пространства имен могут содержать классы,
интерфейсы, функции, переменные и другие пространства имен.

**Определение пространств имен**

Чтобы определить пространство имен, используйте ключевое слово namespace, за которым следует имя пространства имен.
Затем можно добавить любой связанный код внутри фигурных скобок.

```JavaScript
  namespace
MyNamespace
{
    export class MyClass {
        constructor(public

        value: number
    ) {
    }

    displayValue()
    {
        console.log(`The value is: ${this.value}`);
    }

}
}
```

В этом примере определяем пространство имен MyNamespace и добавляем в него класс MyClass. Учтите, что ключевое слово
export используется, чтобы сделать класс доступным за пределами пространства имен.

**Применение пространств имен**

Чтобы применить код из пространства имен, можно либо использовать полностью определенное имя, либо импортировать код с
помощью импорта пространства имен.

```JavaScript
  // Использование полностью определенного имени
const instance1 = new MyNamespace.MyClass(5);
instance1.displayValue(); // Вывод: Значение - 5

// Использование импорта пространства имен
import MyClass

= MyNamespace.MyClass;

const instance2 = new MyClass(10);
instance2.displayValue(); // Вывод: Значение - 10
```

Этот пример демонстрирует два способа использования класса MyClass из пространства имен MyNamespace. В первом случае
используем полностью определенное имя MyNamespace.MyClass. Во втором — применяем оператор импорта пространства имен,
чтобы импортировать класс MyClass и использовать его с более коротким именем.

**Вложенные пространства имен**

Пространства имен могут быть вложенными для создания иерархии и дальнейшей организации кода.

```JavaScript 
namespace
OuterNamespace
{
export
    namespace
    InnerNamespace
    {
        export class MyClass {
            constructor(public

            value: number
        ) {
        }

        displayValue()
        {
            console.log(`The value is: ${this.value}`);
        }
    }

    }
}

// Использование полностью определенного имени
const instance = new OuterNamespace.InnerNamespace.MyClass(15);
instance.displayValue(); // Вывод: Значение - 15
```

В этом примере определяем вложенное пространство имен InnerNamespace внутри OuterNamespace. Затем определяем класс
MyClass внутри вложенного пространства имен и используем его с полным именем OuterNamespace.InnerNamespace.MyClass.

## 30. Что такое предохранители типов?

`Предохранители типов в TypeScript` — это способ сузить тип переменной или параметра в определенном блоке кода. Они
позволяют дифференцировать различные типы и получать доступ к свойствам и методам, специфичным для этих типов,
обеспечивая безопасность типов и снижая вероятность ошибок во время выполнения.

**Определение предохранителей типов**

Чтобы определить предохранитель типа, создайте функцию, которая принимает переменную или параметр и возвращает предикат
типа. Предикат типа — это булево выражение, которое сужает тип параметра в пределах области видимости функции.

```JavaScript
  function isString(value: any): value

is
string
{
    return typeof value === "string";
}
```

В этом примере определяем функцию предохранителя типа isString, которая проверяет, является ли заданное значение типом
string. Функция возвращает предикат типа value is string, который сужает тип параметра value в пределах области
видимости функции.

**Использование предохранителей типов**

Чтобы использовать предохранитель типа, просто вызовите функцию предохранителя типа в условном операторе, например в if
и switch.

```JavaScript
  function processValue(value: string | number) {
    if (isString(value)) {
        console.log(`The length of the string is: ${value.length}`);
    } else {
        console.log(`The square of the number is: ${value * value}`);
    }
}
```

В этом примере определяем функцию processValue , которая принимает значение типа string | number. Используем функцию
предохранителя типа isString, чтобы проверить, является ли значение строкой. Если это так, обращаемся к свойству length,
характерному для string типа. В противном случае принимаем значение за number и вычисляем его квадрат.

**Теперь продемонстрируем, как работает предохранитель типа на практике.**

```JavaScript
  processValue("hello"); // Вывод: Длина строки - 5
processValue(42); // Вывод: Квадрат числа равен 1764
```

В этом примере вызываем функцию processValue как со строкой, так и с числом. Функция предохранителя типа isString
обеспечивает выполнение соответствующего блока кода для каждого типа, что позволяет получить доступ к свойствам и
методам, специфичным для конкретного типа, без ошибок типа.

## 31. Зачем нужен keyof?

Оператор keyof возвращает в качестве типа перечисление ключей объекта, по отношению к которому он применяется.

```JavaScript
  type
Point = {x: number; y: number};

type
P = keyof
Point;

// type P = “x” | “y”
```

## 32. Что такое Partial<>?

`Утилитарный тип Partial<T>` позволяет сделать все свойства типа T необязательными. Можно сказать, что он добавит
отметку ? рядом с каждым полем.

```JavaScript
interface Todo
{
    title: string;
    description: string;
}

function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {
    return {...todo, ...fieldsToUpdate};
}
```

## 33. Что такое Required<>?

В отличие от Partial утилитарный тип `Required<T>` принудительно делает все свойства объекта T обязательными.

```javascript
interface Props
{
    a?: number;
    b?: string;
}

const obj: Props = {a: 5};

const obj2: Required<Props> = {a: 5};

// Property 'b' is missing in type '{ a: number; }' but required in type 'Required<Props>'.
```

## 34. Что такое Pick<>?

Утилитарный тип `Pick<Type, Keys>` позволяет создать новый тип, взяв из Type свойства Keys.

```javascript
interface Todo {
  title: string;
  description: string;
  completed: boolean;
}

type TodoPreview = Pick<Todo, "title" | "completed">;

const todo: TodoPreview = {
  title: "Clean room",
  completed: false,
};
```

## 35. Что такое Omit<>?

Утилитарный тип `Omit<Type, Keys>` является противоположностью утилитарного типа Pick<Type, Keys>. С помощью Omit можно создать тип на основе имеющегося, исключив перечисленные свойства.

```javascript
interface Todo {
  title: string;
  description: string;
  completed: boolean;
  createdAt: number;
}
 
type TodoPreview = Omit<Todo, "description">;
 
const todo: TodoPreview = {
  title: "Clean room",
  completed: false,
  createdAt: 1615544252770,
};
```

## 36. Что такое Exclude<>?

`Exclude<UnionType, ExcludedMembers>` похож на Omit с тем лишь отличием, что первым параметром принимает UnionType, а не конкретный тип.

Он создает тип, исключая из UnionType указанные ExcludedMembers.

Обратите внимание на третий пример, это может работать даже так.

```javascript
type T0 = Exclude<"a" | "b" | "c", "a">;
// type T0 = "b" | "c"

type T1 = Exclude<"a" | "b" | "c", "a" | "b">;
// type T1 = "c"

type T2 = Exclude<string | number | (() => void), Function>;
// type T2 = string | number
```

## 37. Что такое Extract<>?

`Extract<Type, Union>` создает тип на основе извлеченного Union из Type.

```javascript
type T0 = Extract<"a" | "b" | "c", "a" | "f">;
// type T0 = "a"

type T1 = Extract<string | number | (() => void), Function>;
// type T1 = () => void
```

## 38. Что такое NonNullable<>?

`NonNullable<Type>` просто возвращает переданный тип, лишив его типов null и undefined.

```javascript
type T0 = NonNullable<string | number | undefined>;
// type T0 = string | number

type T1 = NonNullable<string[] | null | undefined>;
// type T1 = string[]
```

## 39. Что такое Parameters<>?

`Parameters<Type>` принимает на вход функцию и возвращает тип, описывающий её параметры.

```javascript
declare function myFunc(arg: { a: number; b: string }): void;

type Params = Parameters<typeof myFunc>;
//  type Params = [arg: {
//    a: number;
//    b: string;
//  }]
```

## 40. Что такое ReturnType<>?

`ReturnType<Type>` принимает на вход функцию и возвращает тип, описывающий возвращаемое ею значение.

```javascript
declare function f1(): { a: number; b: string };

type T1= ReturnType<typeof f1>;
//  type T1= {
//    a: number;
//    b: string;
//  }

type T2 = ReturnType<() => string>;
// type T2 = string
```